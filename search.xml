<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>KVM 虚拟化服务实践</title>
      <link href="/2021/kvm-practice/"/>
      <url>/2021/kvm-practice/</url>
      
        <content type="html"><![CDATA[<p>摘要:<br>KVM 虚拟化服务实践</p><span id="more"></span><h1 id="kvm-虚拟化服务"><a href="#kvm-虚拟化服务" class="headerlink" title="kvm 虚拟化服务"></a>kvm 虚拟化服务</h1><h2 id="1-架构"><a href="#1-架构" class="headerlink" title="1. 架构"></a>1. 架构</h2><p><img src="http://qiniu.itliusir.com/image-20210316143331879.png" alt="kvm-architecture"></p><h2 id="2-控制层"><a href="#2-控制层" class="headerlink" title="2. 控制层"></a>2. 控制层</h2><p>控制层负责对外提供虚拟机相关 API。</p><p>例如在接收到创建虚拟机请求后，会封装为相应的任务，会存储在 ETCD 中。</p><h3 id="2-1-调度"><a href="#2-1-调度" class="headerlink" title="2.1 调度"></a>2.1 调度</h3><ul><li><strong>节点选择</strong><ol><li>24 小时平均 cpubusy &lt; 50</li><li>15 分钟平均单核负载 &lt; 80</li><li>节点数超出预设值</li><li>可用内存小于 1GB</li><li>节点内存是否足够其使用(保留内存 + 当前节点任务队列的已需求内存 + 新来的节点内存 &gt; 物理机总内存 + 超卖内存)</li><li>磁盘是否足够使用</li></ol></li><li><strong>调度策略</strong><ol><li>按照主机域(zone)调度</li><li>扩容/批量多台机器选择在不同节点</li></ol></li><li><strong>最优节点选择</strong><ol><li>选择物理机已存在实例较少的</li><li>较少的区间里去选择cpu空闲的</li></ol></li></ul><h2 id="3-DB"><a href="#3-DB" class="headerlink" title="3. DB"></a>3. DB</h2><p>ETCD 负责存储数据。</p><p>基于 etcd 实现了任务的状态机，也存储了部分计算后的结果对外提供查询。</p><h2 id="4-Agent"><a href="#4-Agent" class="headerlink" title="4. Agent"></a>4. Agent</h2><p>订阅了 etcd ，例如在监听到删除虚拟机的任务后，负责执行对虚拟机的指令操作。</p><h3 id="4-1-创建虚机"><a href="#4-1-创建虚机" class="headerlink" title="4.1 创建虚机"></a>4.1 创建虚机</h3><ol><li><p>获取flavor配置(4c-4g-80g)</p></li><li><p>创建对应的disk</p></li><li><p>创建基础配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># tree /data/kvm/instances/</span><br><span class="line">---- uuid(实例id)</span><br><span class="line"> ---- config_drive</span><br><span class="line">   ---- openstack</span><br><span class="line">     ---- latest</span><br><span class="line">       ---- meta_data.json(password/id/name/secret)</span><br><span class="line">       ---- network_data.json</span><br><span class="line">       ---- user_data(init script)</span><br><span class="line">  ---- disk</span><br><span class="line">  ---- disk.config(mkisofs)</span><br><span class="line">  ---- libvirt.xml(kvm instance xml)</span><br><span class="line">---- _base(base os image)</span><br></pre></td></tr></table></figure></li><li><p>构建 libvirt.xml</p><img src="http://qiniu.itliusir.com/libvirt1.png" alt="libvirt-cpu" style="zoom:70%;" /><img src="http://qiniu.itliusir.com/libvirt2.png" alt="libvirt-devices" style="zoom:50%;" /></li></ol><p>调用 kvm 的 <a href="github.com/digitalocean/go-libvirt">go-libvirt</a> 工具库方法 <code>DomainDefineXMLFlags</code> 实现对虚机的创建</p><h3 id="4-2-销毁虚机"><a href="#4-2-销毁虚机" class="headerlink" title="4.2 销毁虚机"></a>4.2 销毁虚机</h3><p>调用 kvm 的 <a href="github.com/digitalocean/go-libvirt">go-libvirt</a> 工具库方法 <code>DomainDestroy</code>  实现对虚机的销毁</p><h2 id="5-OS-管理"><a href="#5-OS-管理" class="headerlink" title="5. OS 管理"></a>5. OS 管理</h2><p>每个机房会部署一个程序负责镜像的存储，会分发到不同的节点。</p><h3 id="5-1-宿主机-os-管理"><a href="#5-1-宿主机-os-管理" class="headerlink" title="5.1 宿主机 os 管理"></a>5.1 宿主机 os 管理</h3><p>宿主机在第一台虚机创建时，会去当前所在机房拉取镜像，拉完缓存在宿主机本地磁盘中，当前宿主机的所有 vm 实例(进程) 只有一个基础镜像。</p><p><a href="http://www.linux-kvm.org/page/Qcow2">Qcow2(QEMU Copy On Write)</a> 是格式镜像是 qemu 模拟器支持的一种镜像，和普通的 Raw 格式镜像相比，具有以下优点：</p><ul><li>更小的空间占用</li><li>支持 Copy On Write.</li><li>支持多级快照</li><li>支持压缩</li><li>支持 AES</li></ul><p>当前采用的镜像格式就是 Qcow2，共享一个基础镜像，写时Copy On Write</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷歌统一权限系统Zanzibar</title>
      <link href="/2021/paper-zanzibar/"/>
      <url>/2021/paper-zanzibar/</url>
      
        <content type="html"><![CDATA[<p>摘要:<br>Google Zanzibar 权限服务</p><span id="more"></span><h1 id="Zanzibar"><a href="#Zanzibar" class="headerlink" title="Zanzibar"></a>Zanzibar</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>Zanzibar 是一个用于存储和评估访问控制列表的全球系统。 Zanzibar 提供统一的数据模型和配置语言，用于表达来自 Google 数百个客户端服务的广泛访问控制策略，包括Calendar、Cloud、 Drive、Maps、Photos、YouTube。</p><img src="http://qiniu.itliusir.com/auth_exm.png" alt="image-20210616114929969" style="zoom:50%;" /><ul><li><p><strong>Consistent</strong></p><p>保证用户操作ACL的因果顺序，提供外部一致性。</p></li><li><p><strong>Flexible</strong></p><p>支持丰富的访问控制策略</p></li><li><p><strong>Scalable</strong></p><p>数以万亿计的 ACL 条目，百万check qps</p></li><li><p><strong>Fast</strong></p><p>95%请求小于10ms，99.9%请求小于100ms</p></li><li><p><strong>Available</strong></p><p>过去 3 年 可用率99.999%</p></li></ul><h2 id="2-模型"><a href="#2-模型" class="headerlink" title="2. 模型"></a>2. 模型</h2><h3 id="2-1-Relation-Tuples"><a href="#2-1-Relation-Tuples" class="headerlink" title="2.1 Relation Tuples"></a>2.1 Relation Tuples</h3><p>ACL 表示为关系元组的对象-用户或对象-对象关系的集合。组只是具有成员资格语义的 ACL。关系元组具有高效的二进制编码，我们使用方便的文本符号表示它们：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">⟨*tuple*⟩ ::= ⟨*object*⟩‘#’⟨*relation*⟩‘@’⟨*user*⟩ </span><br><span class="line"></span><br><span class="line">⟨*object*⟩ ::= ⟨*namespace*⟩‘:’⟨*object id*⟩ </span><br><span class="line"></span><br><span class="line">⟨*user*⟩ ::= ⟨*user id*⟩ | ⟨*userset*⟩ </span><br><span class="line"></span><br><span class="line">⟨*userset*⟩ ::= ⟨*object*⟩‘#’⟨*relation*⟩</span><br></pre></td></tr></table></figure><p><strong>Simple Example</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user1 has access on dir1</span></span><br><span class="line">dir1#access@user1</span><br><span class="line"><span class="comment">// Have a look on the subjects concept page if you don&#x27;t know the empty relation.</span></span><br><span class="line">dir1#parent@(file1#)</span><br><span class="line"><span class="comment">// Everyone with access to dir1 has access to file1. This would probably be defined</span></span><br><span class="line"><span class="comment">// through a subject set rewrite that defines this inherited relation globally.</span></span><br><span class="line"><span class="comment">// In this example, we define this tuple explicitly.</span></span><br><span class="line">file1#access@(dir1#access)</span><br><span class="line"><span class="comment">// Direct access on file2 was granted.</span></span><br><span class="line">file2#access@user1</span><br><span class="line"><span class="comment">// user2 is owner of file2</span></span><br><span class="line">file2#owner@user2</span><br><span class="line"><span class="comment">// Owners of file2 have access to it; possibly defined through subject set rewrites.</span></span><br><span class="line">file2#access@(file2#owner)</span><br></pre></td></tr></table></figure><img src="http://qiniu.itliusir.com/auth_exm2.png" alt="image-20210617160709202" style="zoom:50%;" /><h3 id="2-2-Consistency-Model"><a href="#2-2-Consistency-Model" class="headerlink" title="2.2 Consistency Model"></a>2.2 Consistency Model</h3><table><thead><tr><th>Example Tuple</th><th>Semantics</th></tr></thead><tbody><tr><td>doc:readme#owner@10</td><td>User 10 is an owner of doc:readme</td></tr><tr><td>group:eng#member@11</td><td>User 11 is a member of group:eng</td></tr><tr><td>doc:readme#viewer@group:eng#member</td><td>Members of group:eng are viewers of doc:readme</td></tr><tr><td>doc:readme#parent@folder:A#…</td><td>doc:readme is in folder:A</td></tr></tbody></table><h3 id="2-3-Relation-Configs"><a href="#2-3-Relation-Configs" class="headerlink" title="2.3 Relation Configs"></a>2.3 Relation Configs</h3><p>为了减少关系元组在表达关系上会出现很多条的关系组，客户端通过关系配置中的用户集重写规则来定义对象不可知的关系。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">name: &quot;doc&quot;</span><br><span class="line">relation &#123; name: &quot;owner&quot; &#125;</span><br><span class="line">relation &#123;</span><br><span class="line"> name: &quot;editor&quot;</span><br><span class="line"> userset_rewrite &#123;</span><br><span class="line">  union &#123;</span><br><span class="line">   child &#123; _this &#123;&#125; &#125;</span><br><span class="line">   child &#123; computed_userset &#123; relation: &quot;owner&quot; &#125; &#125;</span><br><span class="line">&#125;&#125;&#125;</span><br><span class="line">relation &#123;</span><br><span class="line"> name: &quot;viewer&quot;</span><br><span class="line"> userset_rewrite &#123;</span><br><span class="line">  union &#123;</span><br><span class="line">   child &#123; _this &#123;&#125; &#125;</span><br><span class="line">   child &#123; computed_userset &#123; relation: &quot;editor&quot; &#125; &#125;</span><br><span class="line">   child &#123; tuple_to_userset &#123;</span><br><span class="line">     tupleset &#123; relation: &quot;parent&quot; &#125;</span><br><span class="line">     computed_userset &#123;</span><br><span class="line">       object: $TUPLE_USERSET_OBJECT  # parent folder</span><br><span class="line">relation: &quot;viewer&quot; &#125;&#125;&#125;</span><br><span class="line">&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="child-节点"><a href="#child-节点" class="headerlink" title="child 节点"></a>child 节点</h4><ul><li><p><code>_this</code> </p><p>返回所有用户集合，默认行为</p></li><li><p><code>computed_userset</code> </p><p>计算出一个新的用户集合，例如使 viewer 用户引用 editor 用户。</p></li><li><p><code>tuple_to_userset</code><br>从输入对象中获取匹配的关系组，例如匹配其父级文件夹并继承其 viewer 权限</p></li></ul><blockquote><p> 一个用户集表达式也可以由多个子表达式组成，通过并集、交集和排除等操作组合。</p></blockquote><h2 id="3-架构"><a href="#3-架构" class="headerlink" title="3. 架构"></a>3. 架构</h2><img src="http://qiniu.itliusir.com/ayth_exm3.png" alt="image-20210616233003291" style="zoom:50%;" /><h3 id="3-1-aclserver"><a href="#3-1-aclserver" class="headerlink" title="3.1 aclserver"></a>3.1 aclserver</h3><p>aclservers 是主要的服务器类型。它们被组织成集群并响应 Check、Read、Expand 和 Write 请求。请求到达集群中的任何服务器，并且该服务器根据需要将工作分发到集群中的其他服务器。这些服务器可以依次联系其他服务器以计算中间结果。初始服务器收集最终结果并将其返回给客户端。</p><h3 id="3-2-watchserver"><a href="#3-2-watchserver" class="headerlink" title="3.2 watchserver"></a>3.2 watchserver</h3><p>watchservers 是一种特殊的服务器类型，可以响应 Watch 请求。他们跟踪更改日志并近乎实时地为客户端提供命名空间更改流。</p><h3 id="3-2-Storage"><a href="#3-2-Storage" class="headerlink" title="3.2 Storage"></a>3.2 Storage</h3><ul><li><p><strong>Namespace Config Storage</strong></p><p>命名空间配置存储在具有两个表的数据库中。一张表包含配置并以命名空间 ID 为键。另一个是配置更新的更改日志.</p></li><li><p><strong>Relation Tuple Storage</strong></p><p>每个命名空间的关系元组存储在一个单独的数据库中，其中每一行都由主键（分片 ID、对象 ID、关系、用户、提交时间戳）标识。主键的排序允许我们查找给定对象 ID 或（对象 ID，关系）对的所有关系元组。<br>我们的客户端根据其数据模式配置命名空间的分片。通常，分片 ID 仅由对象 ID 确定。在某些情况下，例如，当命名空间存储具有大量成员的组时，分片 ID 是根据对象 ID 和用户计算得出的。</p></li><li><p><strong>change log</strong></p><p>用于存储 Watch API 的元组更新历史记录。主键是（更改日志分片 ID、时间戳、唯一更新 ID），其中每次写入随机选择一个更改日志分片。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Paper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zanzibar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LevelDB</title>
      <link href="/2020/paper-leveldb/"/>
      <url>/2020/paper-leveldb/</url>
      
        <content type="html"><![CDATA[<p>摘要:<br>Google LevelDB 锁服务</p><span id="more"></span><h1 id="LevelDB"><a href="#LevelDB" class="headerlink" title="LevelDB"></a>LevelDB</h1><h2 id="1-Architecture"><a href="#1-Architecture" class="headerlink" title="1. Architecture"></a>1. Architecture</h2><p><img src="http://qiniu.itliusir.com/level_arch4.png"></p><blockquote><ul><li><p><em>MemTable</em></p><p>LevelDb 内存中的结构，写入先写入 <em>MemTable</em> ，其数据结构一般采用 skipList(O(log n) 时间复杂度) ，排序规则由用户自定义。</p></li><li><p><em>Immutable MemTable</em></p><p><em>MemTable</em> 达到阈值(4M, default) 会转化为不可变的 <em>MemTable</em> 快照 <em>Immutable MemTable</em> (只读) ，其数据结构和 <em>MemTable</em> 一模一样。</p></li><li><p><em>sstable</em></p><p>每当一个不可变的 <em>MemTable</em> 快照被创建时，后台异步线程就会将其持久化到一个 <em>sstable</em> 中。</p></li><li><p><em>log</em></p><p>WAL(write-ahead-log)，进程异常可以用来恢复数据。</p></li><li><p><em>manifest</em></p><p>每次 leveldb 启动时，都会创建一个新的 manifest 文件，记录每次 <strong>合并</strong> 变化的内容(增/删了哪些sstable)。</p></li><li><p><em>current</em></p><p>记录当前 <em>manifest</em> 文件名</p></li></ul></blockquote><h2 id="2-Put"><a href="#2-Put" class="headerlink" title="2. Put"></a>2. Put</h2><p>无论是 put 、 delete 还是batch操作，leveldb 底层都是以 batch 作为执行实例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Batch is a write batch.</span></span><br><span class="line"><span class="keyword">type</span> Batch <span class="keyword">struct</span> &#123;</span><br><span class="line">data  []<span class="keyword">byte</span></span><br><span class="line">index []batchIndex</span><br><span class="line"><span class="comment">// internalLen is sums of key/value pair length plus 8-bytes internal key.</span></span><br><span class="line">internalLen <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>leveldb的写入是类似线程组的模式，各个线程会将任务其放入队列中，拿到锁的线程会批量取任务然后合并后写入。</p><p><img src="http://qiniu.itliusir.com/level_write.png"></p><h2 id="3-Read"><a href="#3-Read" class="headerlink" title="3. Read"></a>3. Read</h2><p>读取流程比较简单，按照 Memtable –&gt; Immutable –&gt; sstable(level0~7)</p><blockquote><p>对于文件的读取，每次读取会减少其 score，具体作用可以看 <em>Major Compaction</em> 的过程四。</p></blockquote><h2 id="4-Compaction"><a href="#4-Compaction" class="headerlink" title="4. Compaction"></a>4. Compaction</h2><h3 id="4-1-Minor-Compaction"><a href="#4-1-Minor-Compaction" class="headerlink" title="4.1  Minor Compaction"></a>4.1  Minor Compaction</h3><p>内存的持久化在 leveldb 称为 <strong>Minor Compaction</strong> ，每次 <em>minor compaction</em> 都会产出一个 level 0层的 sstable，多个文件中可能会存在数据 overlap。</p><p>因为 <em>minor compaction</em> 必须要在短时间完成(阻塞写入操作)，因此其优先级要比 <em>Major Compaction</em> 更高，在进行 <em>minor compaction</em> 时会暂停 <em>Major Compaction</em></p><blockquote><p>overlap，因为内存的 memtable 是按照阈值分割的，所以可能出现一个数据存在多个文件中</p></blockquote><h3 id="4-2-Major-Compaction"><a href="#4-2-Major-Compaction" class="headerlink" title="4.2 Major Compaction"></a>4.2 Major Compaction</h3><p>随着 level 0层的 sstable 越来越多，导致查询越来越慢，leveldb 会将 level 0层的文件进行<strong>归并</strong>到 level 1层，这个操作称为 <strong>Major Compaction</strong> 。</p><p>当用户写入的速度始终大于 <em>Major Compaction</em> 时，会导致 level 0层的文件数量越来越多，读取性能持续拉胯，leveldb 为此设计了一种平衡策略:</p><ul><li>当 level 0层文件数量超过阈值1(8,default)时，减缓写入速度</li><li>当 level 0层文件数量超过阈值2(12,default)时，写入暂停，直到 <em>Major Compaction</em> 完成</li></ul><blockquote><p><em>Major Compaction 触发条件：</em> </p><ol><li>level 0层文件数量超过阈值</li><li>level i层总大小超过阈值</li><li>某个文件读取次数过多</li></ol></blockquote><h4 id="4-2-1-过程一、寻找原始输入文件"><a href="#4-2-1-过程一、寻找原始输入文件" class="headerlink" title="4.2.1 过程一、寻找原始输入文件"></a>4.2.1 过程一、寻找原始输入文件</h4><p>采用轮换的方法选择文件，第一批选完会记录其最大key，下一次从这个key后的文件开始，如下图中选中了黄色区域。</p><p><img src="http://qiniu.itliusir.com/level_compaction1.png"></p><h4 id="4-2-2-过程二、扩大输入文件"><a href="#4-2-2-过程二、扩大输入文件" class="headerlink" title="4.2.2 过程二、扩大输入文件"></a>4.2.2 过程二、扩大输入文件</h4><p>在当前层继续寻找与过程一原始输入文件有重叠的文件，如下图中选中了蓝色区域。</p><p><img src="http://qiniu.itliusir.com/level_compaction2.png"></p><h4 id="4-2-3-过程三、多路归并"><a href="#4-2-3-过程三、多路归并" class="headerlink" title="4.2.3 过程三、多路归并"></a>4.2.3 过程三、多路归并</h4><p>将选中的文件集合，进行冗余清理、归并排序到原始输入文件的下一个level (如下图是归并到 level 1中的红色区域)。</p><p><img src="http://qiniu.itliusir.com/level_compaction3.png"></p><h4 id="4-2-4-过程四、计算积分"><a href="#4-2-4-过程四、计算积分" class="headerlink" title="4.2.4 过程四、计算积分"></a>4.2.4 过程四、计算积分</h4><ul><li><strong>计分规则1：</strong></li></ul><ol><li>level 0层，score = level 0层文件总数 / 4</li><li>level i层，score = level i层文件总数据量 / level i层数据最大量</li></ol><p>根据得分来选择合并的 level</p><ul><li><strong>计分规则2：</strong></li></ul><p>为每个新的 sstable 文件维护初始分数为 100，每查一次该文件就减一，递减到0会被标记为待合并。</p>]]></content>
      
      
      <categories>
          
          <category> Paper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LevelDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chubby 锁服务</title>
      <link href="/2020/paper-chubby/"/>
      <url>/2020/paper-chubby/</url>
      
        <content type="html"><![CDATA[<p>摘要:<br>Google Chubby 锁服务</p><span id="more"></span><h1 id="Chubby-锁服务"><a href="#Chubby-锁服务" class="headerlink" title="Chubby 锁服务"></a>Chubby 锁服务</h1><h2 id="1-定位"><a href="#1-定位" class="headerlink" title="1. 定位"></a>1. 定位</h2><p><em>We describe our experiences with the Chubby lock ser- vice, which is intended to provide coarse-grained lock- ing as well as reliable (though low-volume) storage for a loosely-coupled distributed system</em></p><p>我们描述了Chubby锁服务的经验，该服务旨在为松耦合的分布式系统 <strong>提供粗粒度的锁</strong> 以及 <strong>可靠的（尽管容量较小）存储</strong></p><blockquote><p>这里粗粒度的锁指的是应用加锁的时间比较长，例如 leader election</p><p>chubby 服务本质上不算新的研究成果，而是一种工程上的努力实现</p></blockquote><h3 id="1-1-lock-vs-distributed-library"><a href="#1-1-lock-vs-distributed-library" class="headerlink" title="1.1 lock vs distributed library"></a>1.1 lock vs distributed library</h3><p>Google 内部实际上也提供了一个独立于 Chubby 的一致性库(基于paxos)，但考虑到锁服务有如下一些优点：</p><ol><li>开发者(用户侧) 在应用刚起步的时候并不会像我们想象的考虑高可用，代码也没有为使用一致性协议而专门优化。(PS: 好的架构是演化来的)</li><li>可以在锁服务存储少量数据。</li><li>开发者(用户侧) 更熟悉锁的接口、临界区，而不用去考虑底层的一些细节。</li><li>锁服务可以减少对接的业务节点数量(使用一致性库需要使用 quorum)</li></ol><h2 id="2-系统架构"><a href="#2-系统架构" class="headerlink" title="2. 系统架构"></a>2. 系统架构</h2><p><a href="http://qiniu.itliusir.com/chubby_struct.png"><img src="http://qiniu.itliusir.com/chubby_struct.png" alt="img"></a></p><p>一个 chubby 单元由副本集合组成(通常是5个、放在不同的机柜)，这些副本通过一次 paxos 选举出一个 master，同时要保证在 master 的租约有效期内不会再选举另一个 master，租约会周期性的更新。</p><p>master 负责读写，slave 只是复制 master。客户端通过请求 DNS 获取各副本列表，然后像这些副本发送 master 定位请求，非 master 副本返回 master标识，一旦定位到 master 则将请求全部切到 master (直到 master 失去响应或者 因为不再是 master 拒绝请求)。</p><blockquote><p>对于 <strong>副本异常</strong> 且无法自动恢复的场景，一个替换系统会从空闲的机器池中选择一台新的机器并运行 chubby 服务，然后更新 DNS 表，将出错的改为新的。并且从文件系统的备份中选择一份最近的数据和接收最新的更新。</p><p>master 节点会定期检测 DNS 表，在发现该变化时会更新它所在的单元的副本列表</p></blockquote><h2 id="3-文件系统设计"><a href="#3-文件系统设计" class="headerlink" title="3. 文件系统设计"></a>3. 文件系统设计</h2><p>Chubby提供了一个类似于UNIX但是相对简单的文件系统接口。</p><p><em>/ls/foo/wombat/pouch</em></p><ul><li><em>ls</em> 代表了 lock service</li><li><em>foo</em> 代表了 foo 这个chubby单元，通过 DNS 解析为一组副本。特殊单元 <em>local</em> 表示了离客户端最近的那个单元</li><li><em>/wombat/pouch</em> 由落到的 foo 单元自行处理</li></ul><blockquote><p>这样的设计可以降低使用的门槛，文件和目录统称为Node，和client同生命周期的临时节点可以用来实现节点存活监控。</p><p>Node 除了记录数据外还包括了一些元信息</p></blockquote><h3 id="3-1-元信息"><a href="#3-1-元信息" class="headerlink" title="3.1 元信息"></a>3.1 元信息</h3><ul><li>ACL<ul><li><em>/r/acl/node1</em> – user1</li><li><em>/w/acl/node1</em> – user1</li></ul></li><li>四个严格递增的64位数字<ul><li>实例编号 (大于该节点之前的任何实例编号)</li><li>内容版本号 (内容发生改变时，随之增加)</li><li>锁版本号 (锁发生状态变化时，随之增加)</li><li>ACL版本号 (权限被修改时，随之增加)</li></ul></li></ul><h2 id="4-锁接口设计"><a href="#4-锁接口设计" class="headerlink" title="4. 锁接口设计"></a>4. 锁接口设计</h2><ul><li>每一个 Node 都可以作为一个读写锁，要么是一个 client 独占读锁，要么是多个 client 共享写锁。</li><li>提供友好的API：<ul><li>open,close</li><li>Acquire,TryAcquire,Release</li><li>GetContentsAndStat,SetContents,SetACL</li><li>Delete</li><li>GetSequencer,SetSequencer,CheckSequencer</li></ul></li></ul><h3 id="4-1-实现"><a href="#4-1-实现" class="headerlink" title="4.1 实现"></a>4.1 实现</h3><ol><li>发起 Acquire request, master 生成<strong>锁描述 Sequencer</strong> 和 <strong>lock 版本号</strong>，在对应节点的元信息中记录这个<strong>lock版本号</strong> ，每次被Acquire 时加一</li><li>Acquire request 成功后，在对应的 Handler 也记录这个 <strong>锁描述 Sequencer</strong></li><li>后续的操作通过对比元信息的 <strong>锁描述 Sequencer</strong> 和 <strong>lock 版本号</strong> 判断是否有效</li><li>发起Release request，则释放并修改对应元信息</li></ol><h3 id="4-2-事件"><a href="#4-2-事件" class="headerlink" title="4.2 事件"></a>4.2 事件</h3><ul><li>文件内容改变</li><li>子节点的增删改</li><li>master 故障恢复</li><li>锁的获取</li><li>锁冲突</li></ul><blockquote><p>这里的事件都是实际动作发生后才传递的。</p></blockquote><h2 id="5-Cache-amp-Session-amp-Fail-overs"><a href="#5-Cache-amp-Session-amp-Fail-overs" class="headerlink" title="5. Cache &amp; Session &amp; Fail-overs"></a>5. Cache &amp; Session &amp; Fail-overs</h2><h3 id="5-1-cache"><a href="#5-1-cache" class="headerlink" title="5.1 cache"></a>5.1 cache</h3><p>Chubby 的 Cache 主要用来缓存文件数据、元信息。当文件发生改变时，修改的请求会被阻塞，直到 master 将失效通知发给所有的客户端。</p><h3 id="5-2-session"><a href="#5-2-session" class="headerlink" title="5.2 session"></a>5.2 session</h3><p>Chubby 的 Session 是 Chubby Cell 和 Chubby 客户端的一种关系，通过周期性的 KeepAlive 握手维护。</p><p>每个 Session 都通过一个租约时间来保证 master 不单方面结束会话。</p><p>master 在下面的三个时机会选择续期租约：</p><ul><li>会话刚创建时</li><li>master 发生故障恢复时</li><li>在租约快到期响应客户端的 KeepAlive RPC 调用时 (master 在收到 client 的 KeepAlive RPC 时，会阻塞到本地，直到租约快到期，master 会延长租约时间(默认是12s)并返回阻塞的 KeepAlive RPC 给 client)</li><li>client 的租约过期会进入 <strong>jeopardy 状态</strong>，client 会进入一个宽限期(grace period，默认45s)，以期待与 master 重新进行 KeepAlive 交互，如果还是无法交互则返回失败。</li></ul><blockquote><ol><li>这样的设计可以保证通常只有一个 KeepAlive 调用阻塞在master端</li><li>客户端也维护了一个本地租约时间，它的过期时间要比 master 久(1. KeepAlive 的传输时间 2. master 时钟快于 client)</li><li>宽限期可以保障在API调用时候不会无限期的阻塞</li></ol></blockquote><h3 id="5-3-Fail-overs"><a href="#5-3-Fail-overs" class="headerlink" title="5.3 Fail-overs"></a>5.3 Fail-overs</h3><p><a href="http://qiniu.itliusir.com/chubby_keepalives.png"><img src="http://qiniu.itliusir.com/chubby_keepalives.png" alt="img"></a></p><p>我们重点关注在宽限期(grace period)内，新的 master 被选举出来后的恢复操作，如下步骤所示：</p><ol><li>它会选择一个新的epoch number (master 会拒绝使用老的 epoch 编号的客户端)</li><li>恢复 Session 和 锁的内存数据结构，租约会被重置一个很大的值</li><li>master 开始接受 client 的 KeepAlive RPC，第一个因为 epoch 是老的会被拒绝，第二个会带着第一个返回的最新 epoch 发起请求，master 立即返回并通知 client 设置本地的 租约时间(lease C3)，接着 master 开始阻塞第三个 KeepAlive RPC，恢复正常！</li></ol><h2 id="6-Chubby-的使用"><a href="#6-Chubby-的使用" class="headerlink" title="6. Chubby 的使用"></a>6. Chubby 的使用</h2><p>以论文中选主场景为例：</p><ol><li>潜在参与选主的节点，调用 <code>open()</code> 同一个节点，然后用返回的 Handler 调用 <code>Aquire()</code></li><li>只有一个成功拿到锁，成为 Primary 节点，其余的是 Secondary 节点</li><li>Primary 节点调用 <code>SetContents()</code> 写入自己的标识，client 和其他 Secondary 通过 <code>GetContentsAndStat()</code> 获取该信息，并注册监听内容变化的 Event，以便发现 Primary 的改变</li><li>Primary 节点 通过 <code>GetSequencer()</code> 获取一个sequencer，发给它所通信的依赖锁的服务，该服务通过<code>CheckSequencer()</code> 来验证它是否仍然是 Primary</li></ol><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>可以发现，Chubby 是有很多的优化和稳定努力，例如通过增加租约时间来减少 rpc造成的负载、增加缓存提高读的性能、对于资源的全面监控可以更好的做降级、单元的不同副本不同机柜、每隔几个小时会把存储数据快照写入另一栋楼的 GFS 文件系统，避免了 GFS 和 Chubby 的循环依赖。</p>]]></content>
      
      
      <categories>
          
          <category> Paper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chubby </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadPoolExecutor 源码分析</title>
      <link href="/2020/20-ThreadPoolExecutor/"/>
      <url>/2020/20-ThreadPoolExecutor/</url>
      
        <content type="html"><![CDATA[<h2 id="TOP-带着问题看源码"><a href="#TOP-带着问题看源码" class="headerlink" title="TOP 带着问题看源码"></a>TOP 带着问题看源码</h2><ol><li>ThreadPoolExecutor 线程池是如何实现的</li></ol><span id="more"></span><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p>前面文章的 Thread 我们也分析了，因为 Java 中的Thread 和 内核线程是 1 : 1 的，所以线程是一个重量级的对象，应该避免频繁创建和销毁，我们可以使用线程池来避免。</p><p>ThreadPoolExecutor 是 Java 实现的线程池，它并没有采取常见的池化资源的设计方法，而是采用的 <strong>生产者-消费者</strong> 模式。</p><p><a href="http://qiniu.itliusir.com/threadpool01.png"><img src="http://qiniu.itliusir.com/threadpool01.png" alt="img"></a></p><p>上图的左边是线程池的核心体系，右边是 JDK 提供创建线程池的工具类。</p><p><em>Executor 接口</em></p><p>提供最基础的执行方法 execute(Runnable command)</p><p><em>ExecutorService 接口</em></p><p>基于 Executor 接口，新增了线程池的一些操作能力</p><p><em>AbstractExecutorService 抽象类</em></p><p>使用模板模式，丰富了一部分操作的细节流程</p><p><em>ForkJoinPool 实现类</em></p><p>jdk1.7 中新增的线程池类，适用于分治的场景</p><h2 id="2-成员变量-amp-核心类分析"><a href="#2-成员变量-amp-核心类分析" class="headerlink" title="2. 成员变量 &amp; 核心类分析"></a>2. 成员变量 &amp; 核心类分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 控制变量 前 3 位标示运行状态，后 29 位标识工作线程的数量</span></span><br><span class="line"><span class="comment">// 初始化为 RUNNING 状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 移位的段</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 后29位，标识容量</span></span><br><span class="line"><span class="comment">// ‭0001 1111 1111 1111 1111 1111 1111 1111‬</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 下面是线程池状态</span></span><br><span class="line"><span class="comment">// 表示可以接受新任务，且可执行队列的任务</span></span><br><span class="line"><span class="comment">// 111 0 0000 ... 0000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 不接收新任务，但可以执行队列的任务</span></span><br><span class="line"><span class="comment">// 000 0 0000 ... 0000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 中断正在执行的，不再接收和执行队列的任务</span></span><br><span class="line"><span class="comment">// 001 0 0000 ... 0000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 半中止状态，所有任务都已中止且无工作线程,修改为这个状态，然后执行 terminated() 方法</span></span><br><span class="line"><span class="comment">// 010 0 0000 ... 0000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 中止状态,已经执行过 terminated() 方法</span></span><br><span class="line"><span class="comment">// 011 0 0000 ... 0000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 获取状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 获取工作线程的数量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="comment">// ctl 的值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure><h2 id="3-核心方法分析"><a href="#3-核心方法分析" class="headerlink" title="3. 核心方法分析"></a>3. 核心方法分析</h2><h3 id="3-1-普通任务提交"><a href="#3-1-普通任务提交" class="headerlink" title="3.1 普通任务提交"></a>3.1 普通任务提交</h3><h4 id="3-1-1-execute-Runnable-command"><a href="#3-1-1-execute-Runnable-command" class="headerlink" title="3.1.1 execute(Runnable command)"></a>3.1.1 execute(Runnable command)</h4><p>主要过程就是：</p><ol><li>如果当前工作线程没有达到核心线程数量阈值，就直接添加一个核心工作线程</li><li>如果达到了核心线程数量阈值，就入任务队列，如果状态不正常，执行拒绝策略</li><li>如果队列满了，就创建非核心线程</li><li>如果创建非核心线程失败(达到了最大数量阈值、线程池状态不正常)，执行拒绝策略</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 如果工作线程数小于核心数</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// 添加一个核心工作线程</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果线程池状态正常，并且达到了核心数量，就入队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 再次检查状态，如果不是运行状态就移除任务并执行拒绝策略</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 再次检查，如果工作线程数量是0，就创建一个</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果入队列失败，就尝试创建非核心工作线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        <span class="comment">// 创建非核心线程失败，执行拒绝策略</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-2-addWorker-Runnable-firstTask-boolean-core"><a href="#3-1-2-addWorker-Runnable-firstTask-boolean-core" class="headerlink" title="3.1.2 addWorker(Runnable firstTask, boolean core)"></a>3.1.2 addWorker(Runnable firstTask, boolean core)</h4><p><code>addWorker</code> 方法主要作用就是创建一个工作线程，并加入到工作线程的集合中，然后启动。在此期间会进行状态和数量的校验。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 校验状态</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">// 校验工作线程数量</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 数量+1 跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建工作线程，把 firstTask 封装到 Worker 对象，然后把 Worker 对象传给 thread</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"><span class="comment">// 再次检查状态</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    <span class="comment">// 加入到工作线程集合</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="comment">// 目前集合的数量</span></span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    <span class="comment">// 标记添加成功</span></span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">// 添加成功就启动线程</span></span><br><span class="line">                <span class="comment">// 通过上面 new Worker 的分析，我们知道这里会调用 Worker对象的 run方法</span></span><br><span class="line">                <span class="comment">// run 方法里接着调用 runWorker(this)</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 没有启动成功，执行降级方法(从集合中清除掉、数量减少、)</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-3-runWorker-Worker-w"><a href="#3-1-3-runWorker-Worker-w" class="headerlink" title="3.1.3 runWorker(Worker w)"></a>3.1.3 runWorker(Worker w)</h4><p>如果有第一个任务就先执行，之后从任务队列取任务执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前工作线程</span></span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// ???</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// task如果为空就取任务，如果任务也取不到就结束循环</span></span><br><span class="line">        <span class="comment">// getTask() 方法主要就是从任务队列中取任务</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// 检查状态</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 任务执行前扩展方法，例如：可以在执行前等待实现暂停的效果</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行任务</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 任务执行后扩展方法，例如：可以在执行后释放一些资源</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 置 null,重新从队列取</span></span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 增加完成数</span></span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-异步任务提交"><a href="#3-2-异步任务提交" class="headerlink" title="3.2 异步任务提交"></a>3.2 异步任务提交</h3><h4 id="3-2-1-submit-Callable-task"><a href="#3-2-1-submit-Callable-task" class="headerlink" title="3.2.1 submit(Callable task)"></a>3.2.1 submit(Callable task)</h4><p><code>submit</code> 方法定义在模板类 <code>AbstractExecutorService</code> 中，然后把 task 封装为 <code>FutureTask</code> , 最后调用 <code>execute</code> 方法来提交任务</p><p><em>AbstractExecutorService#submit</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们上面分析 <code>execute</code> 方法知道其最终执行的地方还是调用的 task 的 run 方法，所以我们来分析 FutureTask 的 run 方法。</p><h4 id="3-2-2-run"><a href="#3-2-2-run" class="headerlink" title="3.2.2 run()"></a>3.2.2 run()</h4><p>主要是多了一个执行结果的记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 线程状态不为 NEW 或者 修改当前线程来运行当前任务失败，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                     <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="comment">// 再次校验线程状态</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            <span class="comment">// 注意盯着这个运行结果变量</span></span><br><span class="line">            V result;</span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 任务执行</span></span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 执行异常就修改线程状态为 EXCEPTIONAL</span></span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                <span class="comment">// 执行正常就修改线程的状态为 NORMAL</span></span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-3-get"><a href="#3-2-3-get" class="headerlink" title="3.2.3 get()"></a>3.2.3 get()</h4><p>主要思路就是自旋等待线程执行完</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public V get() throws InterruptedException, ExecutionException &#123;</span><br><span class="line">    int s = state;</span><br><span class="line">    <span class="comment">// 如果线程状态没完成，就进入等待队列</span></span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(<span class="literal">false</span>, 0L);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int awaitDone(boolean timed, long nanos)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">    final long deadline = timed ? System.nanoTime() + nanos : 0L;</span><br><span class="line">    WaitNode q = <span class="literal">null</span>;</span><br><span class="line">    boolean queued = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            removeWaiter(q);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int s = state;</span><br><span class="line">        <span class="comment">// 已完成就返回</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q != <span class="literal">null</span>)</span><br><span class="line">                q.thread = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 快完成(异常)，就等一会</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        <span class="comment">// 第一次进来一般会走到这里，把当前线程构建一个等待节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="literal">null</span>)</span><br><span class="line">            q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">        <span class="comment">// 第二次循环尝试把节点入队</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">            queued = UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, waitersOffset,</span><br><span class="line">                                                 q.next = waiters, q);</span><br><span class="line">        <span class="comment">// 如果有超时时间</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= 0L) &#123;</span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="keyword">return</span> state;</span><br><span class="line">            &#125;</span><br><span class="line">            LockSupport.parkNanos(<span class="built_in">this</span>, nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果发现入队失败(已经入队过了)，就挂起当前线程</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>可以看到，线程池实际上是一个生产-消费模型的实现，其支持普通任务提交和异步任务提交(ps.. 其实叫异步并不是很合适，对于用户来说线程池本来就是异步的)。</p><p>知道了核心数量以及等待队列还有最大数量这些功能的实现，相信对如何更好的使用线程池会更有帮助。</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThreadPoolExecutor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal 源码分析</title>
      <link href="/2020/19-ThreadLocal/"/>
      <url>/2020/19-ThreadLocal/</url>
      
        <content type="html"><![CDATA[<h2 id="TOP-带着问题看源码"><a href="#TOP-带着问题看源码" class="headerlink" title="TOP 带着问题看源码"></a>TOP 带着问题看源码</h2><ol><li>ThreadLocal 是怎么保证不同线程内部的变量隔离的</li><li>你说了ThreadLocalMap,那它是如何解决Hash冲突的</li><li>ThreadLocal 什么情况下会内存泄漏</li></ol><span id="more"></span><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p>我们知道解决共享变量不安全的一种方式，就是利用每个线程的私有变量来操作，避免共享变量导致的线程不安全问题。</p><p>ThreadLocal 就是提供一个局部变量，不会遇到并发问题。</p><h2 id="2-成员变量-amp-核心类分析"><a href="#2-成员变量-amp-核心类分析" class="headerlink" title="2. 成员变量 &amp; 核心类分析"></a>2. 成员变量 &amp; 核心类分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算hash值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"><span class="comment">// 使用原子类记录hash值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode =</span><br><span class="line">    <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="comment">// 魔数，更好的分散数据</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread.class</span></span><br><span class="line"><span class="comment">// 每个线程类都会有一个 ThreadLocalMap</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.lang.ThreadLocal.ThreadLocalMap </span></span><br><span class="line"><span class="comment">// 初始化容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 存储数据数组</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"><span class="comment">// 元素个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 扩容的阈值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">// 构造方法，初始化值</span></span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到问题 <strong>TOP 1</strong> ，可以知道是不同线程都有自己的 ThreadLocalMap ，也就天然做到了隔离</p><h3 id="2-1-ThreadLocal-内存泄漏的原因"><a href="#2-1-ThreadLocal-内存泄漏的原因" class="headerlink" title="2.1 ThreadLocal 内存泄漏的原因"></a>2.1 ThreadLocal 内存泄漏的原因</h3><p>通过对变量和核心类的分析，相信对 ThreadLocal 的一个结构有了大致的了解，接下来我们先来看下 ThreadLocal 的 map 是怎么定义的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    Object value;</span><br><span class="line"><span class="comment">// 注意，这里 k 作为弱引用</span></span><br><span class="line">    <span class="comment">// 原因是如果是强引用，我们如果把 threadlocal 置为 null 不再使用，但是其在线程中的 threadlocalmap还在，导致无法gc</span></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到问题 <strong>TOP 3</strong> ，由此可以分析，在 gc 的情况下，k 会出现为 null，也就会出现 value 还在但是无法拿到的情况(内存泄漏)。</p><p>实际上在 ThreadLocal 中这个问题并不是想象的那么可怕，其核心方法基本都会对这种无效的数据进行清理。</p><h2 id="3-核心方法分析"><a href="#3-核心方法分析" class="headerlink" title="3. 核心方法分析"></a>3. 核心方法分析</h2><h3 id="3-1-set-数据"><a href="#3-1-set-数据" class="headerlink" title="3.1 set 数据"></a>3.1 set 数据</h3><p>核心逻辑就是：</p><ol><li>把数据放到当前线程的 ThreadLocalMap 的 value</li><li>如果当前 key 的位置已经有了就覆盖</li><li>如果当前位置的元素与当前 key 不相等，就插入下一个可以放置元素的地方</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程的 ThreadLocalMap</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 这里this是指的调用这个方法的threadlocal对象</span></span><br><span class="line">        <span class="comment">// 调用 set 方法</span></span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 还没有就创建一个map</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">// 根据 hash 计算位置</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 循环，如果第一次没有获取到 key 相同的，就循环下一个位置</span></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="comment">// 获取 key</span></span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"><span class="comment">// key 相同，直接覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// key 为空就调用 replaceStaleEntry，见下文</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 走到这里说明目标位置是空的，构建元素放到存储数组中</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="comment">// 增加元素个数</span></span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="comment">// 如果不再有无用元素，并且容量超过了阈值，就扩容</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到问题 <strong>TOP 2</strong> ，可以知道其处理 hash 冲突采用的是开放寻址法，位置已被占就会找下一个。在数据量较少的场景，这个是很合适的。</p><h3 id="3-2-get-数据"><a href="#3-2-get-数据" class="headerlink" title="3.2 get 数据"></a>3.2 get 数据</h3><p>核心逻辑就是：</p><ol><li>把当前线程的 ThreadLocalMap 的 value 取出来</li><li>如果按照 hash 查找到的 key 不一样，说明出现 hash 冲突了，调用 <code>getEntryAfterMiss()</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程的 ThreadLocalMap</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用 getEntry 根据 key 查找到 value</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据hash值确定位置，获取元素</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果 key 不相同或者值为null，调用 getEntryAfterMiss</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-辅助方法"><a href="#3-3-辅助方法" class="headerlink" title="3.3 辅助方法"></a>3.3 辅助方法</h3><h4 id="3-3-1-getEntryAfterMiss"><a href="#3-3-1-getEntryAfterMiss" class="headerlink" title="3.3.1 getEntryAfterMiss"></a>3.3.1 getEntryAfterMiss</h4><p>该方法主要是用来处理 hash 冲突的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"><span class="comment">// 死循环</span></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 当 key 也相同时候就返回</span></span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="comment">// 如果 key 为 null 调用 expungeStaleEntry</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 获取下一个位置</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        <span class="comment">// 获取新的位置元素</span></span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-expungeStaleEntry"><a href="#3-3-2-expungeStaleEntry" class="headerlink" title="3.3.2 expungeStaleEntry"></a>3.3.2 expungeStaleEntry</h4><p>核心逻辑就是：</p><ol><li>清理无效的 entity</li><li>往后继续搜索和清理，直到 tab[i] == null 退出</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除无效元素</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 循环，直到 tab[i] == null 退出</span></span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 如果再次发现 key 为 null 的都删掉</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 处理 rehash 情况</span></span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-3-cleanSomeSlots"><a href="#3-3-3-cleanSomeSlots" class="headerlink" title="3.3.3 cleanSomeSlots"></a>3.3.3 cleanSomeSlots</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 获取下一个索引值</span></span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">        Entry e = tab[i];</span><br><span class="line">        <span class="comment">// 如果这个索引对应的 value 不为空 并且 key 是空的</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 重置n为哈希表大小</span></span><br><span class="line">            n = len;</span><br><span class="line">            removed = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 清理无效的 entity</span></span><br><span class="line">            <span class="comment">// expungeStaleEntry我们前面也分析了,会往后找到所有无效的 entity</span></span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 每次搜索范围减少一半</span></span><br><span class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>可以看到，ThreadLocal 在完成基本功能之外，做了很多辅助操作来避免内存泄漏，这种严谨的做法也值得我们在工作中来做。</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程的实现与分析</title>
      <link href="/2020/18-Thread/"/>
      <url>/2020/18-Thread/</url>
      
        <content type="html"><![CDATA[<h2 id="TOP-带着问题来分析"><a href="#TOP-带着问题来分析" class="headerlink" title="TOP 带着问题来分析"></a>TOP 带着问题来分析</h2><ol><li>Java 的线程模型</li><li>Java 的线程状态</li><li>Java线程的 join 实现原理</li></ol><span id="more"></span><h2 id="1-线程模型"><a href="#1-线程模型" class="headerlink" title="1. 线程模型"></a>1. 线程模型</h2><p>线程是操作系统调度的最小单位，实现线程有三种方式，而 Java Thread 采用的是 <strong>内核线程实现</strong></p><h3 id="1-1-用户层实现-N-1"><a href="#1-1-用户层实现-N-1" class="headerlink" title="1.1 用户层实现(N:1)"></a>1.1 用户层实现(N:1)</h3><p><a href="http://qiniu.itliusir.com/thread02.png"><img src="http://qiniu.itliusir.com/thread02.png" alt="img"></a></p><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li>用户线程切换不需要内核介入，切换很快、代价相对低</li><li>用户线程操作成本低</li></ul><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li>用户线程自己进行管理，比较麻烦</li><li>阻塞处理复杂</li><li>如何将线程映射到其他处理器</li></ul><h3 id="1-2-内核线程实现-1-1"><a href="#1-2-内核线程实现-1-1" class="headerlink" title="1.2 内核线程实现(1:1)"></a>1.2 内核线程实现(1:1)</h3><p>每一个用户线程对应一个内核线程，内核去完成线程的创建和调度。</p><p><a href="http://qiniu.itliusir.com/thread03.png"><img src="http://qiniu.itliusir.com/thread03.png" alt="img"></a></p><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ul><li>阻塞处理比较简单</li><li>充分利用硬件</li></ul><h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><ul><li>用户线程操作涉及到内核调用，代价较高</li></ul><blockquote><p>通过跟踪 Java Thread 中 start() 方法：</p><p>start() -&gt; native start0() -&gt; JVM_StartThread() -&gt; JavaThread() -&gt; os::create_thread() -&gt; pthread_create()</p><p>可以发现在 Java 中每次调用 start() 方法，都会在 C++ 的 JavaThread 构造方法里通过 pthread 进行创建一个内核线程。</p><p>回到问题 <strong>TOP 1</strong> ，也就是说 <strong>Java 采用的线程模型是 1:1</strong></p></blockquote><h3 id="1-3-混合实现-M-N"><a href="#1-3-混合实现-M-N" class="headerlink" title="1.3 混合实现(M:N)"></a>1.3 混合实现(M:N)</h3><p><a href="http://qiniu.itliusir.com/thread04.png"><img src="http://qiniu.itliusir.com/thread04.png" alt="img"></a></p><h4 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h4><ul><li>用户线程的操作成本低</li><li>充分利用硬件</li><li>阻塞问题折中处理</li></ul><h4 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h4><ul><li>需要用户层管理和映射</li></ul><h2 id="2-线程状态分析"><a href="#2-线程状态分析" class="headerlink" title="2. 线程状态分析"></a>2. 线程状态分析</h2><p>在状态枚举类 <em>java.lang.Thread.State</em> 中我们看到了一共有 6 种状态</p><ul><li><p><strong>NEW</strong></p><p>新建状态，线程还没调用 start() 方法</p></li><li><p><strong>RUNNABLE</strong></p><p>可运行状态，调用 start() 方法后，正在运行或等待系统资源</p></li><li><p><strong>BLOCKED</strong></p><p>阻塞状态，等待锁、Object#wait()-notify() 后都会进入阻塞状态</p></li><li><p><strong>WAITING</strong></p><p>等待状态，调用 Object#wait()、join()、LockSupport#park() ，注意这里都是没有超时时间</p></li><li><p><strong>TIMED_WAITING</strong></p><p>超时等待状态，调用 Thread#sleep()、Object#wait(long)、join(long)、LockSupport#parkNanos、LockSupport#parkUntil，可以发现这里都是有超时时间</p></li><li><p><strong>TERMINATED</strong></p><p>终止状态，线程已经执行完毕</p></li></ul><h3 id="2-1-线程状态流程图"><a href="#2-1-线程状态流程图" class="headerlink" title="2.1 线程状态流程图"></a>2.1 线程状态流程图</h3><p><a href="http://qiniu.itliusir.com/thread05.png"><img src="http://qiniu.itliusir.com/thread05.png" alt="img"></a></p><p>回到问题 <strong>TOP 2</strong> ，相信看完这个流程图会对状态流转更清晰一些</p><h2 id="3-核心方法分析"><a href="#3-核心方法分析" class="headerlink" title="3. 核心方法分析"></a>3. 核心方法分析</h2><h3 id="3-1-join"><a href="#3-1-join" class="headerlink" title="3.1 join()"></a>3.1 join()</h3><p>例如我们 主线程A 要等待 子线程B 完成再往下执行，可以调用 子线程B 的join() 方法</p><p>回到问题 <strong>TOP 3</strong> ，其实就是通过 wait 方法来让主线程等待，最后子线程完成后会唤醒主线程来实现了一个线程之间的通信。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    join(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="comment">// 获取当前时间</span></span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 入参校验</span></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 默认 join()参数走这个分支</span></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 只要线程还未完成</span></span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">          <span class="comment">// 0 是一直等待下去</span></span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">          <span class="comment">// 还剩下多少时间</span></span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">          <span class="comment">// 时间到了就跳出</span></span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 调用wait方法等待</span></span><br><span class="line">            wait(delay);</span><br><span class="line">          <span class="comment">// 当前已经过了多久</span></span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-interrupt"><a href="#3-2-interrupt" class="headerlink" title="3.2 interrupt()"></a>3.2 interrupt()</h3><p>我们知道 stop() 方法由于太暴力和不安全已经设置为过期，现在基本上是采用 interrupt() 来交给我们优雅的处理。为什么这样说呢？</p><p>我们看下面 interrupt() 的实现可以看到实际上只是设置了一个中断标识(通知线程应该中断了)，并不会真正停止一个线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        Interruptible b = blocker;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">            b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们可以通过这个中断的通知来自己处理是继续运行还是中断，例如我们想要中断后停止线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">        <span class="comment">// do more work.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一段时间以后</span></span><br><span class="line">thread.interrupt();</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，在一些可中断阻塞函数中，会抛出 InterruptedException，需要注意的是如果你不想处理继续往上抛，需要再次调用 interrupt() 方法(因为中断状态已经被重置了)。</p></blockquote><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>我们这篇文章主要是分析了线程模型和线程的状态，已经几个核心方法的实现，相信看完会对线程有了更深一层的认识。</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> join </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DelayQueue 源码分析</title>
      <link href="/2020/17-DelayQueue/"/>
      <url>/2020/17-DelayQueue/</url>
      
        <content type="html"><![CDATA[<h2 id="TOP-带着问题看源码"><a href="#TOP-带着问题看源码" class="headerlink" title="TOP 带着问题看源码"></a>TOP 带着问题看源码</h2><ol><li>DelayQueue 的应用场景</li><li>DelayQueue 实现原理</li></ol><span id="more"></span><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p>我们先来看一下它的实现类图，它实现了 Delayed、BlockingQueue 接口和 AbstractQueue 基础类，从实现的功能上看，它首先是一个阻塞队列，然后 Delayed 接口是标记给定延迟后执行的对象，结合类名也可以大致的分析出：DelayQueue 是一个 <strong>延时阻塞</strong> 队列</p><p><a href="http://qiniu.itliusir.com/delayq.png"><img src="http://qiniu.itliusir.com/delayq.png" alt="img"></a></p><h2 id="2-成员变量分析"><a href="#2-成员变量分析" class="headerlink" title="2. 成员变量分析"></a>2. 成员变量分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保证线程安全的锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">// 优先队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;E&gt; q = <span class="keyword">new</span> PriorityQueue&lt;E&gt;();</span><br><span class="line"><span class="comment">// 标记取元素时是否有线程在排队</span></span><br><span class="line"><span class="keyword">private</span> Thread leader = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 是否可取的条件变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition available = lock.newCondition();</span><br></pre></td></tr></table></figure><h2 id="3-核心方法分析"><a href="#3-核心方法分析" class="headerlink" title="3. 核心方法分析"></a>3. 核心方法分析</h2><h3 id="3-1-入队操作"><a href="#3-1-入队操作" class="headerlink" title="3.1 入队操作"></a>3.1 入队操作</h3><h4 id="3-1-1-offer-E-e"><a href="#3-1-1-offer-E-e" class="headerlink" title="3.1.1 offer(E e)"></a>3.1.1 offer(E e)</h4><p>入队逻辑很简单：</p><ol><li><p>把数据加入到优先队列里</p></li><li><p>如果添加的元素是堆顶元素</p><p>2.1 leader 置空</p><p>2.2 唤醒 “可取” 条件队列的线程</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        q.offer(e);</span><br><span class="line">        <span class="keyword">if</span> (q.peek() == e) &#123;</span><br><span class="line">            leader = <span class="keyword">null</span>;</span><br><span class="line">            available.signal();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-出队操作"><a href="#3-2-出队操作" class="headerlink" title="3.2 出队操作"></a>3.2 出队操作</h3><h4 id="3-2-1-poll"><a href="#3-2-1-poll" class="headerlink" title="3.2.1 poll()"></a>3.2.1 poll()</h4><p>出队非阻塞API，核心逻辑就是：</p><ol><li>检查堆顶元素，如果为空或者还没到期呢，返回 null</li><li>否则返回取出堆顶元素</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        E first = q.peek();</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span> || first.getDelay(NANOSECONDS) &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> q.poll();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-take"><a href="#3-2-2-take" class="headerlink" title="3.2.2 take()"></a>3.2.2 take()</h4><p>出队阻塞API，核心逻辑就是：</p><ol><li>检查堆顶元素，如果为空就等待添加元素时候被唤醒重试</li><li>如果不为空，并且已经过期就直接取出来，没过期并且前面没有线程等待，就等待超时时间后唤醒重试</li><li>每次取完都会唤醒 “可取” 条件队列的线程</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          <span class="comment">// 堆顶元素</span></span><br><span class="line">            E first = q.peek();</span><br><span class="line">          <span class="comment">// 为空，等待被唤醒</span></span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                available.await();</span><br><span class="line">          <span class="comment">// 堆顶不为空</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 获取元素的超时时间</span></span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">              <span class="comment">// 已过期就取走</span></span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> q.poll();</span><br><span class="line">              <span class="comment">// 没过期往下走</span></span><br><span class="line">              <span class="comment">// 这里设置为 null 是放在还有别的线程持有没有释放导致内存泄漏</span></span><br><span class="line">                first = <span class="keyword">null</span>; <span class="comment">// don&#x27;t retain ref while waiting</span></span><br><span class="line">              <span class="comment">// 校验是否有等待线程，有就等待leader线程取完或有新加入的元素唤醒它</span></span><br><span class="line">                <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                    available.await();</span><br><span class="line">              <span class="comment">// 没有等待线程，就把自己设置为等待线程，然后等待超时时间唤醒重试</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        available.awaitNanos(delay);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                      <span class="comment">// 唤醒后就把 leader 置空</span></span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 没有等待线程并且队列还有数据，就唤醒下一个线程来取</span></span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; q.peek() != <span class="keyword">null</span>)</span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到问题 <strong>TOP 2</strong> ，通过对入队列和出队列的分析，其实现原理想必已经明白，就是在队列的基础上增加了时间维度的优先级，然后通过锁和条件变量来控制取/放流程。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>和我们开头分析的一样，DelayQueue是一个 <strong>阻塞延时且无界</strong> 的队列，它使用的是优先级队列+时间维度来实现。回到问题 <strong>TOP 1</strong> 延时队列场景主要适用于定时任务，但是对于内存中的延时队列往往不能用于重要的业务场景(毕竟还是内存队列，宕机了就没咯)，所以可以应用于一些基础类库，不太重要的业务定时清理和处理等。</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DelayQueue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentLinkedQueue 源码分析</title>
      <link href="/2020/16-ConcurrentLinkedQueue/"/>
      <url>/2020/16-ConcurrentLinkedQueue/</url>
      
        <content type="html"><![CDATA[<h2 id="TOP-带着问题看源码"><a href="#TOP-带着问题看源码" class="headerlink" title="TOP 带着问题看源码"></a>TOP 带着问题看源码</h2><ol><li>ConcurrentLinkedQueue 是怎么保证线程安全的</li><li>ConcurrentLinkedQueue 和 LinkedBlockingQueue 区别是啥</li><li>ConcurrentLinkedQueue 的应用场景</li></ol><span id="more"></span><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p>ConcurrentLinkedQueue 是一个线程安全且 <strong>非阻塞</strong> 的 <strong>无界</strong> 队列，它采用先进先出的规则，实现了 AbstractQueue 基础抽象类和 Queue 接口。</p><p>它在内部维护了一个 Node 类，有存放数据的 item 和 执行下一个节点的指针 next，全部通过 CAS 来操作。</p><h2 id="2-成员变量分析"><a href="#2-成员变量分析" class="headerlink" title="2. 成员变量分析"></a>2. 成员变量分析</h2><p>在前面分析阻塞队列 ArrayBlockingQueue 时候，我们发现对数据的增删都是从数组的第一个元素进行操作， 这里我们可以把 head 节点理解为相同的索引作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; head;</span><br><span class="line"><span class="comment">// 尾节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcurrentLinkedQueue.Node</span></span><br><span class="line"><span class="comment">// 存放数据</span></span><br><span class="line"><span class="keyword">volatile</span> E item;</span><br><span class="line"><span class="comment">// 下一个节点指针</span></span><br><span class="line"><span class="keyword">volatile</span> Node&lt;E&gt; next;</span><br></pre></td></tr></table></figure><h2 id="3-核心方法分析"><a href="#3-核心方法分析" class="headerlink" title="3. 核心方法分析"></a>3. 核心方法分析</h2><h3 id="3-1-入队列操作"><a href="#3-1-入队列操作" class="headerlink" title="3.1 入队列操作"></a>3.1 入队列操作</h3><h4 id="3-1-1-offer-E-e"><a href="#3-1-1-offer-E-e" class="headerlink" title="3.1.1 offer(E e)"></a>3.1.1 offer(E e)</h4><p>入队列的API，核心逻辑就是：</p><ol><li>把数据封装为 node 节点，设置为当前尾结点的 next 节点，失败就重试</li><li>每两次 CAS 更新 next 节点 更新一次 tail 节点</li><li>重置尾结点 p</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line"><span class="comment">// 循环入队，直到成功</span></span><br><span class="line">  <span class="comment">// t 是tail节点</span></span><br><span class="line">  <span class="comment">// p 是链表此时此刻的尾结点(也可以理解为入队节点)</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">      <span class="comment">// q 是尾结点的 next 节点</span></span><br><span class="line">        Node&lt;E&gt; q = p.next;</span><br><span class="line">      <span class="comment">// 如果q为null，说明到链表尾部了</span></span><br><span class="line">        <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// CAS 更新 next为新节点，失败就重试</span></span><br><span class="line">            <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, newNode)) &#123;</span><br><span class="line">                <span class="comment">// 然后更新tail节点</span></span><br><span class="line">              <span class="comment">// 这里采用的是一种巧妙的累计更新，也就是说下个 CAS p才会不等于tail</span></span><br><span class="line">              <span class="comment">// 相当于循环两次更新一次 tail，所以才有了最下面的两个判断来设置尾结点p</span></span><br><span class="line">                <span class="keyword">if</span> (p != t) <span class="comment">// hop two nodes at a time</span></span><br><span class="line">                    casTail(t, newNode);  <span class="comment">// Failure is OK.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// p 和 p的next都为空(非对象为空，还是有next的)</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 重置 p节点为下一个入队节点(这一步可以理解为校准,入队节点最终永远要指向最新的尾结点)</span></span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-出队列操作"><a href="#3-2-出队列操作" class="headerlink" title="3.2 出队列操作"></a>3.2 出队列操作</h3><h4 id="3-2-1-poll"><a href="#3-2-1-poll" class="headerlink" title="3.2.1 poll()"></a>3.2.1 poll()</h4><p>可以看到 poll 的大概代码设计是和 offer 差不多的，这里是把 p 做为 头节点来维护(出队节点)，同样是每两次 CAS 更新数据，更新一次头节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    restartFromHead:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="comment">// 从头开始</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">          <span class="comment">// 取数据</span></span><br><span class="line">            E item = p.item;</span><br><span class="line"><span class="comment">// CAS 置null</span></span><br><span class="line">            <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="comment">// 更新 head 节点</span></span><br><span class="line">                <span class="keyword">if</span> (p != h) <span class="comment">// hop two nodes at a time</span></span><br><span class="line">                    updateHead(h, ((q = p.next) != <span class="keyword">null</span>) ? q : p);</span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 队列为空返回 null(可以看到是非阻塞的)</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((q = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">                <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">          <span class="comment">// 重置p节点尾下一个出队节点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到问题 <strong>TOP 2</strong> ，通过对入队出队的分析，可以分析 ConcurrentLinkedQueue 和 LinkedBlockingQueue 的区别主要还是 一个是非阻塞，一个是阻塞，两者都是线程安全的。</p><p>回到问题 <strong>TOP 3</strong> ，那场景也就是线程安全且不需要阻塞功能的常规内存队列场景。</p><h3 id="3-3-辅助操作"><a href="#3-3-辅助操作" class="headerlink" title="3.3 辅助操作"></a>3.3 辅助操作</h3><h4 id="3-3-1-isEmpty"><a href="#3-3-1-isEmpty" class="headerlink" title="3.3.1 isEmpty()"></a>3.3.1 isEmpty()</h4><p>判断队列是否为空是通过判断头节点是否为空来实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 查看头节点是否为空</span></span><br><span class="line">    <span class="keyword">return</span> first() == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    restartFromHead:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">          <span class="comment">// 获取头节点的值，顺带更新一波 Head</span></span><br><span class="line">            <span class="keyword">boolean</span> hasItem = (p.item != <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (hasItem || (q = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                <span class="keyword">return</span> hasItem ? p : <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">                <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-size"><a href="#3-3-2-size" class="headerlink" title="3.3.2 size()"></a>3.3.2 size()</h4><p>遍历队列，计数，效率较差</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; p = first(); p != <span class="keyword">null</span>; p = succ(p))</span><br><span class="line">        <span class="keyword">if</span> (p.item != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// Collection.size() spec says to max out</span></span><br><span class="line">            <span class="keyword">if</span> (++count == Integer.MAX_VALUE)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过对以上的核心方法的分析，回到问题 <strong>TOP 1</strong> 可以明白基本都是采用 CAS 自旋来实现的，保证了线程的安全性</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>对比阻塞队列，ConcurrentLinkedQueue 没有条件变量、锁等那些复杂的东西，代码设计层面尽量是简洁、巧妙。</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ConcurrentLinkedQueue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayBlockingQueue 源码分析</title>
      <link href="/2020/15-ArrayBlockingQueue/"/>
      <url>/2020/15-ArrayBlockingQueue/</url>
      
        <content type="html"><![CDATA[<h2 id="TOP-带着问题看源码"><a href="#TOP-带着问题看源码" class="headerlink" title="TOP 带着问题看源码"></a>TOP 带着问题看源码</h2><ol><li>ArrayBlockingQueue 实现原理</li><li>ArrayBlockingQueue 应用的场景</li><li>ArrayBlockingQueue 和 LinkedBlockingQueue 区别</li></ol><span id="more"></span><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p>ArrayBlockingQueue 是一个基于数组实现的线程安全的阻塞队列。</p><p>其实现了阻塞队列 BlockingQueue 接口和基本队列操作 AbstractQueue 接口</p><p><a href="http://qiniu.itliusir.com/abq.png"><img src="http://qiniu.itliusir.com/abq.png" alt="img"></a></p><h2 id="2-成员变量分析"><a href="#2-成员变量分析" class="headerlink" title="2. 成员变量分析"></a>2. 成员变量分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存放数据数组</span></span><br><span class="line"><span class="keyword">final</span> Object[] items;</span><br><span class="line"><span class="comment">// 下一个取的索引</span></span><br><span class="line"><span class="keyword">int</span> takeIndex;</span><br><span class="line"><span class="comment">// 下一个放的索引</span></span><br><span class="line"><span class="keyword">int</span> putIndex;</span><br><span class="line"><span class="comment">// 队列数量</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="comment">// 锁</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"><span class="comment">// 队列不为空条件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"><span class="comment">// 队列没有满条件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"><span class="comment">// 迭代器状态</span></span><br><span class="line"><span class="keyword">transient</span> Itrs itrs = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h2 id="3-构造方法分析"><a href="#3-构造方法分析" class="headerlink" title="3. 构造方法分析"></a>3. 构造方法分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 默认非公平锁，调用下个构造方法</span></span><br><span class="line">    <span class="keyword">this</span>(capacity, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化数组，锁，条件变量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-核心方法分析"><a href="#4-核心方法分析" class="headerlink" title="4. 核心方法分析"></a>4. 核心方法分析</h2><h3 id="4-1-入队列操作"><a href="#4-1-入队列操作" class="headerlink" title="4.1 入队列操作"></a>4.1 入队列操作</h3><h4 id="4-1-1-enqueue-E-x"><a href="#4-1-1-enqueue-E-x" class="headerlink" title="4.1.1 enqueue(E x)"></a>4.1.1 enqueue(E x)</h4><p>核心逻辑就是往数组中插入一条数据，然后更新 putIndex，唤醒 “队列不为空” 条件对应的条件队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">  <span class="comment">// 因为取也是从0开始取，所以接下来已经满了就重置为0</span></span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">  <span class="comment">// 因为已经有数据了，就可以唤醒 notEmpty Condition了</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-2-offer-E-e"><a href="#4-1-2-offer-E-e" class="headerlink" title="4.1.2 offer(E e)"></a>4.1.2 offer(E e)</h4><p>队列对外暴露的入队列 API，其实就是调用了一下 enqueue 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果传的是null 直接抛空指针异常</span></span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 如果已经满了，返回false</span></span><br><span class="line">        <span class="keyword">if</span> (count == items.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 调用 enqueue 插入数据</span></span><br><span class="line">            enqueue(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-3-put-E-e"><a href="#4-1-3-put-E-e" class="headerlink" title="4.1.3 put(E e)"></a>4.1.3 put(E e)</h4><p>队列对外暴露的入队列 阻塞API，如果队列已满，会进入阻塞状态，直到 ”队列没有满“ 条件满足，才会插入新的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">  <span class="comment">// 可响应中断</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 如果队列已满</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">          <span class="comment">// 等待 ”队列没有满“ Condition</span></span><br><span class="line">            notFull.await();</span><br><span class="line">      <span class="comment">// 插入数据</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-出队列操作"><a href="#4-2-出队列操作" class="headerlink" title="4.2 出队列操作"></a>4.2 出队列操作</h3><h4 id="4-2-1-dequeue"><a href="#4-2-1-dequeue" class="headerlink" title="4.2.1 dequeue()"></a>4.2.1 dequeue()</h4><p>核心逻辑就是从数组中取出一条数据，然后更新 takeIndex，唤醒 “队列没有满” 条件对应的条件队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 如果取完就重置 takeIndex，继续从0开始取</span></span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">  <span class="comment">// 走到这里说明已经取一条了</span></span><br><span class="line">  <span class="comment">// 这个时候需要唤醒 &quot;队列没有满&quot; Condition</span></span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-2-poll"><a href="#4-2-2-poll" class="headerlink" title="4.2.2 poll()"></a>4.2.2 poll()</h4><p>队列对外暴露的取队列 API，如果取完，返回null，没取完就调用 dequeue 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-3-take"><a href="#4-2-3-take" class="headerlink" title="4.2.3 take()"></a>4.2.3 take()</h4><p>队列对外暴露的取队列 阻塞API，如果队列已空，会进入阻塞状态，直到 “队列不为空” 条件满足，才会继续取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">  <span class="comment">// 可响应中断</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 队列已空</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">          <span class="comment">// 等待 ”队列不为空“ Condition</span></span><br><span class="line">            notEmpty.await();</span><br><span class="line">      <span class="comment">// 调用 dequeue 取元素</span></span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-4-peek"><a href="#4-2-4-peek" class="headerlink" title="4.2.4 peek()"></a>4.2.4 peek()</h4><p>队列对外暴露的只看不取 API，逻辑很简单，就是直接按照 takeIndex 查看元素，但是不置空也不维护 takeIndex</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> itemAt(takeIndex); <span class="comment">// null when queue is empty</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> E <span class="title">itemAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) items[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的核心方法分析，回到问题 <strong>TOP 1</strong> 我们可以明白其实现原理就是采用 可重入非公平锁来保证线程安全，通过在数组的入口和出口来互相更新条件变量的唤醒条件来实现阻塞队列。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>整体设计我们可以发现设计的很巧妙，既有阻塞 API，也有不阻塞线程安全的 API。回到问题 <strong>TOP 2</strong> 其应用场景不难想象，只要是涉及到内存中的生产者-消费者模型的都可以使用它来暂存数据。</p><p>关于最后的问题 <strong>TOP 3</strong> ，其区别主要是底层数据结构的选择，整体的阻塞设计和逻辑都是一样的。</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ArrayBlockingQueue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CopyOnWriteArrayList 源码分析</title>
      <link href="/2020/13-CopyOnWriteArrayList/"/>
      <url>/2020/13-CopyOnWriteArrayList/</url>
      
        <content type="html"><![CDATA[<h2 id="TOP-带着问题看源码"><a href="#TOP-带着问题看源码" class="headerlink" title="TOP 带着问题看源码"></a>TOP 带着问题看源码</h2><ol><li>CopyOnWriteArrayList 是怎么保证线程安全的</li><li>适用的场景</li></ol><span id="more"></span><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p>顾名思义，这是一个每次写入都采用先复制再写入的方式来实现的线程安全的 List。这样的好处是可以读写并行，而且实现简单。</p><h2 id="2-成员变量分析"><a href="#2-成员变量分析" class="headerlink" title="2. 成员变量分析"></a>2. 成员变量分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lock 锁</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">// 存放数据的数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getter</span></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// setter</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-核心方法分析"><a href="#3-核心方法分析" class="headerlink" title="3. 核心方法分析"></a>3. 核心方法分析</h2><h3 id="3-1-add-E-e"><a href="#3-1-add-E-e" class="headerlink" title="3.1 add(E e)"></a>3.1 add(E e)</h3><p>核心逻辑就是使用数组copy把旧的数据复制到新的数组(比旧的数组长度大1)，然后把存放数据的数组指向新的数组。加锁是解决线程不安全问题，可以明白问题 <strong>TOP 1</strong> 的线程安全问题是由 COW+Lock 来保证的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-get-int-index"><a href="#3-2-get-int-index" class="headerlink" title="3.2 get(int index)"></a>3.2 get(int index)</h3><p>获取指定 index 的数据比较简单，可以看到查询是无锁的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>经过前面的分析，可以发现其更新操作都是贯彻 COW 思想，那就有可能写入还在复制副本期间读的是旧的数据，回到问题 <strong>TOP 2</strong> 那对应的场景也可以猜到：</p><p><strong>适用于写少读多且能容忍读写的短暂不一致</strong></p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CopyOnWriteArrayList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019-年度总结</title>
      <link href="/2019/2019-%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
      <url>/2019/2019-%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>摘要:<br>2019 年度总结</p><span id="more"></span><p>2019年已经匆匆过去，转眼间就到了新的一年</p><p>接下来从工作和生活以及个人方面简单做个年终总结。</p><h2 id="生活总结"><a href="#生活总结" class="headerlink" title="生活总结"></a>生活总结</h2><p>今年有了 Thor 这只可爱的小猫，名字来源于《雷神》，它的到来给生活带来了很多欢乐。小时候皮的很总喜欢半夜咬人让你陪它玩，现在懂事了会等到你早上睁开眼再凑过来，但也经常钻到电脑下面搞事情…</p><p>然后买了一把吉他，在女票的指导下会弹了几首简单的曲子，但是最近太忙了很少有时间练这个，希望 2020年 能多一些时间来练习=。=</p><p>另外会做了很多家常菜，做菜也是一件很幸福的事情，有一个家的感觉，但是今后半年猪肉涨的太厉害了，拿手的红烧肉好久没吃了。</p><p>周末出去玩耍时间少了，希望2020年 能更合理一些安排时间陪女票一起出去玩。</p><h2 id="工作总结"><a href="#工作总结" class="headerlink" title="工作总结"></a>工作总结</h2><p>今年年初换了一份工作，目的就是想去互联网瞅瞅，感谢之前的老大和同事教会了我很多东西，新的工作主要是做任务调度和之前做的 RPA 很类似，算是经历了 618 1111 大促通宵值班，和同事们也学习了很多东西，技术架构这块也学习了很多自己之前没有接触过的东西，遇到了很多线上的问题，也成长了很多。</p><h2 id="自我总结"><a href="#自我总结" class="headerlink" title="自我总结"></a>自我总结</h2><p>先回顾下年初的 flag，完成情况不是很好，还是不立 flag 好了。</p><ul><li><p><strong>读5本打基础的书籍</strong></p><p>只读完了 深入理解Java 虚拟机、 计网自顶向下、深入理解计算机操作系统(CSAPP) 三本</p><p>并没有完成5本的目标</p></li><li><p><strong>J.U.C 剩余部分</strong></p><p>并发流程控制那块还没有看</p></li><li><p><strong>完成10篇高质量的博客</strong></p><p>已完成10篇小白文章=。=</p></li></ul><p>今年参加了很多有趣的小组，也认识了很多人，今年主要参与的有三个。</p><ol><li><p><strong>读书小组</strong></p><p>感谢 <strong>码农翻身</strong> 公众号大刘组织，主要是围绕着基础这块来共读，比如计网自顶向下、CSAPP 都是在此期间读的。</p></li><li><p><strong>算法训练营</strong></p><p>感谢极客时间的覃超老师，让我这个非科班很快的对算法入了门，老师的五遍刷题法的确很有用，准备今年继续刷下去。</p></li><li><p><strong>源码共读小组</strong></p><p>感谢七楼(有意思的一个鼓励师)同鞋的组织，目前主要是围绕 JDK 源码来读，期间自己在总结时候发现自己之前理解的并不是很透彻，确实每个阶段都会有不同的收获。</p></li></ol><p>俗话说计划跟不上变化，2020 的 flag 就不立了，努力就好了，自己接下来就是继续完善基础，然后熟悉一种与网络有关的开源项目。</p><p><em>Thor 镇楼</em></p><p><a href="http://qiniu.itliusir.com/thor00.png"><img src="http://qiniu.itliusir.com/thor00.png" alt="img"></a></p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AbstractQueuedSynchronizer 源码分析</title>
      <link href="/2019/12-AbstractQueuedSynchronizer/"/>
      <url>/2019/12-AbstractQueuedSynchronizer/</url>
      
        <content type="html"><![CDATA[<h2 id="TOP-带着问题看源码"><a href="#TOP-带着问题看源码" class="headerlink" title="TOP 带着问题看源码"></a>TOP 带着问题看源码</h2><ol><li>AQS 的数据结构</li><li>AQS 的设计模式</li><li>AQS 的核心思想</li></ol><span id="more"></span><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p>前面我们已经介绍和分析了管程，以及 JVM 层面的管程而 AQS 则是 Java 并发包中管程的一种实现。</p><p>下面是 AQS 的类实现关系图</p><p><a href="http://qiniu.itliusir.com/aqs_dependent.png"><img src="http://qiniu.itliusir.com/aqs_dependent.png" alt="img"></a></p><h2 id="2-成员变量分析"><a href="#2-成员变量分析" class="headerlink" title="2. 成员变量分析"></a>2. 成员变量分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头结点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"><span class="comment">// 尾节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"><span class="comment">// 同步状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="comment">// AbstractOwnableSynchronizer.class</span></span><br><span class="line"><span class="comment">// 当前持有独占锁的线程，类似对象头的Thread ID，可以用来判断是否为重入</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br></pre></td></tr></table></figure><h3 id="2-1-Node-节点分析"><a href="#2-1-Node-节点分析" class="headerlink" title="2.1 Node 节点分析"></a>2.1 Node 节点分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节点状态，有下面几种取值</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"><span class="comment">// 共享模式</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line"><span class="comment">// 独占模式</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 当前线程取消了锁的竞争</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 后继节点需要被唤醒</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 当前节点线程正在等待条件</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"><span class="comment">// 双向链表</span></span><br><span class="line"><span class="comment">// 前驱节点</span></span><br><span class="line"><span class="keyword">volatile</span> Node prev;</span><br><span class="line"><span class="comment">// 后继节点</span></span><br><span class="line"><span class="keyword">volatile</span> Node next;</span><br><span class="line"><span class="comment">// 节点封装的线程</span></span><br><span class="line"><span class="keyword">volatile</span> Thread thread;</span><br><span class="line"><span class="comment">// 条件队列的单向链表</span></span><br><span class="line">Node nextWaiter;</span><br></pre></td></tr></table></figure><p>回到问题 <strong>TOP 1</strong> ，可以分析得到 AQS 的数据结构是一个双向链表，并维护了一个全局状态</p><h2 id="3-核心方法分析"><a href="#3-核心方法分析" class="headerlink" title="3. 核心方法分析"></a>3. 核心方法分析</h2><h3 id="3-1-尝试获取锁"><a href="#3-1-尝试获取锁" class="headerlink" title="3.1 尝试获取锁"></a>3.1 尝试获取锁</h3><p><code>tryAcquire</code> 这个方法 AQS 是定义了一个空方法，交由子类自行实现，这里也是采用了 <strong>模板设计模式</strong></p><p>我们先暂时理解 <code>tryAcquire</code> 是尝试获取一下锁，后面会结合具体实现类来分析</p><p>可以看到如果 <code>tryAcquire(arg)</code> 返回 true，方法就结束了，如果返回 false 则往下走加入队列，加入成功就设置中断状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们来分析 <em>addWaiter(Node.EXCLUSIVE)</em></p><p>如果你看过之前分析 <code>Synchronized</code> 那一篇的重量锁阶段相信你看到这会发现很熟悉，没错！就是在竞争失败后把当前线程封装到 node 节点(独占模式)，与 <code>Synchronized</code> 不同的是 node 不是放在队列头部而是塞到队列的队尾处。</p><p>核心逻辑就是通过 CAS 自旋进行入队。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">// 队列不为空 直接 CAS 入队，成功直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 队列为空 或 CAS竞争失败 调用 enq 自旋入队</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看下 <em>enq(node)</em> 的逻辑，很简单就是：</p><ol><li>队列为空就初始化 head 节点(初始化之前是null，这里new Node中waitStatus是0) ，队列不为空后就继续循环走下面入队的逻辑</li><li>不为空说明是 CAS 竞争失败，尝试自旋入队</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>acquire(arg)</em> 中的 <em>addWaiter(Node.EXCLUSIVE)</em> 已经分析完了，接下来我们分析外层的 <em>acquireQueued()</em> 方法。</p><p>上面逻辑已经把节点放入队列了，接下来的逻辑就是会把放入队列的节点不断获取锁，直到成功或者中断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">          <span class="comment">// 如果前驱节点是队头就尝试获取锁，因为这个节点有可能是刚初始化的</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">              <span class="comment">// 注意，唯一 return 跳出方法的地方</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 说明要么上面分支没获取到锁，要么不是头节点</span></span><br><span class="line">          <span class="comment">// 接下来我们分析 shouldParkAfterFailedAcquire</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 根据 return 之前的赋值可以知道，failed 为 true 只有 tryAcquire 异常时候会出现</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">          <span class="comment">// 将 node 节点设置为 CANCELLED 状态</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们分析 <em>shouldParkAfterFailedAcquire(p, node)</em> 方法，注意传过来的第一个节点是 <strong>前驱节点</strong> ，第二个是当前节点</p><p>该方法核心思想就是判断当前线程是否应该被挂起</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">  <span class="comment">// 前驱节点是唤醒状态</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">// ws&gt;0 代表前驱节点取消了排队 </span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">         * indicate retry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">          <span class="comment">// 因为依赖前驱节点的唤醒，所以前驱不能是取消状态，再往前找，一直找到前驱不是取消状态的才停止</span></span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    <span class="comment">// 排除 ws = -1 和 ws &gt; 0，加上前面初始化节点并没有看见设置 waitStatus</span></span><br><span class="line">    <span class="comment">// 所以进入这个分支的也就是 waitStatus 为0</span></span><br><span class="line">    <span class="comment">// 使用 CAS 把前驱节点状态设置为 唤醒状态，再次循环时候就会从第一个分支 return true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上个方法返回为 true ，就会接着调用 park 挂起当前线程。</p><p>正常来说 第一次都会为 false，因为 第一次只是设置状态，第二次才会校验状态</p><h4 id="3-1-1-tryAcquire-arg-的实现"><a href="#3-1-1-tryAcquire-arg-的实现" class="headerlink" title="3.1.1 tryAcquire(arg) 的实现"></a>3.1.1 tryAcquire(arg) 的实现</h4><p>我们主要拿 <code>ReentrantLock</code> 和 <code>Semaphore</code> 的实现来举例子</p><p><code>ReentrantLock</code> 有两个版本的实现，一个是公平锁，一个是非公平锁</p><p>我们先来看非公平锁，并没有什么特殊处理，就是先尝试获取一下，成功就返回，失败就入 AQS 的等待队列</p><p><em>ReentrantLock.Sync#nonfairTryAcquire</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">  <span class="comment">// c 为 0，说明还没有线程持有锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 尝试 CAS 一下，成功就直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 如果有线程且是当前线程，说明是重入锁，state+1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们来看公平锁，可以看到在非公平的基础上多判断一次 <code>hasQueuedPredecessors</code> , <code>hasQueuedPredecessors</code> 的逻辑很简单，就是判断队列为不为空，如果不为空说明还有等待的，就不往下走了</p><p><em>ReentrantLock.FairSync#tryAcquire</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 队列为空，就 CAS 尝试获取一下锁</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 重入</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列不为空返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Semaphore</code> 是 Java 层面实现的一个信号量，也是分为公平和非公平版本，<code>Semaphore</code> 也是基于 AQS 来实现的，它是通过一个许可介质，获取许可就把许可减少，如果许可数小于0，就入队列阻塞等待许可的归还；归还许可的时候就把许可数增加。信号量这块可以参考前面的文章，有专门讲解这个机制。</p><p>我们先来看非公平的实现，其实就是对许可的减少</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="comment">// 获取许可数量</span></span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">      <span class="comment">// 减去当前要获取的许可的剩余的许可数量</span></span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">      <span class="comment">// CAS 修改许可的数量，如果小于0，则返回负数，在上一层调用的时候如果为负数会加入 AQS 的队列</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看公平锁的实现，相信看到 <code>hasQueuedPredecessors</code> 你又懂了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-尝试释放锁"><a href="#3-2-尝试释放锁" class="headerlink" title="3.2 尝试释放锁"></a>3.2 尝试释放锁</h3><p>同 <code>tryAcquire</code> 一样， <code>tryRelease</code> 也是 AQS 中的一个模板方法，我们后面会分析 <code>tryRelease</code> 的具体实现，我们先来分析 <code>release</code></p><p>同获取锁 <code>acquire</code> 不一样，这里是子类实现返回 true才往下走(后面我们会知道，这个是指是否完全释放)，后面会调用 <code>unparkSuccessor</code> 方法来唤醒后继节点，需要注意的是传入的节点是 <strong>head 节点</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>unparkSuccessor</em> 方法核心逻辑就是唤醒 head 的后继节点，如果后继节点的状态不是需要被唤醒的状态，就从后往前找到 waitStatus 是唤醒状态的最前面的节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    Node s = node.next;</span><br><span class="line">  <span class="comment">// 有可能后继节点取消了等待</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// 从后往前遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">          <span class="comment">// 找到最前面的一个waitStatus &lt;= 0的节点，赋值给 s 等待被唤醒</span></span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 后继节点正常且不为空就唤醒</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-1-tryRelease-arg-的实现"><a href="#3-2-1-tryRelease-arg-的实现" class="headerlink" title="3.2.1 tryRelease(arg) 的实现"></a>3.2.1 tryRelease(arg) 的实现</h4><p>同样的，我们主要拿 <code>ReentrantLock</code> 和 <code>Semaphore</code> 的实现来举例子</p><p>先来看 <code>ReentrantLock</code> 的实现，如果可重入的次数已经减少完了就返回true，走 AQS 的模板方法调用唤醒操作</p><p><em>ReentrantLock.Sync#tryRelease</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 减少可重入次数</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">// 这里考虑到了是否为重入锁，也就是是否完全释放，</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 更新状态数</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后来看下 <code>Semaphore</code> 的实现，更新许可，成功则返回 true，走 AQS 的模板进行唤醒操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="comment">// 当前许可数量，因为有可能有竞争，所以每次自旋后重新获取许可数量进行归还</span></span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">      <span class="comment">// 新增许可数量</span></span><br><span class="line">        <span class="keyword">int</span> next = current + releases;</span><br><span class="line">        <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);</span><br><span class="line">      <span class="comment">// CAS 更新许可数量，失败就重试</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过对核心方法的分析，我们可以知道 AQS 定义了很多模板方法，扩展逻辑交由子类实现。</p><p>回到问题 <strong>TOP 2</strong> ，可以知道采用的设计模式是模板设计模式</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>由上面对成员变量和核心方法的分析，我们可以看到 AQS 这个管程的实现其实和概念上是相同的，就是对队列和状态值的一个维护，也可以明白 Java 为什么使用管程为核心实现同步，其优势是面向对象，把复杂逻辑封装起来，对于使用更友好。</p><p>同样我们对 <code>Semaphore</code> 这个 Java 层面的信号量实现的分析，也明白了管程那篇文章中写的 <strong>管程和信号量等价</strong> ，因为我们可以使用管程来实现信号量，也可以使用信号量来实现管程，只是管程对我们更加友好！</p><p>以上的总结也是对问题 <strong>TOP 3</strong> 的一个回答。</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AbstractQueuedSynchronizer </tag>
            
            <tag> AQS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Synchronized 源码分析</title>
      <link href="/2019/11-Synchronized/"/>
      <url>/2019/11-Synchronized/</url>
      
        <content type="html"><![CDATA[<h2 id="TOP-带着问题看源码"><a href="#TOP-带着问题看源码" class="headerlink" title="TOP 带着问题看源码"></a>TOP 带着问题看源码</h2><ol><li>Synchronized 怎么做到同步的</li><li>Synchronized 做了哪些优化</li><li>Synchronized 有哪些缺点</li></ol><span id="more"></span><h2 id="1-Synchronized-基本介绍"><a href="#1-Synchronized-基本介绍" class="headerlink" title="1. Synchronized 基本介绍"></a>1. Synchronized 基本介绍</h2><p>前面我们已经介绍和分析了管程，而 Synchronized 则是 JVM 层面中管程的一种实现，它通过对细节的屏蔽方便了开发人员的使用。</p><h2 id="2-对象的内存结构"><a href="#2-对象的内存结构" class="headerlink" title="2. 对象的内存结构"></a>2. 对象的内存结构</h2><p>在 HotSpot 虚拟机中，对象在堆内存中的存储布局可以划分为三个部分：对象头、实例数据、对齐填充</p><p>我们可以通过使用工具 <a href="https://mvnrepository.com/artifact/org.openjdk.jol/jol-core">jol</a> 打印对象的结构</p><p><em>obj example</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    String s;</span><br><span class="line">    <span class="keyword">long</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>print obj struct</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printObjStruct</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(</span><br><span class="line">            ClassLayout.parseInstance(<span class="keyword">new</span> ObjDemo()).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>result</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">OFFSET  SIZE               TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4                    (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span><br><span class="line">      4     4                    (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4                    (object header)                           44 c1 00 f8 (01000100 11000001 00000000 11111000) (-134168252)</span><br><span class="line">     12     4                int ObjDemo.a                                 0</span><br><span class="line">     16     8               long ObjDemo.l                                 0</span><br><span class="line">     24     4   java.lang.String ObjDemo.s                                 null</span><br><span class="line">     28     4                    (loss due to the next object alignment)</span><br><span class="line">Instance size: 32 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br></pre></td></tr></table></figure><h3 id="2-1-对象头"><a href="#2-1-对象头" class="headerlink" title="2.1 对象头"></a>2.1 对象头</h3><p>HotSpot 虚拟机对象的对象头包括两类信息，一类是存储对象运行时数据，我们称为 <strong>Mark Word</strong> ；一类是类型指针，即对象指向它的类型元数据的指针(虚拟机通过该指针确定对象是哪个类的实例)，我们称为 <strong>klass pointer</strong>。</p><h4 id="2-1-1-Klass-Pointer"><a href="#2-1-1-Klass-Pointer" class="headerlink" title="2.1.1 Klass Pointer"></a>2.1.1 Klass Pointer</h4><p>存放的是该对象对应的类的指针(指向方法区的内存区域)</p><h4 id="2-1-2-Mark-Word"><a href="#2-1-2-Mark-Word" class="headerlink" title="2.1.2 Mark Word"></a>2.1.2 Mark Word</h4><p><em>markOop.hpp</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 64 bits:</span><br><span class="line">//  --------</span><br><span class="line">//  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)</span><br><span class="line">//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)</span><br><span class="line">//  PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span><br><span class="line">//  size:64 -----------------------------------------------------&gt;| (CMS free block)</span><br><span class="line">//</span><br><span class="line">//  unused:25 hash:31 --&gt;| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; normal object)</span><br><span class="line">//  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; biased object)</span><br><span class="line">//  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 -----&gt;| (COOPs &amp;&amp; CMS promoted object)</span><br><span class="line">//  unused:21 size:35 --&gt;| cms_free:1 unused:7 ------------------&gt;| (COOPs &amp;&amp; CMS free block)</span><br></pre></td></tr></table></figure><p>由 markOop 的源码注释，我们可以知道 mark word 在不同的状态下都存哪些东西。</p><p>对象的状态一共有五种：无锁(0 01)、可偏向锁(1 01)、轻量级锁(_ 00)、重量级锁(_ 10)、GC状态(_ 11)</p><blockquote><p>注意:</p><ol><li>age 一直为4位的原因是我们 gc 的年龄最大是15就会被回收到老年代，所以 4 个 bit位就可以表示</li><li>lock 2位只能表示4种状态，加上偏向标志biased lock 1位则可以表示5种状态</li><li>epoch 是用来标示是否已经重偏向</li></ol></blockquote><p>通过对象头的结构我们可以知道，同步锁实际是存储在对象头中的，不难推断其同步的方式就是通过对象与线程的绑定占有来实现排他的效果。 <code>Synchronized</code> 关键字在编译后会在同步块的前后生成 <code>monitorenter</code> 和 <code>monitorexit</code> 这两个字节码指令，JVM 会对其进行解析，如果锁的是对象则就是对该对象加锁解锁，如果是类方法则是对 Class 对象加锁解锁，如果是实例方法则是对对应的对象加锁解锁。</p><p>回到 <strong>TOP 1</strong> 问题，可以知道同步是通过对象与线程的绑定记录来实现的。</p><h3 id="2-2-实例数据"><a href="#2-2-实例数据" class="headerlink" title="2.2 实例数据"></a>2.2 实例数据</h3><p>真正存储的有效信息，默认顺序会按照虚拟机的默认分配顺序, 如果 -XX:CompactFields 参数为 true (默认为true)，子类中较小的变量页允许插入到父类变量的空隙中。</p><h3 id="2-3-对齐填充"><a href="#2-3-对齐填充" class="headerlink" title="2.3 对齐填充"></a>2.3 对齐填充</h3><p>由于 HotSpot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，因此如果对象实例数据部分没有对齐的话就需要对齐填充来补全</p><h2 id="3-monitorenter-源码解析"><a href="#3-monitorenter-源码解析" class="headerlink" title="3. monitorenter 源码解析"></a>3. monitorenter 源码解析</h2><p>我们主要解析 monitorenter 加锁的例子。</p><h3 id="3-1-入口"><a href="#3-1-入口" class="headerlink" title="3.1 入口"></a>3.1 入口</h3><p>HotSpot 虚拟机实现了两种的解释器，分别是模板解释器 和 C++解释器，默认使用的是模板解释器。</p><p>C++ 解释器也即是我们平时用来实现功能的方法，简单明了但是很慢；模板解释器是跳过了编译器，自己使用汇编代码来做的，比较难懂。</p><p>所以 monitorenter 的两个入口，我们从 C++ 解释器的入口分析，更加容易明白。</p><h3 id="3-2-偏向锁-amp-轻量级锁"><a href="#3-2-偏向锁-amp-轻量级锁" class="headerlink" title="3.2 偏向锁&amp;轻量级锁"></a>3.2 偏向锁&amp;轻量级锁</h3><h4 id="3-2-1-偏向锁的获取"><a href="#3-2-1-偏向锁的获取" class="headerlink" title="3.2.1 偏向锁的获取"></a>3.2.1 偏向锁的获取</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CASE</span>(_monitorenter): &#123;</span><br><span class="line">  oop lockee = <span class="built_in">STACK_OBJECT</span>(<span class="number">-1</span>);</span><br><span class="line">  <span class="built_in">CHECK_NULL</span>(lockee);</span><br><span class="line">  <span class="comment">// 寻找空闲的锁记录(Lock Record) 空间</span></span><br><span class="line">  BasicObjectLock* limit = istate-&gt;<span class="built_in">monitor_base</span>();</span><br><span class="line">  BasicObjectLock* most_recent = (BasicObjectLock*) istate-&gt;<span class="built_in">stack_base</span>();</span><br><span class="line">  BasicObjectLock* entry = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">while</span> (most_recent != limit ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (most_recent-&gt;<span class="built_in">obj</span>() == <span class="literal">NULL</span>) entry = most_recent;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (most_recent-&gt;<span class="built_in">obj</span>() == lockee) <span class="keyword">break</span>;</span><br><span class="line">    most_recent++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 存在空闲的Lock Record</span></span><br><span class="line">  <span class="keyword">if</span> (entry != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// Lock Record 的 obj 指针指向锁对象</span></span><br><span class="line">    entry-&gt;<span class="built_in">set_obj</span>(lockee);</span><br><span class="line">    <span class="keyword">int</span> success = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">uintptr_t</span> epoch_mask_in_place = (<span class="keyword">uintptr_t</span>)markOopDesc::epoch_mask_in_place;</span><br><span class="line">    markOop mark = lockee-&gt;<span class="built_in">mark</span>();</span><br><span class="line">    <span class="keyword">intptr_t</span> hash = (<span class="keyword">intptr_t</span>) markOopDesc::no_hash;</span><br><span class="line">    <span class="comment">// 如果锁对象的对象头标志是偏向模式(1 01)</span></span><br><span class="line">    <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_bias_pattern</span>()) &#123;</span><br><span class="line">      <span class="keyword">uintptr_t</span> thread_ident;</span><br><span class="line">      <span class="keyword">uintptr_t</span> anticipated_bias_locking_value;</span><br><span class="line">      thread_ident = (<span class="keyword">uintptr_t</span>)istate-&gt;<span class="built_in">thread</span>();</span><br><span class="line">      <span class="comment">// 通过位运算计算anticipated_bias_locking_value</span></span><br><span class="line">      anticipated_bias_locking_value =</span><br><span class="line">        <span class="comment">// 将线程id与prototype_header(epoch、分代年龄、偏向模式、锁标志)部分相或</span></span><br><span class="line">        (((<span class="keyword">uintptr_t</span>)lockee-&gt;<span class="built_in">klass</span>()-&gt;<span class="built_in">prototype_header</span>() | thread_ident) </span><br><span class="line">        <span class="comment">// 与锁对象的markword异或，相等为0</span></span><br><span class="line">         ^ (<span class="keyword">uintptr_t</span>)mark) </span><br><span class="line">        <span class="comment">// 将上面结果中的分代年龄忽略掉</span></span><br><span class="line">        &amp;~((<span class="keyword">uintptr_t</span>) markOopDesc::age_mask_in_place);</span><br><span class="line"><span class="comment">// ① 为0代表偏向线程是当前线程 且 对象头的epoch与class的epoch相等，什么也不做</span></span><br><span class="line">      <span class="keyword">if</span>  (anticipated_bias_locking_value == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PrintBiasedLockingStatistics) &#123;</span><br><span class="line">          (* BiasedLocking::<span class="built_in">biased_lock_entry_count_addr</span>())++;</span><br><span class="line">        &#125;</span><br><span class="line">        success = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ② 偏向模式关闭，则尝试撤销</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((anticipated_bias_locking_value &amp; markOopDesc::biased_lock_mask_in_place) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// try revoke bias</span></span><br><span class="line">        markOop header = lockee-&gt;<span class="built_in">klass</span>()-&gt;<span class="built_in">prototype_header</span>();</span><br><span class="line">        <span class="keyword">if</span> (hash != markOopDesc::no_hash) &#123;</span><br><span class="line">          header = header-&gt;<span class="built_in">copy_set_hash</span>(hash);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span>(header, lockee-&gt;<span class="built_in">mark_addr</span>(), mark) == mark) &#123;</span><br><span class="line">          <span class="keyword">if</span> (PrintBiasedLockingStatistics)</span><br><span class="line">            (*BiasedLocking::<span class="built_in">revoked_lock_entry_count_addr</span>())++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ③ 锁对象头的 epoch 与 class 的 epoch 不相等，尝试重偏向</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((anticipated_bias_locking_value &amp; epoch_mask_in_place) !=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// try rebias</span></span><br><span class="line">        markOop new_header = (markOop) ( (<span class="keyword">intptr_t</span>) lockee-&gt;<span class="built_in">klass</span>()-&gt;<span class="built_in">prototype_header</span>() | thread_ident);</span><br><span class="line">        <span class="keyword">if</span> (hash != markOopDesc::no_hash) &#123;</span><br><span class="line">          new_header = new_header-&gt;<span class="built_in">copy_set_hash</span>(hash);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span>((<span class="keyword">void</span>*)new_header, lockee-&gt;<span class="built_in">mark_addr</span>(), mark) == mark) &#123;</span><br><span class="line">          <span class="keyword">if</span> (PrintBiasedLockingStatistics)</span><br><span class="line">            (* BiasedLocking::<span class="built_in">rebiased_lock_entry_count_addr</span>())++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 有竞争重偏向失败，调用 monitorenter 锁升级</span></span><br><span class="line">          <span class="built_in">CALL_VM</span>(InterpreterRuntime::<span class="built_in">monitorenter</span>(THREAD, entry), handle_exception);</span><br><span class="line">        &#125;</span><br><span class="line">        success = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ④ 未偏向任何线程，尝试偏向</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        markOop header = (markOop) ((<span class="keyword">uintptr_t</span>) mark &amp; ((<span class="keyword">uintptr_t</span>)markOopDesc::biased_lock_mask_in_place |</span><br><span class="line">                                                        (<span class="keyword">uintptr_t</span>)markOopDesc::age_mask_in_place |</span><br><span class="line">                                                        epoch_mask_in_place));</span><br><span class="line">        <span class="keyword">if</span> (hash != markOopDesc::no_hash) &#123;</span><br><span class="line">          header = header-&gt;<span class="built_in">copy_set_hash</span>(hash);</span><br><span class="line">        &#125;</span><br><span class="line">        markOop new_header = (markOop) ((<span class="keyword">uintptr_t</span>) header | thread_ident);</span><br><span class="line">        <span class="comment">// debugging hint</span></span><br><span class="line">        <span class="built_in">DEBUG_ONLY</span>(entry-&gt;<span class="built_in">lock</span>()-&gt;<span class="built_in">set_displaced_header</span>((markOop) (<span class="keyword">uintptr_t</span>) <span class="number">0xdeaddead</span>);)</span><br><span class="line">        <span class="comment">// CAS 尝试修改</span></span><br><span class="line">        <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span>((<span class="keyword">void</span>*)new_header, lockee-&gt;<span class="built_in">mark_addr</span>(), header) == header) &#123;</span><br><span class="line">          <span class="keyword">if</span> (PrintBiasedLockingStatistics)</span><br><span class="line">            (* BiasedLocking::<span class="built_in">anonymously_biased_lock_entry_count_addr</span>())++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有竞争偏向失败，调用 monitorenter 锁升级</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">CALL_VM</span>(InterpreterRuntime::<span class="built_in">monitorenter</span>(THREAD, entry), handle_exception);</span><br><span class="line">        &#125;</span><br><span class="line">        success = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 走到这里说明偏向的不是当前线程或没有开启偏向锁等原因</span></span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">      <span class="comment">// 轻量级锁逻辑 start</span></span><br><span class="line">      <span class="comment">// 构造无锁状态 Mark Word 的 copy(Displaced Mark Word)</span></span><br><span class="line">      markOop displaced = lockee-&gt;<span class="built_in">mark</span>()-&gt;<span class="built_in">set_unlocked</span>();</span><br><span class="line">      <span class="comment">// 将锁记录空间(Lock Record)指向Displaced Mark Word</span></span><br><span class="line">      entry-&gt;<span class="built_in">lock</span>()-&gt;<span class="built_in">set_displaced_header</span>(displaced);</span><br><span class="line">      <span class="comment">// 是否禁用偏向锁和轻量级锁</span></span><br><span class="line">      <span class="keyword">bool</span> call_vm = UseHeavyMonitors;</span><br><span class="line">      <span class="keyword">if</span> (call_vm || Atomic::<span class="built_in">cmpxchg_ptr</span>(entry, lockee-&gt;<span class="built_in">mark_addr</span>(), displaced) != displaced) &#123;</span><br><span class="line">        <span class="comment">// 判断是不是锁重入，是的话把Displaced Mark Word设置为null来表示重入</span></span><br><span class="line">        <span class="comment">// 置null的原因是因为要记录重入次数，但是mark word大小有限，所以每次重入都在栈帧中新增一个Displaced Mark Word为null的记录</span></span><br><span class="line">        <span class="keyword">if</span> (!call_vm &amp;&amp; THREAD-&gt;<span class="built_in">is_lock_owned</span>((address) displaced-&gt;<span class="built_in">clear_lock_bits</span>())) &#123;</span><br><span class="line">          entry-&gt;<span class="built_in">lock</span>()-&gt;<span class="built_in">set_displaced_header</span>(<span class="literal">NULL</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 若禁用则锁升级</span></span><br><span class="line">          <span class="built_in">CALL_VM</span>(InterpreterRuntime::<span class="built_in">monitorenter</span>(THREAD, entry), handle_exception);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">UPDATE_PC_AND_TOS_AND_CONTINUE</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    istate-&gt;<span class="built_in">set_msg</span>(more_monitors);</span><br><span class="line">    <span class="built_in">UPDATE_PC_AND_RETURN</span>(<span class="number">0</span>); <span class="comment">// Re-execute</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到 <strong>TOP 2</strong> 问题，可以知道在真正系统同步之前对竞争态小的做了偏向锁和轻量级锁的优化。</p><h4 id="3-2-2-偏向锁的撤销"><a href="#3-2-2-偏向锁的撤销" class="headerlink" title="3.2.2 偏向锁的撤销"></a>3.2.2 偏向锁的撤销</h4><p>这里的撤销并不是锁的释放，而是尝试获取偏向锁因为不满足条件把锁改为非偏向锁状态</p><ul><li><code>JavaThread* thread</code> 是指 java 中当前线程</li><li><code>BasicObjectLock* elem</code> 包含对象头数据和 oop 指针</li><li><code>UseBiasedLocking</code> 是指是否启动偏向锁标识，JVM 启动默认是启动偏向锁</li></ul><p>获取偏向锁失败会进入下面逻辑，如果是支持偏向锁，走 <code>fast_enter</code> ，否则走 <code>slow_enter</code></p><p><em>interpreterRuntime.cpp</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">IRT_ENTRY_NO_ASYNC</span>(<span class="keyword">void</span>, InterpreterRuntime::<span class="built_in">monitorenter</span>(JavaThread* thread, BasicObjectLock* elem))</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="comment">// Retry fast entry if bias is revoked to avoid unnecessary inflation</span></span><br><span class="line">    ObjectSynchronizer::<span class="built_in">fast_enter</span>(h_obj, elem-&gt;<span class="built_in">lock</span>(), <span class="literal">true</span>, CHECK);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ObjectSynchronizer::<span class="built_in">slow_enter</span>(h_obj, elem-&gt;<span class="built_in">lock</span>(), CHECK);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">IRT_END</span><br></pre></td></tr></table></figure><p><em>synchronizer.cpp</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectSynchronizer::fast_enter</span><span class="params">(Handle obj, BasicLock* lock, <span class="keyword">bool</span> attempt_rebias, TRAPS)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 再次判断是否开启偏向锁</span></span><br><span class="line"> <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">   <span class="comment">// 未处于全局安全点</span></span><br><span class="line">    <span class="keyword">if</span> (!SafepointSynchronize::<span class="built_in">is_at_safepoint</span>()) &#123;</span><br><span class="line">      <span class="comment">// 撤销或重偏向</span></span><br><span class="line">      BiasedLocking::Condition cond = BiasedLocking::<span class="built_in">revoke_and_rebias</span>(obj, attempt_rebias, THREAD);</span><br><span class="line">      <span class="keyword">if</span> (cond == BiasedLocking::BIAS_REVOKED_AND_REBIASED) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 处于全局安全点，撤销偏向锁</span></span><br><span class="line">      <span class="built_in">assert</span>(!attempt_rebias, <span class="string">&quot;can not rebias toward VM thread&quot;</span>);</span><br><span class="line">      BiasedLocking::<span class="built_in">revoke_at_safepoint</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(!obj-&gt;<span class="built_in">mark</span>()-&gt;<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;biases should be revoked by now&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">slow_enter</span> (obj, lock, THREAD) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>biasedLocking.cpp</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BiasedLocking::Condition <span class="title">BiasedLocking::revoke_and_rebias</span><span class="params">(Handle obj, <span class="keyword">bool</span> attempt_rebias, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取对象头的 Mark Word</span></span><br><span class="line">  markOop mark = obj-&gt;<span class="built_in">mark</span>();</span><br><span class="line">  <span class="comment">// ① 是否是可偏向状态(后三位是否为 1 01) 且 Thread ID 为 null 且 attempt_rebias 为 false(如锁对象的hashcode方法被调用)，需要撤销偏向锁</span></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;<span class="built_in">is_biased_anonymously</span>() &amp;&amp; !attempt_rebias) &#123;</span><br><span class="line">    markOop biased_value       = mark;</span><br><span class="line">    <span class="comment">// 构造非偏向的markword</span></span><br><span class="line">    markOop unbiased_prototype = markOopDesc::<span class="built_in">prototype</span>()-&gt;<span class="built_in">set_age</span>(mark-&gt;<span class="built_in">age</span>());</span><br><span class="line">    <span class="comment">// CAS 设置重新设置偏向锁状态(撤销)</span></span><br><span class="line">    markOop res_mark = (markOop) Atomic::<span class="built_in">cmpxchg_ptr</span>(unbiased_prototype, obj-&gt;<span class="built_in">mark_addr</span>(), mark);</span><br><span class="line">    <span class="keyword">if</span> (res_mark == biased_value) &#123;</span><br><span class="line">      <span class="keyword">return</span> BIAS_REVOKED;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// ② 是否是可偏向状态(后三位是否为 1 01)</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_bias_pattern</span>()) &#123;</span><br><span class="line">    Klass* k = obj-&gt;<span class="built_in">klass</span>();</span><br><span class="line">    markOop prototype_header = k-&gt;<span class="built_in">prototype_header</span>();</span><br><span class="line">    <span class="comment">// ②-① 已经有线程对对象做了锁定,需要撤销偏向锁</span></span><br><span class="line">    <span class="keyword">if</span> (!prototype_header-&gt;<span class="built_in">has_bias_pattern</span>()) &#123;</span><br><span class="line">      markOop biased_value       = mark;</span><br><span class="line">      markOop res_mark = (markOop) Atomic::<span class="built_in">cmpxchg_ptr</span>(prototype_header, obj-&gt;<span class="built_in">mark_addr</span>(), mark);</span><br><span class="line">      <span class="keyword">return</span> BIAS_REVOKED;</span><br><span class="line">    <span class="comment">// ②-② epoch 不相等,说明重偏向过,已过期,需要撤销偏向锁</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prototype_header-&gt;<span class="built_in">bias_epoch</span>() != mark-&gt;<span class="built_in">bias_epoch</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (attempt_rebias) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(THREAD-&gt;<span class="built_in">is_Java_thread</span>(), <span class="string">&quot;&quot;</span>);</span><br><span class="line">        markOop biased_value       = mark;</span><br><span class="line">        markOop rebiased_prototype = markOopDesc::<span class="built_in">encode</span>((JavaThread*) THREAD, mark-&gt;<span class="built_in">age</span>(), prototype_header-&gt;<span class="built_in">bias_epoch</span>());</span><br><span class="line">        markOop res_mark = (markOop) Atomic::<span class="built_in">cmpxchg_ptr</span>(rebiased_prototype, obj-&gt;<span class="built_in">mark_addr</span>(), mark);</span><br><span class="line">        <span class="keyword">if</span> (res_mark == biased_value) &#123;</span><br><span class="line">          <span class="keyword">return</span> BIAS_REVOKED_AND_REBIASED;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 不允许获取偏向锁，撤销锁</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        markOop biased_value       = mark;</span><br><span class="line">        markOop unbiased_prototype = markOopDesc::<span class="built_in">prototype</span>()-&gt;<span class="built_in">set_age</span>(mark-&gt;<span class="built_in">age</span>());</span><br><span class="line">        markOop res_mark = (markOop) Atomic::<span class="built_in">cmpxchg_ptr</span>(unbiased_prototype, obj-&gt;<span class="built_in">mark_addr</span>(), mark);</span><br><span class="line">        <span class="keyword">if</span> (res_mark == biased_value) &#123;</span><br><span class="line">          <span class="keyword">return</span> BIAS_REVOKED;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 批量重偏向 批量撤销</span></span><br><span class="line">  HeuristicsResult heuristics = <span class="built_in">update_heuristics</span>(<span class="built_in">obj</span>(), attempt_rebias);</span><br><span class="line">  <span class="keyword">if</span> (heuristics == HR_NOT_BIASED) &#123;</span><br><span class="line">    <span class="keyword">return</span> NOT_BIASED;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (heuristics == HR_SINGLE_REVOKE) &#123;</span><br><span class="line">    Klass *k = obj-&gt;<span class="built_in">klass</span>();</span><br><span class="line">    markOop prototype_header = k-&gt;<span class="built_in">prototype_header</span>();</span><br><span class="line">    <span class="comment">// 需要撤销的是偏向当前线程的锁</span></span><br><span class="line">    <span class="keyword">if</span> (mark-&gt;<span class="built_in">biased_locker</span>() == THREAD &amp;&amp;</span><br><span class="line">        prototype_header-&gt;<span class="built_in">bias_epoch</span>() == mark-&gt;<span class="built_in">bias_epoch</span>()) &#123;</span><br><span class="line">      ResourceMark rm;</span><br><span class="line">      <span class="keyword">if</span> (TraceBiasedLocking) &#123;</span><br><span class="line">        tty-&gt;<span class="built_in">print_cr</span>(<span class="string">&quot;Revoking bias by walking my own stack:&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      BiasedLocking::Condition cond = <span class="built_in">revoke_bias</span>(<span class="built_in">obj</span>(), <span class="literal">false</span>, <span class="literal">false</span>, (JavaThread*) THREAD);</span><br><span class="line">      ((JavaThread*) THREAD)-&gt;<span class="built_in">set_cached_monitor_info</span>(<span class="literal">NULL</span>);</span><br><span class="line">      <span class="built_in">assert</span>(cond == BIAS_REVOKED, <span class="string">&quot;why not?&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> cond;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 调用revoke_bias方法</span></span><br><span class="line">      <span class="comment">// revoke_bias 主要逻辑</span></span><br><span class="line">      <span class="comment">// 1. 查看当前线程是否存活，不存活直接撤销</span></span><br><span class="line">      <span class="comment">// 2. 偏向的线程如果不在同步块直接撤销(通过遍历线程栈的Lock Record来判断)</span></span><br><span class="line">      <span class="comment">// 3. 轻量级锁逻辑</span></span><br><span class="line">      VM_RevokeBias <span class="built_in">revoke</span>(&amp;obj, (JavaThread*) THREAD);</span><br><span class="line">      VMThread::<span class="built_in">execute</span>(&amp;revoke);</span><br><span class="line">      <span class="keyword">return</span> revoke.<span class="built_in">status_code</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>((heuristics == HR_BULK_REVOKE) ||</span><br><span class="line">         (heuristics == HR_BULK_REBIAS), <span class="string">&quot;?&quot;</span>);</span><br><span class="line">  <span class="comment">// 批量撤销、重定向</span></span><br><span class="line">  <span class="function">VM_BulkRevokeBias <span class="title">bulk_revoke</span><span class="params">(&amp;obj, (JavaThread*) THREAD,</span></span></span><br><span class="line"><span class="params"><span class="function">                                (heuristics == HR_BULK_REBIAS),</span></span></span><br><span class="line"><span class="params"><span class="function">                                attempt_rebias)</span></span>;</span><br><span class="line">  VMThread::<span class="built_in">execute</span>(&amp;bulk_revoke);</span><br><span class="line">  <span class="keyword">return</span> bulk_revoke.<span class="built_in">status_code</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-重量级锁"><a href="#3-3-重量级锁" class="headerlink" title="3.3 重量级锁"></a>3.3 重量级锁</h3><p><em>synchronizer.cpp</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectSynchronizer::slow_enter</span><span class="params">(Handle obj, BasicLock* lock, TRAPS)</span> </span>&#123;</span><br><span class="line">  markOop mark = obj-&gt;<span class="built_in">mark</span>();</span><br><span class="line">  <span class="built_in">assert</span>(!mark-&gt;<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;should not see bias pattern here&quot;</span>);</span><br><span class="line"><span class="comment">// 如果是无锁状态</span></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;<span class="built_in">is_neutral</span>()) &#123;</span><br><span class="line">    <span class="comment">// Anticipate successful CAS -- the ST of the displaced mark must</span></span><br><span class="line">    <span class="comment">// be visible &lt;= the ST performed by the CAS.</span></span><br><span class="line">    lock-&gt;<span class="built_in">set_displaced_header</span>(mark);</span><br><span class="line">    <span class="keyword">if</span> (mark == (markOop) Atomic::<span class="built_in">cmpxchg_ptr</span>(lock, <span class="built_in">obj</span>()-&gt;<span class="built_in">mark_addr</span>(), mark)) &#123;</span><br><span class="line">      <span class="built_in">TEVENT</span> (slow_enter: release stacklock) ;</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 轻量级锁重入</span></span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_locker</span>() &amp;&amp; THREAD-&gt;<span class="built_in">is_lock_owned</span>((address)mark-&gt;<span class="built_in">locker</span>())) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(lock != mark-&gt;<span class="built_in">locker</span>(), <span class="string">&quot;must not re-lock the same lock&quot;</span>);</span><br><span class="line">    <span class="built_in">assert</span>(lock != (BasicLock*)obj-&gt;<span class="built_in">mark</span>(), <span class="string">&quot;don&#x27;t relock with same BasicLock&quot;</span>);</span><br><span class="line">    lock-&gt;<span class="built_in">set_displaced_header</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">  <span class="comment">// 锁标记为_ 10,膨胀为重量级锁,调用 enter 方法</span></span><br><span class="line">  lock-&gt;<span class="built_in">set_displaced_header</span>(markOopDesc::<span class="built_in">unused_mark</span>());</span><br><span class="line">  ObjectSynchronizer::<span class="built_in">inflate</span>(THREAD, <span class="built_in">obj</span>())-&gt;<span class="built_in">enter</span>(THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-1-膨胀过程"><a href="#3-3-1-膨胀过程" class="headerlink" title="3.3.1 膨胀过程"></a>3.3.1 膨胀过程</h4><p>膨胀过程很简单，就是对不同状态的对象进行不同的处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ObjectMonitor * ATTR <span class="title">ObjectSynchronizer::inflate</span> <span class="params">(Thread * Self, oop object)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span> (Universe::<span class="built_in">verify_in_progress</span>() ||</span><br><span class="line">          !SafepointSynchronize::<span class="built_in">is_at_safepoint</span>(), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">const</span> markOop mark = object-&gt;<span class="built_in">mark</span>() ;</span><br><span class="line">    <span class="comment">// ① 如果已经是重量级锁状态直接返回</span></span><br><span class="line">      <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_monitor</span>()) &#123;</span><br><span class="line">          ObjectMonitor * inf = mark-&gt;<span class="built_in">monitor</span>() ;</span><br><span class="line">          <span class="keyword">return</span> inf ;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// ② 如果是正在膨胀中，重试等待另一个膨胀完</span></span><br><span class="line"><span class="keyword">if</span> (mark == markOopDesc::<span class="built_in">INFLATING</span>()) &#123;</span><br><span class="line">         <span class="built_in">TEVENT</span> (Inflate: spin <span class="keyword">while</span> INFLATING) ;</span><br><span class="line">         <span class="built_in">ReadStableMark</span>(object) ;</span><br><span class="line">         <span class="keyword">continue</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// ③ 如果是轻量级锁状态</span></span><br><span class="line"><span class="keyword">if</span> (mark-&gt;<span class="built_in">has_locker</span>()) &#123;</span><br><span class="line">        <span class="comment">// 先初始化 ObjectMonitor 对象</span></span><br><span class="line">          ObjectMonitor * m = <span class="built_in">omAlloc</span> (Self) ;</span><br><span class="line">          m-&gt;<span class="built_in">Recycle</span>();</span><br><span class="line">          m-&gt;_Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">          m-&gt;OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">          m-&gt;_recursions   = <span class="number">0</span> ;</span><br><span class="line">          m-&gt;_SpinDuration = ObjectMonitor::Knob_SpinLimit ;   <span class="comment">// Consider: maintain by type/class</span></span><br><span class="line"><span class="comment">// 设置状态为膨胀中</span></span><br><span class="line">          markOop cmp = (markOop) Atomic::<span class="built_in">cmpxchg_ptr</span> (markOopDesc::<span class="built_in">INFLATING</span>(), object-&gt;<span class="built_in">mark_addr</span>(), mark) ;</span><br><span class="line">          <span class="keyword">if</span> (cmp != mark) &#123;</span><br><span class="line">             <span class="built_in">omRelease</span> (Self, m, <span class="literal">true</span>) ;</span><br><span class="line">             <span class="keyword">continue</span> ;       <span class="comment">// Interference -- just retry</span></span><br><span class="line">          &#125;</span><br><span class="line">          markOop dmw = mark-&gt;<span class="built_in">displaced_mark_helper</span>() ;</span><br><span class="line">          <span class="comment">// Setup monitor fields to proper values -- prepare the monitor</span></span><br><span class="line">          m-&gt;<span class="built_in">set_header</span>(dmw) ;</span><br><span class="line">          m-&gt;<span class="built_in">set_owner</span>(mark-&gt;<span class="built_in">locker</span>());</span><br><span class="line">          m-&gt;<span class="built_in">set_object</span>(object);</span><br><span class="line">          <span class="built_in">guarantee</span> (object-&gt;<span class="built_in">mark</span>() == markOopDesc::<span class="built_in">INFLATING</span>(), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">        <span class="comment">// 将锁对象头设置为重量级锁状态</span></span><br><span class="line">          object-&gt;<span class="built_in">release_set_mark</span>(markOopDesc::<span class="built_in">encode</span>(m));</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (ObjectMonitor::_sync_Inflations != <span class="literal">NULL</span>) ObjectMonitor::_sync_Inflations-&gt;<span class="built_in">inc</span>() ;</span><br><span class="line">          <span class="built_in">TEVENT</span>(Inflate: overwrite stacklock) ;</span><br><span class="line">          <span class="keyword">if</span> (TraceMonitorInflation) &#123;</span><br><span class="line">            <span class="keyword">if</span> (object-&gt;<span class="built_in">is_instance</span>()) &#123;</span><br><span class="line">              ResourceMark rm;</span><br><span class="line">              tty-&gt;<span class="built_in">print_cr</span>(<span class="string">&quot;Inflating object &quot;</span> INTPTR_FORMAT <span class="string">&quot; , mark &quot;</span> INTPTR_FORMAT <span class="string">&quot; , type %s&quot;</span>,</span><br><span class="line">                (<span class="keyword">void</span> *) object, (<span class="keyword">intptr_t</span>) object-&gt;<span class="built_in">mark</span>(),</span><br><span class="line">                object-&gt;<span class="built_in">klass</span>()-&gt;<span class="built_in">external_name</span>());</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> m ;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// ④ 如果是无锁状态</span></span><br><span class="line">      ObjectMonitor * m = <span class="built_in">omAlloc</span> (Self) ;</span><br><span class="line">      <span class="comment">// prepare m for installation - set monitor to initial state</span></span><br><span class="line">      m-&gt;<span class="built_in">Recycle</span>();</span><br><span class="line">      m-&gt;<span class="built_in">set_header</span>(mark);</span><br><span class="line">      m-&gt;<span class="built_in">set_owner</span>(<span class="literal">NULL</span>);</span><br><span class="line">      m-&gt;<span class="built_in">set_object</span>(object);</span><br><span class="line">      m-&gt;OwnerIsThread = <span class="number">1</span> ;</span><br><span class="line">      m-&gt;_recursions   = <span class="number">0</span> ;</span><br><span class="line">      m-&gt;_Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">      m-&gt;_SpinDuration = ObjectMonitor::Knob_SpinLimit ;       <span class="comment">// consider: keep metastats by type/class</span></span><br><span class="line"><span class="comment">// CAS 设置对象头标志为重量级锁</span></span><br><span class="line">      <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span> (markOopDesc::<span class="built_in">encode</span>(m), object-&gt;<span class="built_in">mark_addr</span>(), mark) != mark) &#123;</span><br><span class="line">          <span class="comment">// 有竞争设置失败，释放monitor重试</span></span><br><span class="line">        m-&gt;<span class="built_in">set_object</span> (<span class="literal">NULL</span>) ;</span><br><span class="line">          m-&gt;<span class="built_in">set_owner</span>  (<span class="literal">NULL</span>) ;</span><br><span class="line">          m-&gt;OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">          m-&gt;<span class="built_in">Recycle</span>() ;</span><br><span class="line">          <span class="built_in">omRelease</span> (Self, m, <span class="literal">true</span>) ;</span><br><span class="line">          m = <span class="literal">NULL</span> ;</span><br><span class="line">          <span class="keyword">continue</span> ;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Hopefully the performance counters are allocated on distinct</span></span><br><span class="line">      <span class="comment">// cache lines to avoid false sharing on MP systems ...</span></span><br><span class="line">      <span class="keyword">if</span> (ObjectMonitor::_sync_Inflations != <span class="literal">NULL</span>) ObjectMonitor::_sync_Inflations-&gt;<span class="built_in">inc</span>() ;</span><br><span class="line">      <span class="built_in">TEVENT</span>(Inflate: overwrite neutral) ;</span><br><span class="line">      <span class="keyword">if</span> (TraceMonitorInflation) &#123;</span><br><span class="line">        <span class="keyword">if</span> (object-&gt;<span class="built_in">is_instance</span>()) &#123;</span><br><span class="line">          ResourceMark rm;</span><br><span class="line">          tty-&gt;<span class="built_in">print_cr</span>(<span class="string">&quot;Inflating object &quot;</span> INTPTR_FORMAT <span class="string">&quot; , mark &quot;</span> INTPTR_FORMAT <span class="string">&quot; , type %s&quot;</span>,</span><br><span class="line">            (<span class="keyword">void</span> *) object, (<span class="keyword">intptr_t</span>) object-&gt;<span class="built_in">mark</span>(),</span><br><span class="line">            object-&gt;<span class="built_in">klass</span>()-&gt;<span class="built_in">external_name</span>());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> m ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-获取重量级锁"><a href="#3-3-2-获取重量级锁" class="headerlink" title="3.3.2 获取重量级锁"></a>3.3.2 获取重量级锁</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> ATTR <span class="title">ObjectMonitor::enter</span><span class="params">(TRAPS)</span> </span>&#123;</span><br><span class="line">  Thread * <span class="keyword">const</span> Self = THREAD ;</span><br><span class="line">  <span class="keyword">void</span> * cur ;</span><br><span class="line"><span class="comment">// 无锁状态，通过 CAS 直接获得锁</span></span><br><span class="line">  cur = Atomic::<span class="built_in">cmpxchg_ptr</span> (Self, &amp;_owner, <span class="literal">NULL</span>) ;</span><br><span class="line">  <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 锁重入，计数，直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (cur == Self) &#123;</span><br><span class="line">     _recursions ++ ;</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 当前线程之前是轻量级锁状态，重置owner为当前线程(之前是执行锁记录(Lock Record)的指针),重置重入计数为1</span></span><br><span class="line">  <span class="keyword">if</span> (Self-&gt;<span class="built_in">is_lock_owned</span> ((address)cur)) &#123;</span><br><span class="line">    <span class="built_in">assert</span> (_recursions == <span class="number">0</span>, <span class="string">&quot;internal state error&quot;</span>);</span><br><span class="line">    _recursions = <span class="number">1</span> ;</span><br><span class="line">    _owner = Self ;</span><br><span class="line">    OwnerIsThread = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  Self-&gt;_Stalled = <span class="built_in">intptr_t</span>(<span class="keyword">this</span>) ;</span><br><span class="line">  <span class="comment">// 调用系统同步操作之前，先尝试自旋获得锁</span></span><br><span class="line">  <span class="keyword">if</span> (Knob_SpinEarly &amp;&amp; <span class="built_in">TrySpin</span> (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">     Self-&gt;_Stalled = <span class="number">0</span> ;</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  JavaThread * jt = (JavaThread *) Self ;</span><br><span class="line">  Atomic::<span class="built_in">inc_ptr</span>(&amp;_count);</span><br><span class="line">  EventJavaMonitorEnter event;</span><br><span class="line"></span><br><span class="line">  &#123; </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      jt-&gt;<span class="built_in">set_suspend_equivalent</span>();</span><br><span class="line">      <span class="built_in">EnterI</span> (THREAD) ;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">ExitSuspendEquivalent</span>(jt)) <span class="keyword">break</span> ;</span><br><span class="line">      _recursions = <span class="number">0</span> ;</span><br><span class="line">      _succ = <span class="literal">NULL</span> ;</span><br><span class="line">      <span class="built_in">exit</span> (<span class="literal">false</span>, Self) ;</span><br><span class="line"></span><br><span class="line">      jt-&gt;<span class="built_in">java_suspend_self</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    Self-&gt;<span class="built_in">set_current_pending_monitor</span>(<span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-3-调用-EnterI-方法获得锁"><a href="#3-3-3-调用-EnterI-方法获得锁" class="headerlink" title="3.3.3 调用 EnterI 方法获得锁"></a>3.3.3 调用 EnterI 方法获得锁</h4><p>核心逻辑分为三步：</p><ol><li>将当前线程封装为 node 塞到队列 cxq 的队头</li><li>调用 park 挂起当前线程</li><li>被唤醒后再次尝试获取锁(在唤醒时候会根据不同的唤醒策略定义 cxq 与 EntryList 的优先级)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> ATTR <span class="title">ObjectMonitor::EnterI</span> <span class="params">(TRAPS)</span> </span>&#123;</span><br><span class="line">    Thread * Self = THREAD ;</span><br><span class="line">    <span class="comment">// 尝试获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">TryLock</span> (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DeferredInitialize</span> () ;</span><br><span class="line"><span class="comment">// 自旋</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">TrySpin</span> (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 如果没获取到锁(锁被占用)就把线程封装到node节点中</span></span><br><span class="line">    <span class="function">ObjectWaiter <span class="title">node</span><span class="params">(Self)</span> </span>;</span><br><span class="line">    Self-&gt;_ParkEvent-&gt;<span class="built_in">reset</span>() ;</span><br><span class="line">    node._prev   = (ObjectWaiter *) <span class="number">0xBAD</span> ;</span><br><span class="line">    node.TState  = ObjectWaiter::TS_CXQ ;</span><br><span class="line">    ObjectWaiter * nxt ;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="comment">// 将node节点插入到 cxq 队列的头部</span></span><br><span class="line">        node._next = nxt = _cxq ;</span><br><span class="line">      <span class="comment">// CAS 成功直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span> (&amp;node, &amp;_cxq, nxt) == nxt) <span class="keyword">break</span> ;</span><br><span class="line">        <span class="comment">// CAS 失败走这里，重试获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">TryLock</span> (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 如果没有等待的线程，把_Responsible设置为自己</span></span><br><span class="line">    <span class="keyword">if</span> ((SyncFlags &amp; <span class="number">16</span>) == <span class="number">0</span> &amp;&amp; nxt == <span class="literal">NULL</span> &amp;&amp; _EntryList == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Atomic::<span class="built_in">cmpxchg_ptr</span> (Self, &amp;_Responsible, <span class="literal">NULL</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">TEVENT</span> (Inflated enter - Contention) ;</span><br><span class="line">    <span class="keyword">int</span> nWakeups = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">int</span> RecheckInterval = <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="comment">// 再次尝试获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">TryLock</span> (Self) &gt; <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((SyncFlags &amp; <span class="number">2</span>) &amp;&amp; _Responsible == <span class="literal">NULL</span>) &#123;</span><br><span class="line">           Atomic::<span class="built_in">cmpxchg_ptr</span> (Self, &amp;_Responsible, <span class="literal">NULL</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 park 函数挂起当前线程</span></span><br><span class="line">        <span class="keyword">if</span> (_Responsible == Self || (SyncFlags &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="built_in">TEVENT</span> (Inflated enter - park TIMED) ;</span><br><span class="line">            Self-&gt;_ParkEvent-&gt;<span class="built_in">park</span> ((jlong) RecheckInterval) ;</span><br><span class="line">            <span class="comment">// Increase the RecheckInterval, but clamp the value.</span></span><br><span class="line">            RecheckInterval *= <span class="number">8</span> ;</span><br><span class="line">            <span class="keyword">if</span> (RecheckInterval &gt; <span class="number">1000</span>) RecheckInterval = <span class="number">1000</span> ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">TEVENT</span> (Inflated enter - park UNTIMED) ;</span><br><span class="line">            Self-&gt;_ParkEvent-&gt;<span class="built_in">park</span>() ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">TryLock</span>(Self) &gt; <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">        <span class="built_in">TEVENT</span> (Inflated enter - Futile wakeup) ;</span><br><span class="line">        <span class="keyword">if</span> (ObjectMonitor::_sync_FutileWakeups != <span class="literal">NULL</span>) &#123;</span><br><span class="line">           ObjectMonitor::_sync_FutileWakeups-&gt;<span class="built_in">inc</span>() ;</span><br><span class="line">        &#125;</span><br><span class="line">        ++ nWakeups ;</span><br><span class="line">        <span class="keyword">if</span> ((Knob_SpinAfterFutile &amp; <span class="number">1</span>) &amp;&amp; <span class="built_in">TrySpin</span> (Self) &gt; <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">        <span class="keyword">if</span> ((Knob_ResetEvent &amp; <span class="number">1</span>) &amp;&amp; Self-&gt;_ParkEvent-&gt;<span class="built_in">fired</span>()) &#123;</span><br><span class="line">           Self-&gt;_ParkEvent-&gt;<span class="built_in">reset</span>() ;</span><br><span class="line">           OrderAccess::<span class="built_in">fence</span>() ;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 在释放锁时，_succ会被设置为 EntryList 或 cxq 中的一个线程</span></span><br><span class="line">        <span class="keyword">if</span> (_succ == Self) _succ = <span class="literal">NULL</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Invariant: after clearing _succ a thread *must* retry _owner before parking.</span></span><br><span class="line">        OrderAccess::<span class="built_in">fence</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 上个死循环如果结束意味着获取到锁了</span></span><br><span class="line">  <span class="comment">// 将当前线程 node 从 EntryList 或 cxq 移除</span></span><br><span class="line"><span class="built_in">UnlinkAfterAcquire</span> (Self, &amp;node) ;</span><br><span class="line">    <span class="keyword">if</span> (_succ == Self) _succ = <span class="literal">NULL</span> ;</span><br><span class="line">    <span class="keyword">if</span> (_Responsible == Self) &#123;</span><br><span class="line">        _Responsible = <span class="literal">NULL</span> ;</span><br><span class="line">        OrderAccess::<span class="built_in">fence</span>(); <span class="comment">// Dekker pivot-point</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (SyncFlags &amp; <span class="number">8</span>) &#123;</span><br><span class="line">       OrderAccess::<span class="built_in">fence</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>可以看到 Synchronized 的加锁过程非常复杂，但是核心设计还是在不同的竞争态选择不同的优化模式，尽量使同步的开销减少到最小。而重量级的实现可以发现就是管程的一种实现模式，对比并发包的 Java 层面实现的管程，Synchronized 的条件变量等待队列比较单一，只有 wait 一种。虽然灵活性不如并发包的锁，但是在异常不可控和代码维护方面 Synchronized 无疑是更好。</p><p>回到 <strong>TOP 3</strong> 问题，可以知道 Synchronized 缺点就是不灵活(条件变量、代码使用、超时时间)，不公平，不能响应中断。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Synchronized </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>管程和信号量分析</title>
      <link href="/2019/10-Monitor/"/>
      <url>/2019/10-Monitor/</url>
      
        <content type="html"><![CDATA[<h2 id="TOP-带着问题来分析"><a href="#TOP-带着问题来分析" class="headerlink" title="TOP 带着问题来分析"></a>TOP 带着问题来分析</h2><ol><li>管程和信号量区别</li><li>为什么 Mesa 模型的 wait() 支持超时参数</li></ol><span id="more"></span><h2 id="1-管程-Monitor"><a href="#1-管程-Monitor" class="headerlink" title="1. 管程(Monitor)"></a>1. 管程(Monitor)</h2><p>管程也被称为监视器，指的是通过管理共享变量以及对共享变量的操作过程，实现了在一个时间点，最多只有一个线程在执行(线程安全的，支持并发)。</p><p>管程与信号量是等价的，信号量我们下面会有介绍，管程相比信号量来说，其隐蔽了同步的细节，更易于用户维护，而信号量的 PV 操作会大量分散到代码的地方，不易维护容易造成死锁，所以 Java 选择了管程(面向对象方法)。</p><p>回到问题 <strong>TOP 1</strong> ，可以明白其区别主要是在面向程序员的维护与体验。</p><p>我们来举一个场景，线程 T1 去操作管程中的共享数据，但是因为还不满足 “条件”(例如条件是队列不空)，这个时候 T1 入条件对应的等待队列；假设之后线程 T2 入队成功，满足了 T1 的 “条件”。这个时候 T2 是先唤醒 T1 再执行还是自己执行完再唤醒呢？</p><p>针对这个场景，我们来看管程的三种模型：</p><h3 id="1-1-Mesa-模型"><a href="#1-1-Mesa-模型" class="headerlink" title="1.1 Mesa 模型"></a>1.1 Mesa 模型</h3><p>Mesa 模型是现在广泛应用的模型，Java 管程也是参考的该模型。可以看到在处理以上场景时，也就是图中第 4 步，T1 线程被唤醒后会从 “条件” 等待队列转移到入口队列，T2 线程会继续执行，最后 T1 从入口队列出来继续执行。</p><p><a href="http://qiniu.itliusir.com/mesa.png"><img src="http://qiniu.itliusir.com/mesa.png" alt="img"></a></p><h3 id="1-2-Hoare-模型"><a href="#1-2-Hoare-模型" class="headerlink" title="1.2 Hoare 模型"></a>1.2 Hoare 模型</h3><p>与 Mesa 模型不同的是，Hoare 模型在处理这个场景时，同样在第 4 步是把 T2 线程放入一个 Signal 队列等待唤醒，T1 线程执行完会去 Signal 队列唤醒 T2(如果 Signal 队列为空才去入口队列调度)，T2 重新开始。</p><p><a href="http://qiniu.itliusir.com/hoare.png"><img src="http://qiniu.itliusir.com/hoare.png" alt="img"></a></p><h3 id="1-3-Brinch-Hanson-模型"><a href="#1-3-Brinch-Hanson-模型" class="headerlink" title="1.3 Brinch Hanson 模型"></a>1.3 Brinch Hanson 模型</h3><p>该模型仅允许线程完成(从 Monitor 退出时)发出信号唤醒，也即是第 4 步 T2 线程会一直执行完再去唤醒 T1 。</p><p><a href="http://qiniu.itliusir.com/brinch_hanson.png"><img src="http://qiniu.itliusir.com/brinch_hanson.png" alt="img"></a></p><p>三种模型中，第一种 Mesa 模型的 wait() 是支持超时参数，因为 Mesa 模型中唤醒后进入的是入口等待队列，不一定执行，而后两种模型唤醒后是会直接调度的，所以不需要超时时间。</p><p>回到问题 <strong>TOP 2</strong> ，可以明白其参数的意义。</p><p>相对来说Hoare 模型增加了一个队列(类似优先队列)成本较高，Brinch Hanson 模型较为简单，而且唤醒对比 Mesa 模型保证能一定执行。</p><p>对于 JAVA 层面的管程实现 AQS，可以参考后面几篇源码分析。</p><h2 id="2-信号量-Semaphore"><a href="#2-信号量-Semaphore" class="headerlink" title="2. 信号量(Semaphore)"></a>2. 信号量(Semaphore)</h2><p>并发编程领域的大师 <em>Edsger Dijkstra</em> 提出了一种经典的解决同步不同执行线程问题的方法，这个方法是基于一种叫做 <strong>信号量</strong> 的特殊类型变量的。它由两种特殊的操作来处理，这两种操作称为 P 和 V。</p><ul><li><p><strong>P(s) 操作</strong></p><p>P(s) 把共享变量(信号量) s 减 1，并且立即返回。如果 s 为 0，则挂起这个线程直到变成非0</p></li><li><p><strong>V(s) 操作</strong></p><p>V(s) 把 s 加 1。如果有线程阻塞在 P 操作等待 s 变成非 0，V 操作会唤醒这些线程中的一个，然后把 s 减 1(P 操作)</p></li></ul><p>P V 操作看起来很抽象，我们举个现实中采用信号量控制线程的例子，例如我们信号量设置的是2，也就是同时只允许2个线程处理，当第三个线程 T3 来的时候 T1、T2 还没处理完的情况下，T3 会阻塞到 T1 或 T2 执行完成并且通过 V 操作(加1，释放一个位置给别人)，这个时候 T3 进行 P操作(减一，把这个位置占用)。</p><p>同样的如果s我们设置为1，则可以实现线程之间的互斥操作。</p><p>关于 Java 版本的信号量实现可以参考后面几篇源码分析。</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信号量 </tag>
            
            <tag> 管程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LongAdder 源码分析</title>
      <link href="/2019/07-LongAdder/"/>
      <url>/2019/07-LongAdder/</url>
      
        <content type="html"><![CDATA[<h2 id="TOP-带着问题看源码"><a href="#TOP-带着问题看源码" class="headerlink" title="TOP 带着问题看源码"></a>TOP 带着问题看源码</h2><ol><li>有了 AtomicLong 为什么还会有 LongAdder</li></ol><span id="more"></span><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p>LongAdder 是一个线程安全，JDK 8新加入的一个用来计数的工具类</p><p>按照作者的说法，LongAdder 在多个线程更新下比 AtomicLong 性能更好，但要消耗更多的空间</p><p>LongAdder 继承自 Striped64，其对一些简单情况做了处理(cell 存在且更新没有竞争)，复杂情况交给 Striped64 的 longAccumulate。</p><h2 id="2-Striped64"><a href="#2-Striped64" class="headerlink" title="2. Striped64"></a>2. Striped64</h2><p>Striped64 设计思路是把多个线程分散到不同计数单元，减少线程竞争，提高并发效率</p><h3 id="2-1-成员变量分析"><a href="#2-1-成员变量分析" class="headerlink" title="2.1 成员变量分析"></a>2.1 成员变量分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可用 CPU 数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line"><span class="comment">// cell 数组，大小为2的幂次方</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;</span><br><span class="line"><span class="comment">// 基础偏移值</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> base;</span><br><span class="line"><span class="comment">// 0 无锁 1 有锁</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br></pre></td></tr></table></figure><h3 id="2-2-Cell-类分析"><a href="#2-2-Cell-类分析" class="headerlink" title="2.2 Cell 类分析"></a>2.2 Cell 类分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Cell</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">    Cell(<span class="keyword">long</span> x) &#123; value = x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">cas</span><span class="params">(<span class="keyword">long</span> cmp, <span class="keyword">long</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, valueOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe mechanics</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; ak = Cell.class;</span><br><span class="line">            valueOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (ak.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Cell</code> 类是 <code>Striped64</code> 的静态内部类。通过注解 [<code>@sun.misc.Contended](mailto:</code>@sun.misc.Contended)` 来自动实现缓存行填充，让 Java 编译器和 JRE 运行时来决定如何填充。本质上是一个填充了的、提供了 CAS 更新的 volatile 变量。</p><h3 id="2-3-longAccumulate-分析"><a href="#2-3-longAccumulate-分析" class="headerlink" title="2.3 longAccumulate() 分析"></a>2.3 longAccumulate() 分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">longAccumulate</span><span class="params">(<span class="keyword">long</span> x, LongBinaryOperator fn,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">  <span class="comment">// 获取线程的 probe hash值，如果 seed 初始化，probe 为非0</span></span><br><span class="line">    <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果 probe 为0，就强制初始化一次</span></span><br><span class="line">        ThreadLocalRandom.current(); <span class="comment">// force initialization</span></span><br><span class="line">      <span class="comment">// get 到 probe</span></span><br><span class="line">        h = getProbe();</span><br><span class="line">        wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Cell[] as; Cell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</span><br><span class="line">        <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 通过 hash值获取数组 cells 一个index</span></span><br><span class="line">            <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 当前位置为空，并且拿到锁(cellsBusy 0是无锁，1是有锁)</span></span><br><span class="line">                <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;       <span class="comment">// Try to attach new Cell</span></span><br><span class="line">                  <span class="comment">// 构建一个 Cell</span></span><br><span class="line">                    Cell r = <span class="keyword">new</span> Cell(x);   <span class="comment">// Optimistically create</span></span><br><span class="line">                  <span class="comment">// casCellsBusy 会把 cellsBuy 设置为1，也即是获取锁</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                      <span class="comment">// 创建标识</span></span><br><span class="line">                        <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">                            Cell[] rs; <span class="keyword">int</span> m, j;</span><br><span class="line">                            <span class="keyword">if</span> ((rs = cells) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                <span class="comment">// 计算hash位置j</span></span><br><span class="line">                                rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                              <span class="comment">// 把新构建的 Cell 塞到数组cells的index j的地方</span></span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                              <span class="comment">// 更新创建完成状态</span></span><br><span class="line">                                created = <span class="keyword">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                          <span class="comment">// free lock</span></span><br><span class="line">                            cellsBusy = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                      <span class="comment">// 如果完成直接退出</span></span><br><span class="line">                        <span class="keyword">if</span> (created)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                      <span class="comment">// 否则继续创建(失败)</span></span><br><span class="line">                        <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">// 执行到这里说明也是失败(没拿到锁)，设置碰撞标识为false</span></span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// hash位置已经有值，则往下走</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">                wasUncontended = <span class="keyword">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line">          <span class="comment">// 对当前位置累加，例如原本地方的值是1，要加1，现在则为2。成功就退出</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line">                                         fn.applyAsLong(v, x))))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">              <span class="comment">// cells 长度大于cpu数量，设置碰撞标识为false</span></span><br><span class="line">                collide = <span class="keyword">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">              <span class="comment">// 碰撞标识设置为 true</span></span><br><span class="line">                collide = <span class="keyword">true</span>;</span><br><span class="line">          <span class="comment">// 说明前面操作没有成功，再次尝试获取锁进行扩容</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cells == as) &#123;      <span class="comment">// Expand table unless stale</span></span><br><span class="line">                      <span class="comment">// 扩容2倍，然后数组copy</span></span><br><span class="line">                        Cell[] rs = <span class="keyword">new</span> Cell[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                            rs[i] = as[i];</span><br><span class="line">                        cells = rs;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  <span class="comment">// lock free</span></span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">// 扩容后重试</span></span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 重新计算 hash 值</span></span><br><span class="line">            h = advanceProbe(h);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 1. 初始化 cells，</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">                <span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line">                  <span class="comment">// 最开始容量是2</span></span><br><span class="line">                    Cell[] rs = <span class="keyword">new</span> Cell[<span class="number">2</span>];</span><br><span class="line">                  <span class="comment">// hash对应位置赋值</span></span><br><span class="line">                    rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> Cell(x);</span><br><span class="line">                    cells = rs;</span><br><span class="line">                    init = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                cellsBusy = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (init)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 初始化失败，CAS 把 value 累加到 base</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line">                                    fn.applyAsLong(v, x))))</span><br><span class="line">            <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-add-分析"><a href="#3-add-分析" class="headerlink" title="3. add() 分析"></a>3. add() 分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    Cell[] as; <span class="keyword">long</span> b, v; <span class="keyword">int</span> m; Cell a;</span><br><span class="line">  <span class="comment">// cells 为空直接使用 cas 赋值，cas成功直接返回</span></span><br><span class="line">    <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">          <span class="comment">// cas 失败 || cells 不为空 且 index 处为null || cas 再次修改失败</span></span><br><span class="line">          <span class="comment">// 调用 Striped64 的 longAccumulate</span></span><br><span class="line">            longAccumulate(x, <span class="keyword">null</span>, uncontended);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-sum-分析"><a href="#4-sum-分析" class="headerlink" title="4. sum() 分析"></a>4. sum() 分析</h2><p>熟悉 ConcurrentHashMap 的同鞋看到 sum 相比已经很熟悉，惰性按需计算，可能会不太精准</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">  <span class="comment">// 先统计 base的值</span></span><br><span class="line">    <span class="keyword">long</span> sum = base;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 再遍历 cells 中的值进行累加</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-reset-分析"><a href="#5-reset-分析" class="headerlink" title="5. reset() 分析"></a>5. reset() 分析</h2><p>遍历 cells 数组，重置为0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    base = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                a.value = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以看到 LongAdder 的核心思路就是保证高并发最坏的情况，通过对线程进行散列分片减少竞争时长，利用上了多核的性能。这种设计方式和 CSAPP 中 <a href="http://itliusir.com/2019/07-LongAdder/[https://github.com/itliusir/CS_Notes/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E5%8D%81%E4%BA%8C).md#%E6%8F%90%E9%AB%98%E5%B9%B6%E8%A1%8C%E6%80%A7](https://github.com/itliusir/CS_Notes/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E5%8D%81%E4%BA%8C).md#%E6%8F%90%E9%AB%98%E5%B9%B6%E8%A1%8C%E6%80%A7">提高并行性</a> 提到的方式是一样的。</p><p>回到开篇 <strong>TOP 1</strong> 问题，可以看到 LongAdder 主要目的是解决高并发下 AtomicLong 自旋开销问题 。</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LongAdder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AtomicStampedReference 源码分析</title>
      <link href="/2019/06-AtomicStampedReference/"/>
      <url>/2019/06-AtomicStampedReference/</url>
      
        <content type="html"><![CDATA[<h2 id="TOP-带着问题看源码"><a href="#TOP-带着问题看源码" class="headerlink" title="TOP 带着问题看源码"></a>TOP 带着问题看源码</h2><ol><li>CAS ABA 是什么</li><li>AtomicStampedReference 是怎么解决 CAS ABA问题的</li></ol><span id="more"></span><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p>AtomicStampedReference 是对 AtomicReference 的一个补充，解决了在 CAS 场景下 ABA 的问题</p><h2 id="2-CAS-ABA-是什么"><a href="#2-CAS-ABA-是什么" class="headerlink" title="2. CAS ABA 是什么"></a>2. CAS ABA 是什么</h2><p>从前面几篇分析，我们已经知道了 CAS 其实是一条 CPU 指令，作用是比较和替换，但是有可能 内存值原本是 A 然后变成 B 最后又变回了 A，这个时候 CAS 比较 A 发现是通过的(认为没有变化或者说是竞争)，也就直接更新了，但是实际是有变化的。</p><p>一个解决思路就是加一个版本戳，每次更新变量同步更新一下版本号。这样就发现 1A != 3A，也就不会更新成功了。</p><p>回到 <strong>TOP 1</strong> 可以明白在并发情况下出现 ABA 的原因</p><h2 id="3-内部结构"><a href="#3-内部结构" class="headerlink" title="3. 内部结构"></a>3. 内部结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> T reference;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> stamp;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.reference = reference;</span><br><span class="line">        <span class="keyword">this</span>.stamp = stamp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">of</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, stamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Pair&lt;V&gt; pair;</span><br></pre></td></tr></table></figure><p>我们可以发现，AtomicStampedReference 对比 AtomicReference，全局维护的不是 T reference，而是 Pair。Pair 对象里多维护了一个 stamp 标识。</p><h2 id="4-AtomicStampedReference-的-CAS"><a href="#4-AtomicStampedReference-的-CAS" class="headerlink" title="4. AtomicStampedReference 的 CAS"></a>4. AtomicStampedReference 的 CAS</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="params"><span class="function">                             V   newReference,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">    Pair&lt;V&gt; current = pair;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">      <span class="comment">// 1 引用没变</span></span><br><span class="line">        expectedReference == current.reference &amp;&amp;</span><br><span class="line">      <span class="comment">// 2 版本号没变</span></span><br><span class="line">        expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">      <span class="comment">// 3 新引用等于旧引用</span></span><br><span class="line">        ((newReference == current.reference &amp;&amp;</span><br><span class="line">          <span class="comment">// 4 新版本号等于旧版本号</span></span><br><span class="line">          newStamp == current.stamp) ||</span><br><span class="line">         <span class="comment">// 5 构造 Pair 然后 cas</span></span><br><span class="line">         casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，最后的 return 的逻辑很复杂，我们可以看到多了版本号的校验。</p><p>回到 <strong>TOP 2</strong> 可以明白多加一个维度来保存版本更新信息即可解决。</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AtomicStampedReference </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AtomicInteger 源码分析</title>
      <link href="/2019/05-AtomicInteger/"/>
      <url>/2019/05-AtomicInteger/</url>
      
        <content type="html"><![CDATA[<h2 id="TOP-带着问题看源码"><a href="#TOP-带着问题看源码" class="headerlink" title="TOP 带着问题看源码"></a>TOP 带着问题看源码</h2><ol><li>AtomicInteger 是怎么做到线程安全的</li><li>AtomicInteger 是怎么实现自增的</li></ol><span id="more"></span><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p>AtomicInteger 扩展了 Number，适用于基于数字的处理，并提供了如原子递增等，适合一些计数场景</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure><p>可以看到 value 是采用 volatile 修饰的，并通过 Unsafe 类获取 value 的偏移量，方便后续使用 CAS 操作</p><h2 id="2-自增-amp-自减"><a href="#2-自增-amp-自减" class="headerlink" title="2. 自增 &amp; 自减"></a>2. 自增 &amp; 自减</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 &amp; 自增</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自增 &amp; 获取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取 &amp; 自减</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自减 &amp; 获取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">decrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, -<span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AtomicInteger 提供了自增/自减的两个场景方法，一个返回旧值，一个返回新增/自减后的。</p><p>实际都是通过Unsafe 的 getAndAddInt 方法来实现的，可以看到实际上 getAndAddInt 就是一个 cas + 自旋操作来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到 <strong>TOP 问题1 2</strong> 可以看到实际是采用 CAS + 自旋来实现线程安全的自增</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AtomicInteger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unsafe 源码分析</title>
      <link href="/2019/04-Unsafe/"/>
      <url>/2019/04-Unsafe/</url>
      
        <content type="html"><![CDATA[<h2 id="TOP-带着问题看源码"><a href="#TOP-带着问题看源码" class="headerlink" title="TOP 带着问题看源码"></a>TOP 带着问题看源码</h2><ol><li>如何获取 Unsafe 实例</li><li>如何利用 Unsafe API 绕开 JVM的控制</li><li>CAS 到底是什么</li><li>Unsafe 中的线程调度是怎么回事</li></ol><span id="more"></span><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p>Unsafe 是用于在实质上扩展 Java 语言表达能力、便于在 Java 代码里实现原本要在 C 层实现的核心库功能用的。这些功能包括裸内存的申请、释放、访问，低层硬件的 atomic/volatile 支持，创建未初始化对象等。但由于 Unsafe 类使 Java 语言拥有不应该暴露的骚操作，增加了程序出问题的风险。</p><h3 id="1-1-获取-Unsafe-实例"><a href="#1-1-获取-Unsafe-实例" class="headerlink" title="1.1 获取 Unsafe 实例"></a>1.1 获取 Unsafe 实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Unsafe unsafe;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class c = UnsafeTest.class.getClassLoader().loadClass(<span class="string">&quot;sun.misc.Unsafe&quot;</span>);</span><br><span class="line">    Field f = c.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">    f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    unsafe = (Unsafe)f.get(c);</span><br><span class="line"></span><br><span class="line">    unsafe.xx();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到 <strong>TOP 1</strong> 可以明白，通过反射获取 unsafe 实例。</p><h2 id="2-功能介绍"><a href="#2-功能介绍" class="headerlink" title="2. 功能介绍"></a>2. 功能介绍</h2><p><a href="http://qiniu.itliusir.com/unsafe01.png"><img src="http://qiniu.itliusir.com/unsafe01.png" alt="img"></a></p><h2 id="3-数组相关"><a href="#3-数组相关" class="headerlink" title="3. 数组相关"></a>3. 数组相关</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回数组中第一个元素的偏移地址</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">arrayBaseOffset</span><span class="params">(Class&lt;?&gt; var1)</span></span>;</span><br><span class="line"><span class="comment">// 返回数组中一个元素占用的大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">arrayIndexScale</span><span class="params">(Class&lt;?&gt; var1)</span></span>;</span><br></pre></td></tr></table></figure><p>通过定位数组第一个元素的偏移地址和每个元素占用的大小。</p><p>例如第一个元素偏移地址是16，存的是 int 类型，则可以通过要查询的 index * 4 + 16 来获取到对应的值。</p><p>我们可以在 AtomicIntegerArray 中看到这些操作，不过作者巧妙的通过位运算来计算index对应的偏移量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. first index 偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> base = unsafe.arrayBaseOffset(<span class="keyword">int</span>[].class);</span><br><span class="line"><span class="comment">// 2. scale = 4;</span></span><br><span class="line"><span class="keyword">int</span> scale = unsafe.arrayIndexScale(<span class="keyword">int</span>[].class);</span><br><span class="line"><span class="comment">// 3. 计算 scale 二进制后面有几个0，如scale = 4(0100)，shift = 2</span></span><br><span class="line">shift = <span class="number">31</span> - Integer.numberOfLeadingZeros(scale);</span><br><span class="line"><span class="comment">// 4. 根据index对scale进行乘法运算获取偏移量 offset，如index = 1，offset = 4(1 &lt;&lt; 2) + 16 = 20</span></span><br><span class="line">offset = index &lt;&lt; shift + base;</span><br><span class="line"><span class="comment">// 5. 通过 offset 原子的获取对应的值</span></span><br><span class="line">unsafe.getIntVolatile(array, offset);</span><br></pre></td></tr></table></figure><h2 id="4-内存屏障"><a href="#4-内存屏障" class="headerlink" title="4. 内存屏障"></a>4. 内存屏障</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内存屏障，禁止 load 操作重排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">loadFence</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 内存屏障，禁止 store 操作重排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">storeFence</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 内存屏障，禁止 load、store 操作重排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">fullFence</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>内存屏障主要是避免 CPU 或者 编译器对代码重排序。</p><p>如并发包中 StampedLock 解决因代码重排序校验不准确，采用loadFence()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line">    U.loadFence();</span><br><span class="line">    <span class="keyword">return</span> (stamp &amp; SBITS) == (state &amp; SBITS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-系统相关"><a href="#5-系统相关" class="headerlink" title="5. 系统相关"></a>5. 系统相关</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取系统指针的大小, 64 位是8</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">addressSize</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取内存页大小，2的幂次方，我本机测试是4096</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">pageSize</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>可以根据内存页大小计算分配页数</p><h2 id="6-线程调度"><a href="#6-线程调度" class="headerlink" title="6. 线程调度"></a>6. 线程调度</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取消阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"><span class="comment">// 阻塞直到超时或中断等条件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> var1, <span class="keyword">long</span> var2)</span></span>;</span><br><span class="line"><span class="comment">// 弃用，获取对象锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">monitorEnter</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"><span class="comment">// 弃用，释放对象锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">monitorExit</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"><span class="comment">// 弃用，尝试获取对象锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">tryMonitorEnter</span><span class="params">(Object var1)</span></span>;</span><br></pre></td></tr></table></figure><p>大名鼎鼎的 AQS 就是通过 park、unpark 来对线程阻塞和唤醒的</p><p>回到 <strong>TOP 4</strong> 可以明白其实就是 park unpark</p><h2 id="7-内存操作"><a href="#7-内存操作" class="headerlink" title="7. 内存操作"></a>7. 内存操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内存分配，相当于c++的os::malloc</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">allocateMemory</span><span class="params">(<span class="keyword">long</span> var1)</span></span>;</span><br><span class="line"><span class="comment">// 扩容内存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">reallocateMemory</span><span class="params">(<span class="keyword">long</span> var1, <span class="keyword">long</span> var3)</span></span>;</span><br><span class="line"><span class="comment">// 给定的内存块中设置值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">setMemory</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4, <span class="keyword">byte</span> var6)</span></span>;</span><br><span class="line"><span class="comment">// 内存拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">copyMemory</span><span class="params">(Object var1, <span class="keyword">long</span> var2, Object var4, <span class="keyword">long</span> var5, <span class="keyword">long</span> var7)</span></span>;</span><br><span class="line"><span class="comment">// 释放内存，相当于c++的os::free</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">freeMemory</span><span class="params">(<span class="keyword">long</span> var1)</span></span>;</span><br><span class="line"><span class="comment">// 获取给定地址的XX类型的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">byte</span> <span class="title">getXx</span><span class="params">(<span class="keyword">long</span> var1)</span></span>;</span><br><span class="line"><span class="comment">// 为给定地址设置XX类型的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putXx</span><span class="params">(<span class="keyword">long</span> var1, xx var3)</span></span>;</span><br></pre></td></tr></table></figure><p>以上的内存操作针对的都是堆外内存操作，与我们平时自己创建的对象都在堆内不同，堆外不会受到 JVM 内存管理，合理使用可以减少原本堆内内存使 GC 时间减少。</p><p><code>java.nio.DirectByteBuffer</code> 中利用了堆外内存减少堆内堆外的copy</p><p>回到 <strong>TOP 2</strong> 可以明白使用堆外内存操作可以绕开 JVM 控制</p><h2 id="8-CAS-Compare-And-Swap-比较和替换"><a href="#8-CAS-Compare-And-Swap-比较和替换" class="headerlink" title="8. CAS(Compare And Swap, 比较和替换)"></a>8. CAS(Compare And Swap, 比较和替换)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 根据第二个参数”偏移量”去拿偏移量这么多的属性的值和第三个参数对比，如果相同则将该属性值替换为第四个参数。该偏移量是指某个字段相对Java对象的起始位置的偏移量，可以通过unsafe.objectFieldOffset(param)去获取对应属性的偏移量。</span><br><span class="line">public final native boolean compareAndSwapXx(Object var1, long var2, Xx var4, Xx var5);</span><br></pre></td></tr></table></figure><p>CAS 是一条 CPU 的原子指令(cmpxchg)，如果是多核处理器会加上 LOCK 前缀</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> jint     <span class="title">Atomic::cmpxchg</span>    <span class="params">(jint     exchange_value, <span class="keyword">volatile</span> jint*     dest, jint     compare_value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mp = os::<span class="built_in">is_MP</span>();</span><br><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(LOCK_IF_MP(%<span class="number">4</span>) <span class="string">&quot;cmpxchgl %1,(%3)&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    : <span class="string">&quot;=a&quot;</span> (exchange_value)</span></span></span><br><span class="line"><span class="params"><span class="function">                    : <span class="string">&quot;r&quot;</span> (exchange_value), <span class="string">&quot;a&quot;</span> (compare_value), <span class="string">&quot;r&quot;</span> (dest), <span class="string">&quot;r&quot;</span> (mp)</span></span></span><br><span class="line"><span class="params"><span class="function">                    : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> exchange_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CAS 在并发包中被广泛应用，回到 <strong>TOP 3</strong> 可以明白 CAS 是一条 CPU 的原子指令。</p><h2 id="9-Class-相关"><a href="#9-Class-相关" class="headerlink" title="9. Class 相关"></a>9. Class 相关</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取静态字段的内存地址偏移量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">staticFieldOffset</span><span class="params">(Field var1)</span></span>;</span><br><span class="line"><span class="comment">// 获取一个静态类中给定字段的对象指针</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title">staticFieldBase</span><span class="params">(Field var1)</span></span>;</span><br><span class="line"><span class="comment">// 判断是否需要初始化一个类，因为有可能类还没初始化却去获取静态属性</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">shouldBeInitialized</span><span class="params">(Class&lt;?&gt; var1)</span></span>;</span><br><span class="line"><span class="comment">// 检测类是否已经初始化 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">ensureClassInitialized</span><span class="params">(Class&lt;?&gt; var1)</span></span>;</span><br><span class="line"><span class="comment">// 定义一个类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Class&lt;?&gt; defineClass(String var1, <span class="keyword">byte</span>[] var2, <span class="keyword">int</span> var3, <span class="keyword">int</span> var4, ClassLoader var5, ProtectionDomain var6);</span><br><span class="line"><span class="comment">// 定义一个匿名类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Class&lt;?&gt; defineAnonymousClass(Class&lt;?&gt; var1, <span class="keyword">byte</span>[] var2, Object[] var3);</span><br></pre></td></tr></table></figure><h2 id="10-对象操作"><a href="#10-对象操作" class="headerlink" title="10. 对象操作"></a>10. 对象操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回对象某个属性相对对象内存地址的偏移量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">objectFieldOffset</span><span class="params">(Field var1)</span></span>;</span><br><span class="line"><span class="comment">// 从对象的指定偏移量处获取变量的引用，使用volatile的加载语义</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title">getObjectVolatile</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</span><br><span class="line"><span class="comment">// 存储变量的引用到对象的指定的偏移量处，使用volatile的存储语义</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putObjectVolatile</span><span class="params">(Object o, <span class="keyword">long</span> offset, Object x)</span></span>;</span><br><span class="line"><span class="comment">// 有序、延迟版本的putObjectVolatile方法，不保证值的改变被其他线程立即看到。只有在field被volatile修饰符修饰时有效</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putOrderedObject</span><span class="params">(Object o, <span class="keyword">long</span> offset, Object x)</span></span>;</span><br><span class="line"><span class="comment">// 绕过构造方法、初始化代码来创建对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title">allocateInstance</span><span class="params">(Class&lt;?&gt; cls)</span> <span class="keyword">throws</span> InstantiationException</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unsafe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM Garbage Collection</title>
      <link href="/2019/JVM-Garbage-Collection/"/>
      <url>/2019/JVM-Garbage-Collection/</url>
      
        <content type="html"><![CDATA[<p>摘要: gc</p><span id="more"></span><h1 id="JVM-垃圾回收"><a href="#JVM-垃圾回收" class="headerlink" title="JVM 垃圾回收"></a>JVM 垃圾回收</h1><h2 id="Jvm-内存结构"><a href="#Jvm-内存结构" class="headerlink" title="Jvm 内存结构"></a>Jvm 内存结构</h2><h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><p>程序运行期间会使用到的运行时数据区</p><h4 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h4><p>每一个虚拟机线程都有自己的PC寄存器，保存Java虚拟机正在执行的字节码指令的地址，如果该方法是 native 的，那 PC 寄存器的值是 undefined</p><h4 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h4><p>线程私有的，栈与线程同时创建，生命周期和线程是一样的。虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个<strong>栈帧</strong> ，用于<strong>存储局部变量表，操作数栈，动态链接，方法出口等信息</strong>。每个方法从开始调用到执行完成都对应着一个栈帧在虚拟机栈中入栈到出栈的过程</p><h5 id="栈帧-Frame"><a href="#栈帧-Frame" class="headerlink" title="栈帧(Frame)"></a>栈帧(Frame)</h5><p>用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接、方法返回值和异常分派</p><p>栈帧随着方法调用而创建，随着方法结束而销毁，无论方法是正常完成还是异常完成</p><p>栈帧的存储空间分配在Java虚拟机栈</p><p>每一个栈帧都有自己的局部变量表、操作数栈和指向当前方法所属的类的运行时常量池的引用</p><p>栈帧容量的大小仅仅取决于Java虚拟机的实现和方法调用时可被分配的内存</p><p>一条线程只有正在执行某个方法的栈帧是活动的，叫做当前栈帧，对应的方法叫当前方法，定义这个方法的类叫当前类。对局部变量表和操作数栈的各种操作，通常指的是当前栈帧进行的操作</p><blockquote><p>栈帧是线程本地私有的数据，不可能在一个栈帧之中引用另外一条线程的栈帧</p><p>如果当前方法调用了其他方法，或者当前方法执行结束，那这个方法的栈帧就不再是当前栈帧了。当一个新的方法被调用，则会新建一个栈帧并成为当前栈帧，当方法返回时会将结果（当前新的栈帧）返回给上一个栈帧，当前栈帧丢弃，上一个栈帧重新成为当前栈帧。</p></blockquote><ul><li><strong>局部变量表</strong></li></ul><p>长度由编译期决定，存储于类和接口的二进制表示之中，既通过方法的Code属性保存及提供给栈帧使用</p><ul><li>一个局部变量可以保存类型boolean、byte、char、short、float、reference和returnAddress的数据</li><li>两个局部变量可以保存类型为long和double的数据</li></ul><p>当方法被调用时候，参数将会传递至从0开始的连续的局部变量表里。如果是实例方法被调用则第0个局部变量一定是this</p><blockquote><p>局部变量使用索引来进行定位访问，0-max</p><p>long和double这种需要两个局部变量的类型，索引取最小的那个局部变量。</p></blockquote><ul><li><strong>操作数栈</strong></li></ul><p>同局部变量表，长度由编译期决定，存储于类和接口的二进制表示之中，既通过方法的Code属性保存及提供给栈帧使用</p><p>操作数栈所属的栈帧在刚刚被创建的时候，操作数栈是空的。</p><p>Java虚拟机提供一些字节码指令来从局部变量表或者对象实例的字段中复制常量或变量值到操作数栈中，也提供了一些指令用于从操作数栈取走数据、操作数据和把操作结果重新入栈。在方法调用的时候，操作数栈也用来准备调用方法的参数以及接收方法返回结果，例子参考<a href="http://itliusir.com/2018/JVM-Instruction-Execution-Flow/">初识jvm指令执行流程</a></p><blockquote><p>一个long或者double类型的数据会占用两个单位的栈深度，其他数据类型则会占用一个单位深度</p></blockquote><ul><li><strong>动态链接</strong></li></ul><p>在Class文件里面，描述一个方法调用了其他方法，或者访问其成员变量是通过符号引用来表示的，动态链接的作用就是将这些符号引用所表示的方法转换为实际方法的直接引用</p><p>类加载的过程中将要解析掉尚未被解析的符号引用，并且将变量访问转化为访问这些变量的存储结构所在的运行时内存位置的正确偏移量</p><blockquote><p>由于动态链接的存在，通过晚期绑定（Late Binding）使用的其他类的方法和变量在发生变化时，将不会对调用它们的方法构成影响</p></blockquote><h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>可供各条线程共享的运行时内存区域，也是供所有类实例和数组对象分配内存的区域</p><p>Java堆在虚拟机启动的时候就被创建，它存储了被自动内存管理系统所管理的各种对象，这些受管理的对象无需，也无法显式地被销毁</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>可供各条线程共享的运行时内存区域</p><p>方法区在虚拟机启动的时候被创建，存储了每一个类的结构信息，例如<strong>运行时常量池</strong>(存放编译器生成的各种字面量和符号引用)、字段和方法数据、构造函数和普通方法的字节码内容、还包括一些在类、实例、接口初始化时用到的特殊方法</p><blockquote><p>虽然方法区是堆的逻辑组成部分，但是简单的虚拟机实现可以选择在这个区域不实现垃圾收集，在 JDK1.7 中是 Perm Space , 在 JDK1.8 中是Meta Space</p></blockquote><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>每一个类或接口的常量池的运行时表示形式，它包括了若干种不同的常量：从编译期可知的数值字面量到必须运行期解析后才能获得的方法或字段引用</p><blockquote><p>每一个运行时常量池都分配在Java虚拟机的方法区之中，在类和接口被加载到虚拟机后，对应的运行时常量池就被创建出来</p></blockquote><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>如果支持本地方法栈，则会在线程创建的时候按线程分配</p><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="JVM-中内存结构图"><a href="#JVM-中内存结构图" class="headerlink" title="JVM 中内存结构图"></a>JVM 中内存结构图</h3><p><a href="http://qiniu.itliusir.com/JVM_1.png"><img src="http://qiniu.itliusir.com/JVM_1.png" alt="img"></a></p><p><strong>堆区</strong> 又被划分为 新生代(Young) 和 老年代(Old)</p><p><strong>Young</strong> 新生代，又被划分为 <strong>Eden区</strong> 和 <strong>S区</strong> ，默认情况下JVM采取的是一种动态分配的策略(<code>-XX:+UsePSAdaptiveSurvivorSizePolicy</code>)，根据对象生成的速率，以及S区使用情况动态调整Eden区和S区的比例，也可以使用参数固定此比例(<code>-XX:SurvivorRatio</code>) ,比例越低浪费的堆空间就越高(因为S区有一个区域一直为空，S区大了就会浪费一部分空间)，至于为什么会有S0与S1,可以参考下面的可达性分析清除方式，这里不过多解释</p><p><strong>Metaspace</strong> 存放 Class 、Package 、Method 、Field 、字节码 、常量池 、符号引用等等</p><p><strong>CCS</strong> 压缩类空间，只有启用压缩类短指针的时候才会存在。出现的原因：在堆里面分配每一个对象都会有一个指向自己 Class 的指针，64位的虚拟机每个指针长度是64位的，考虑性能原因我们可以把这个指针使用短指针来引用，使用32位的指针，如果使用短指针，其所引用的Class文件则会存放到CCS区，在 JVM 中是默认开启的 <code>UseCompressedClassPointers</code> ，默认1G大小，可以使用 <code>CompressedClassSpaceSize</code> 设置大小</p><p><strong>CodeCache</strong> 存放JIT即时编译代码 、Native代码，可以使用 <code>-XX:InitialCodeCacheSize</code> <code>-XX:ReservedCodeCacheSize</code> 设置初始和最大大小</p><blockquote><p>需要注意的是在我们调用 new 指令时，它会在Eden区划出一块作为存储对象的内存，由于堆空间是共享的(参考上文中 Jvm的内存结构)，所以在划空间时候是需要进行同步的，JVM的解决办法是为每一个线程分配一段连续的内存作为线程私有的TLAB(Thread Local Allocation Buffer) ，并且只允许该线程拥有该部分内存，该技术对应参数(<code>-XX:+UseTLAB</code> ，默认开启)。</p><p>同样在线程申请内存时候需要加锁，线程主要维护两个指针，一个指向TLAB空余内存的起始Adress，一个指向TLAB末尾。而new的时候便可以通过 <code>bump the pointer</code> 来实现，即将第一个指向起始位置的指针加上请求的字节数，当加上字节数后的值大于指向末尾的指针的值，则当前线程重新申请新的TLAB。当Eden区耗尽则会触发minor GC</p></blockquote><h3 id="分析垃圾的方法"><a href="#分析垃圾的方法" class="headerlink" title="分析垃圾的方法"></a>分析垃圾的方法</h3><blockquote><p>无法被程序引用的在堆上已分配的内存空间称为垃圾</p></blockquote><h4 id="古老的引用计数法"><a href="#古老的引用计数法" class="headerlink" title="古老的引用计数法"></a>古老的引用计数法</h4><p>引用计数方式会为每个已分配的内存单元设置计数器，当计数器减少为0的时候意味着再无法被引用，将立即执行释放内存的动作。</p><blockquote><p><strong>引用计数</strong> 使用弱引用来解决循环引用带来的问题，弱引用不会影响计数器状态的引用，即使循环引用也不会阻止其被清除</p></blockquote><ul><li><strong>问题</strong></li></ul><ol><li>如果分配的内存单元原本就很小，这个时候计数器所占的内存占比就比较大。而垃圾回收方式只需要设置一个标记位置而已</li><li>维护计数器的状态会占据整个程序执行时间中明显的部分，相当于将垃圾回收的消耗均摊到程序运行的整个过程</li><li>计数器代码分布在用户代码各处不易维护</li><li>当存在循环依赖时候内存释放比较复杂</li></ol><h4 id="主流的可达性分析法"><a href="#主流的可达性分析法" class="headerlink" title="主流的可达性分析法"></a>主流的可达性分析法</h4><p>基本思想是 <strong>标记-清除(mark-and-sweep)</strong> ，每隔一段时间或堆空间不足时候才进行一次垃圾回收，每次回收先将所有堆上分配的内存单元标记为 <strong>“不可到达”</strong> ，然后根据 <strong>GC Root</strong> 开始扫描，把可达到的内存单元标记为 <strong>“可以到达”</strong> 。最后回收标记为 <strong>“不可到达”</strong> 的内存单元。</p><p><strong>GC Root:</strong> 类加载器、已启动且未停止的Thread、虚拟机栈的本地变量表、static成员、常量引用、本地方法栈的变量</p><blockquote><p><strong>标记-清除</strong> 并不会受循环引用的影响，如A与B循环依赖 但是当AB都 <strong>不可达</strong> 时则会将AB都进行回收。标记-清除垃圾回收同样也提供了弱引用，原因是为了解决可能是人为造成的内存泄露(无意长时间持有了对已经不需要的对象的引用，如private static修饰的类变量)</p></blockquote><ul><li><strong>问题</strong></li></ul><ol><li>在执行垃圾回收时候一般要把整个程序停下来并执行 <strong>标记-清除</strong> 的过程(不考虑并行回收) ，如果是实时系统一般无法承受这种因为标记过程过长而导致的时间消耗，其宁可选择引用计数均摊到整个运行过程中，分代式的垃圾回收一定程度上缓解了这个问题(例如java 虚拟机新生代与老年代的回收) ，但并没有根除消耗高峰的问题</li><li>最需要垃圾回收时(堆内存已经快分配尽了，但已分配也就是需要标记的有很多)，它运行效果却最差(需要大量时间来标记，实际释放的却未必很多)</li><li><strong>标记-清除</strong> 有两种实现思路，<strong>保守式</strong> 与 <strong>准确式</strong> ，<strong>保守式</strong> 不需要知道内存的具体布局形式，会把所有看上去像指针的数值看作指针并纳入标记计算中； <strong>准确式</strong> 则要求运行时系统清楚的了解内存的布局，能够分辨指针并只标记指针。前者不够准确，后者则需要消耗更多的内存和时间</li></ol><ul><li><strong>清除的方式</strong></li></ul><ol><li><p><strong>直接清除</strong> 把死亡对象所占据的内存标记为空闲内存，新建对象需要内存则从空闲内存中划分</p><blockquote><p><strong>缺点：</strong> 非连续内存空间分配效率低，并且会造成内存碎片，体现在现实中就是内存不够分配提前GC</p></blockquote></li><li><p><strong>清除完进行压缩</strong> 在清除完将存活对象聚集到内存区域的起始位置，保证内存空间是连续的</p><blockquote><p><strong>缺点：</strong> 压缩算法的开销</p></blockquote></li><li><p><strong>清除完进行复制再进行清理</strong> 首先把内存区域分为两部分，用指针from来维护之前需要分配内存的内存区域，在清除完将存活对象复制到to指针维护的内 存区域中，然后清理掉from区，最后重新交换from指针与to指针的内容</p><blockquote><p><strong>缺点：</strong> 内存空间使用效率极低，只有50%</p></blockquote><p><a href="http://qiniu.itliusir.com/JVM_2.png"><img src="http://qiniu.itliusir.com/JVM_2.png" alt="img"></a></p></li></ol><p>现代垃圾回收器会综合上述几种清除方式，根据不同场景选出最合适的方式，例如JVM中会频繁进行Eden区回收，此时则采用复制方式，这样的原因是理想情况下清除垃圾后Eden区的对象基本都死亡了，需要复制的数据很少，使用复制算法效果很好。</p><h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><p>如果老年代中的对象引用新生代的对象，在使用可达性分析标记存活对象的时候我们就需要扫描老年代。为了不做耗时较久的全堆扫描，HotSpot 的解决方案是 <code>Card Table</code> ，该技术将堆划分为一个个大小为512字节的 <code>Card</code> ，然后维护了一个 <code>Table</code> ，用来存储每张 <code>Card</code> 的一个标识位，这个标识位代表是否可能存在指向新生代对象的引用，若存在则认为这是一个脏的 <code>Card</code> 。则在新生代 Minor GC 时则不需要扫描整个老年代，而是寻找脏的 <code>Card</code> 将其中的对象加入到 Minor GC 的 GC Root 中，完成扫描则将所有标识位清空</p><h3 id="对象分配"><a href="#对象分配" class="headerlink" title="对象分配"></a>对象分配</h3><ol><li>对象优先在Eden区分配</li><li>大对象直接进入老年代，可以通过参数( <code>-XX:PretenureSizeThreshold</code> )设置大对象的临界值，默认0，表示没有最大值</li><li>每次S区进行复制算法的时候都会被记录下来，如果一个对象复制次数为 15 (可通过参数 <code>-XX:MaxTenuringThreshold</code> 设置 )，则会进入老年代</li><li>在第3条的基础上会和 S 区存活对象在50%比例下(可通过参数 <code>-XX:TargetSurvivorRatio</code> 设置比例)的平均复制次数取一个最小值，达到这个值则会进入老年代</li></ol><blockquote><p>可通过参数 (-XX:+PrintTenuringDistribution) 打印 Minor GC 后存活对象的年龄分布情况</p></blockquote><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="串行收集器Serial"><a href="#串行收集器Serial" class="headerlink" title="串行收集器Serial"></a>串行收集器Serial</h3><h4 id="开启参数"><a href="#开启参数" class="headerlink" title="开启参数"></a>开启参数</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialGC -XX:+UseSerialOldGC</span><br></pre></td></tr></table></figure><h3 id="并行收集器Parallel"><a href="#并行收集器Parallel" class="headerlink" title="并行收集器Parallel"></a>并行收集器Parallel</h3><p>多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</p><h4 id="开启参数-1"><a href="#开启参数-1" class="headerlink" title="开启参数"></a>开启参数</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC -XX:+UseParallelOldGC</span><br><span class="line">-XX:ParallelGCThreads=&lt;N&gt; # 多少GC线程 默认CPU&gt;8 N=5/8 CPU&lt;8 N=CPU</span><br></pre></td></tr></table></figure><h4 id="自适应调优"><a href="#自适应调优" class="headerlink" title="自适应调优"></a>自适应调优</h4><ul><li><strong>-XX:MaxGCPauseMillis=</strong> 最大停顿时间</li><li><strong>-XX:GCTimeRatio=</strong> 吞吐量(花在应用时间和花在垃圾收集的时间的占比) 默认99，垃圾收集时间=1/1+N</li><li><strong>-Xmx=</strong> 最大堆的大小</li></ul><blockquote><p>JVM会自动调整堆分区的大小来满足以上三个参数条件，当不够了就会变大，变化的比例同样可以通过JVM参数设置：</p><ul><li><code>-XX:YoungGenerationSizeIncrement=&lt;Y&gt;</code> 年轻代适应下大小百分比，默认值20</li><li><code>-XX:TenuredGenerationSizeIncrement=&lt;T&gt;</code> 老年代适应下大小百分比，默认值20</li><li><code>-XX:AdaptiveSizeDecrementScaleFactor=&lt;D&gt;</code> 变小的百分比，默认4</li></ul></blockquote><h3 id="并发收集器Concurrent"><a href="#并发收集器Concurrent" class="headerlink" title="并发收集器Concurrent"></a>并发收集器Concurrent</h3><p>用户线程与垃圾收集线程同时执行(但不一定是并行的，可能会交替执行)，垃圾收集线程在执行的时候不会停顿用户程序的运行。适合对响应时间有要求的场景。本文只是简单介绍，之后会单独出对应文章</p><h4 id="开启参数-2"><a href="#开启参数-2" class="headerlink" title="开启参数"></a>开启参数</h4><ul><li><p><strong>CMS</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC -XX:+UseParNewGC</span><br></pre></td></tr></table></figure></li><li><p><strong>G1</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseG1GC</span><br></pre></td></tr></table></figure></li></ul><h4 id="CMS-Concurrent-Mark-Sweep-收集器"><a href="#CMS-Concurrent-Mark-Sweep-收集器" class="headerlink" title="CMS (Concurrent Mark-Sweep)收集器"></a>CMS (Concurrent Mark-Sweep)收集器</h4><p>核心是 <strong>标记-清除</strong> ，优点是停顿时间最短，缺点是内存碎片，适用于Web</p><ul><li><strong>过程</strong><ul><li><strong>初始标记(STW)</strong> 仅标记 GC Root 直接引用的对象</li><li><strong>并发标记</strong> 从 GC Root 出发，标记可达对象</li><li><strong>重新标记</strong> 标记 <strong>并发标记</strong> 过程中，变更的对象</li><li><strong>并发清除</strong> 清除无用对象</li></ul></li><li><strong>降级 Concurrent Mode Failure</strong><ul><li>并发标记、清理过程、work thread 在运行，申请老年代可能失败</li><li>失败后会 <strong>降级</strong> (临时启动 Serial Old 收集器)</li></ul></li></ul><blockquote><p><strong>缺点：</strong></p><ol><li><strong>CPU敏感</strong> 例如在微服务体系中的某个小服务，配置是2h，启动了一个垃圾回收线程，那么就只有一个 CPU 可以响应用户的请求</li><li><strong>浮动垃圾</strong> 用户线程和垃圾回收线程同时工作，在GC时候，用户线程还是在做内存分配的</li><li><strong>空间碎片</strong></li></ol></blockquote><ul><li><p><strong>相关参数</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-XX:ConcGCThreads # 并发的GC线程数 default: 0(jdk8)</span><br><span class="line">-XX:UseCMSCompactAtFullCollection # FullGC之后做压缩 default: true</span><br><span class="line">-XX:CMSFullGCsBeforeCompaction # 多少次FullGC之后压缩一次 default: 0</span><br><span class="line">-XX:CMSInitiatingOccupancyFraction # Old区占用百分比后触发FullGC 该参数必须配合UseCMSInitiatingOccupancyOnly使用才有效 default: -1,负值表示使用CMSTriggerRatio-&gt;default: 80</span><br><span class="line">-XX:+UseCMSInitiatingOccupancyOnly # 是否开启CMSInitiatingOccupancyFraction占用率 default: false</span><br><span class="line">-XX:+CMSScavengeBeforeRemark # FullGC之前先做YGC 减少gc roots扫描的对象数，从而提高remark的效率 default: false</span><br><span class="line">-XX:+CMSClassUnloadingEnabled # 是否开启类卸载 如果开启 在full gc是会顺带扫描回收metaSpace/PermGen default: true(jdk8)</span><br></pre></td></tr></table></figure></li></ul><h4 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h4><p><strong>Region</strong> G1中的块的概念，</p><p><strong>SATB Snapshot At The Beginning</strong> 通过Root Tracing 得到的，GC开始时候存活对象的快照</p><p><strong>RSet</strong> 记录了其他 Region 中的对象引用本 Region 中对象的关系，属于 points-into 结构(谁引用了我的对象)</p><ul><li><p><strong>Young GC</strong></p><p>与其他年轻代收集方式差不多，新对象进入 Eden 区，存活对象拷贝到S区，存活时间达到年龄阈值时，对象晋升到Old区</p></li><li><p><strong>Mixed GC</strong></p><p>不是 Full GC，回收所有的 Young 和部分 Old</p><blockquote><p><strong>Global Concurrent Marking</strong></p><ol><li><strong>Initial Marking Phase(STW)：</strong> 标记 GC Root</li><li><strong>Root region Scanning Phase：</strong> 标记存活 Region</li><li><strong>Concurrent Marking Phase：</strong> 标记存活的对象</li><li><strong>Remark Phase(STW)：</strong> 重新标记</li><li><strong>Cleanup Phase：</strong> 部分STW</li></ol></blockquote><p><strong>Mixed GC时机</strong></p><ul><li><code>InitiatingHeapOccupancyPercent</code> 堆占有率达到这个数值则触发 <strong>Global Concurrent Marking</strong> ，默认 45</li><li><code>G1HeapWastePercent</code> 在 <strong>Global Concurrent Marking</strong> 结束之后，可以知道 Region 有多少空间要被回收，在每次YGC之后和再次发生 <strong>Mixed GC</strong> 之前，会检查垃圾占比是否达到此参数，达到了下次才会发生 <strong>Mixed GC</strong> ，默认 5(jdk8)</li><li><code>G1MixedGCLiveThresholdPercent</code> Old 区的 region 被回收时候的存活对象占比需要达到多少，默认值 85</li><li><code>G1MixedGCCountTarget</code> 一次 <strong>Global Concurrent Marking</strong> 之后，最多执行 <strong>Mixed GC</strong> 的次数，默认值 8</li><li><code>G1OldCSetRegionThresholdPercent</code> 一次 <strong>Mixed GC</strong> 最多能回收Old区的 Region ，默认值 10</li></ul></li><li><p><strong>常用参数</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-XX:G1HeapRegionSize=n # region的大小,1-32M,2048个 default: 0</span><br><span class="line">-XX:MaxGCPauseMillis=200 # 最大停顿时间</span><br><span class="line">-XX:G1NewSizePercent # Young区的最小占比 default: 5</span><br><span class="line">-XX:G1MaxNewSizePercent # Young区的最大占比 default: 60</span><br><span class="line">-XX:G1ReservePercent # 保留空间防止to space溢出 default: 10</span><br><span class="line">-XX:ParallelGCThreads=n # SWT线程数 default: 2(jdk linux)</span><br><span class="line">-XX:ConcGCThreads=n # 并发线程数=1/4*并行 default: 0</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>G1中避免使用-Xmn、-XX:NewRatio等显式设置Young区的大小，会覆盖停顿时间目标</p></blockquote><h3 id="垃圾收集器搭配"><a href="#垃圾收集器搭配" class="headerlink" title="垃圾收集器搭配"></a>垃圾收集器搭配</h3><p><a href="http://qiniu.itliusir.com/JVM_3.png"><img src="http://qiniu.itliusir.com/JVM_3.png" alt="img"></a></p><p>实线的代表可以搭配使用的，例如 Old 区使用 CMS ，Young 区则可以使用 Serial、ParNew</p><p>虚线的代表 CMS 可以退化为 SerialOld(可以通过压缩减少碎片、内存使用率增长较快则降低触发FullGC 阈值来避免退化)</p><h3 id="选择垃圾收集器"><a href="#选择垃圾收集器" class="headerlink" title="选择垃圾收集器"></a>选择垃圾收集器</h3><ul><li><strong>优先调整堆的大小让服务器自己来选择</strong></li><li><strong>如果内存小于100M，使用串行收集器</strong></li><li><strong>如果是单核，并且没有停顿时间的要求，串行或者JVM自己选</strong></li><li><strong>如果允许停顿时间超过1秒，选择并行或者JVM自己选</strong></li><li><strong>如果响应时间最重要，并且不能超过1秒，使用并发收集器</strong></li></ul><h2 id="可视化GC日志分析工具"><a href="#可视化GC日志分析工具" class="headerlink" title="可视化GC日志分析工具"></a>可视化GC日志分析工具</h2><h3 id="日志打印相关参数"><a href="#日志打印相关参数" class="headerlink" title="日志打印相关参数"></a>日志打印相关参数</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">-XX</span>:+PrintGCDetails <span class="comment"># 打印GC日志详情</span></span><br><span class="line"><span class="literal">-XX</span>:+PrintGCTimeStamps <span class="comment"># 打印时间戳</span></span><br><span class="line"><span class="literal">-XX</span>:+PrintGCDateStamps <span class="comment"># 打印日期戳</span></span><br><span class="line"><span class="literal">-Xloggc</span>:<span class="variable">$</span>&#123;PRO_NAME&#125;/logs/gc.log <span class="comment"># GC日志文件路径</span></span><br><span class="line"><span class="literal">-XX</span>:+PrintHeapAtGC <span class="comment"># 在每次GC的前后打印堆的使用量</span></span><br><span class="line"><span class="literal">-XX</span>:+PrintTenuringDistribution <span class="comment"># 发生GC时候打印Young区 复制年龄信息</span></span><br></pre></td></tr></table></figure><h3 id="日志格式-CMS"><a href="#日志格式-CMS" class="headerlink" title="日志格式(CMS)"></a>日志格式(CMS)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">1. &#123;Heap before GC invocations=40 (full 0):</span><br><span class="line">1.1.  par new generation   total 120192K, used 116952K [0x00000000f0000000, 0x00000000f8000000, 0x00000000f8000000)</span><br><span class="line">1.2.   eden space 109312K, 100% used [0x00000000f0000000, 0x00000000f6ac0000, 0x00000000f6ac0000)</span><br><span class="line">1.3.   from space 10880K,  70% used [0x00000000f6ac0000, 0x00000000f7236058, 0x00000000f7560000)</span><br><span class="line">1.4.   to   space 10880K,   0% used [0x00000000f7560000, 0x00000000f7560000, 0x00000000f8000000)</span><br><span class="line">1.5.  concurrent mark-sweep generation total 131072K, used 103011K [0x00000000f8000000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">1.6.  Metaspace       used 92140K, capacity 94694K, committed 95104K, reserved 1132544K</span><br><span class="line">1.7.   class space    used 10753K, capacity 11309K, committed 11392K, reserved 1048576K</span><br><span class="line">2. 2019-01-24T13:37:49.590+0800: 33.245: [GC (Allocation Failure) 2019-01-24T13:37:49.590+0800: 33.245: [ParNew</span><br><span class="line">Desired survivor size 5570560 bytes, new threshold 1 (max 15)</span><br><span class="line">- age   1:    7451168 bytes,    7451168 total</span><br><span class="line">: 116952K-&gt;8689K(120192K), 0.0155957 secs] 219963K-&gt;115232K(251264K), 0.0156544 secs] [Times: user=0.03 sys=0.00, real=0.02 secs] </span><br><span class="line">3. Heap after GC invocations=41 (full 0):</span><br><span class="line">3.1.  par new generation   total 120192K, used 8689K [0x00000000f0000000, 0x00000000f8000000, 0x00000000f8000000)</span><br><span class="line">3.2.   eden space 109312K,   0% used [0x00000000f0000000, 0x00000000f0000000, 0x00000000f6ac0000)</span><br><span class="line">3.3.   from space 10880K,  79% used [0x00000000f7560000, 0x00000000f7ddc480, 0x00000000f8000000)</span><br><span class="line">3.4.   to   space 10880K,   0% used [0x00000000f6ac0000, 0x00000000f6ac0000, 0x00000000f7560000)</span><br><span class="line">3.5.  concurrent mark-sweep generation total 131072K, used 106543K [0x00000000f8000000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">3.6.  Metaspace       used 92140K, capacity 94694K, committed 95104K, reserved 1132544K</span><br><span class="line">3.7.   class space    used 10753K, capacity 11309K, committed 11392K, reserved 1048576K</span><br><span class="line">&#125;</span><br><span class="line">4. 2019-01-24T13:37:49.606+0800: 33.261: [GC (CMS Initial Mark) [1 CMS-initial-mark: 106543K(131072K)] 117412K(251264K), 0.0029414 secs] [Times: user=0.03 sys=0.00, real=0.00 secs] </span><br><span class="line">4.1. 2019-01-24T13:37:49.609+0800: 33.264: [CMS-concurrent-mark-start]</span><br><span class="line">4.2. 2019-01-24T13:37:49.707+0800: 33.362: [CMS-concurrent-mark: 0.096/0.098 secs] [Times: user=0.19 sys=0.00, real=0.10 secs] </span><br><span class="line">4.3. 2019-01-24T13:37:49.707+0800: 33.362: [CMS-concurrent-preclean-start]</span><br><span class="line">4.4. 2019-01-24T13:37:49.710+0800: 33.365: [CMS-concurrent-preclean: 0.003/0.003 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">4.5. 2019-01-24T13:37:49.710+0800: 33.365: [CMS-concurrent-abortable-preclean-start]</span><br><span class="line"># ... 省略 before after gc detail</span><br><span class="line">4.6. 2019-01-24T13:37:50.004+0800: 33.659: [GC (Allocation Failure) 2019-01-24T13:37:50.004+0800: 33.659: [ParNew</span><br><span class="line">Desired survivor size 5570560 bytes, new threshold 1 (max 15)</span><br><span class="line">- age   1:    5574000 bytes,    5574000 total</span><br><span class="line">: 118001K-&gt;6415K(120192K), 0.0127596 secs] 224544K-&gt;114652K(251264K), 0.0128342 secs] [Times: user=0.02 sys=0.00, real=0.01 secs]</span><br><span class="line">4.7. 2019-01-24T13:37:50.336+0800: 33.991: [CMS-concurrent-abortable-preclean: 0.411/0.626 secs] [Times: user=1.02 sys=0.09, real=0.63 secs] </span><br><span class="line">4.8. 2019-01-24T13:37:50.336+0800: 33.991: [GC (CMS Final Remark) [YG occupancy: 105816 K (120192 K)]2019-01-24T13:37:50.336+0800: 33.991: [Rescan (parallel) , 0.0214420 secs]2019-01-24T13:37:50.357+0800: 34.013: [weak refs processing, 0.0013584 secs]2019-01-24T13:37:50.359+0800: 34.014: [class unloading, 0.0203511 secs]2019-01-24T13:37:50.379+0800: 34.035: [scrub symbol table, 0.0189360 secs]2019-01-24T13:37:50.398+0800: 34.054: [scrub string table, 0.0010303 secs][1 CMS-remark: 108237K(131072K)] 214053K(251264K), 0.0639900 secs] [Times: user=0.08 sys=0.00, real=0.06 secs] </span><br><span class="line">4.9. 2019-01-24T13:37:50.400+0800: 34.055: [CMS-concurrent-sweep-start]</span><br><span class="line"># ...</span><br><span class="line">5.0. 2019-01-24T13:37:50.443+0800: 34.098: [CMS-concurrent-reset-start]</span><br></pre></td></tr></table></figure><h3 id="日志详解"><a href="#日志详解" class="headerlink" title="日志详解"></a>日志详解</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 中括号的内容是内存地址</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. GC前堆的占用情况</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1.1. 年轻代总大小 120192K，已用 116952K (f8000000-f0000000 = 134217728/1024 = 131072-total(120192)=10880)，即年轻代中的s区实际上是有一个大小为10880的空间是浪费的</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1.2. eden区使用情况，使用率100%，大小 109312K(f6ac0000-f0000000=111935488/1024=109312)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1.3. s-from区使用情况，使用率70%，大小 10880K，(f7236058-f6ac0000=7823448/1024 = 7640) /10880=70%</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1.4. s-to区使用情况，使用率0%，大小 10880K</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1.5. 老年代使用情况，大小 131072K，使用 103011K，占比78.6%</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1.6. 元数据空间使用情况(持久代小 94694K，使用 92140K</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1.7. 元数据空间中类占用的空间情况，大小 11309K，使用 10753K</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 新生代回收，从109312K减少至10880K，新分配了20192k 整个内存空间从109312K减少至19172K，总内存空间分配了251264K，耗时0.032s左右，年龄是1；[Times: user=0.05 sys=0.02, real=0.03 secs] 可以看到user+sys(进程实际消耗的CPU时间)&gt;real(调用从开始到结束的实际持续时间)，说明我们是多个cpu执行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. GC后堆的占用情况 invocations=41 指的是已经进行41次gc</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.1. 年轻代总大小 120192K，已用 8689K</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.2. eden区使用情况，使用率0%，大小 109312K</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.3. s-from区使用情况，使用率79%，大小 10880K，(f7ddc480-f7560000=8897664/1024 = 8689) /10880=79.8%</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.4. s-to区使用情况，使用率0%，大小 10880K</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.5. 老年代使用情况，大小 131072K，使用 106543K，占比81.3%</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 由-XX:CMSInitiatingOccupancyFraction参数默认80%可知，old区占比已经大于阈值，将要进行full-gc，此阶段是初始标记阶段，只是标记一下GC Roots能直接关联的对象，是STW的</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4.1&amp;4.2. 并发标记阶段，和用户线程并发执行，主要作用是标记可达的对象</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4.3&amp;4.4. 预清理阶段</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4.5&amp;4.7. 此阶段的目的是使cms gc更加可控一些，作用也是执行一些预清理，以减少Rescan阶段造成应用暂停的时间</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4.6. 先执行一次ParNew GC</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4.8. 重新扫描标记阶段因用户线程继续运作而导致的变动对象，是STW的</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4.9. 并发清理</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5.0. 重置线程参数</span></span><br></pre></td></tr></table></figure><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul><li><a href="https://gceasy.io/">GCeasy</a></li><li><a href="https://github.com/chewiebug/GCViewer">GCViewer</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM Monitor</title>
      <link href="/2019/JVM-Monitor/"/>
      <url>/2019/JVM-Monitor/</url>
      
        <content type="html"><![CDATA[<p>摘要: jvm monitor</p><span id="more"></span><h1 id="JVM-监控"><a href="#JVM-监控" class="headerlink" title="JVM 监控"></a>JVM 监控</h1><h2 id="基于-jstack-监控定位"><a href="#基于-jstack-监控定位" class="headerlink" title="基于 jstack 监控定位"></a>基于 jstack 监控定位</h2><h3 id="查看CPU负载"><a href="#查看CPU负载" class="headerlink" title="查看CPU负载"></a>查看CPU负载</h3><ul><li><p><strong>系统负载/ CPU负载</strong> - 是Linux系统中CPU过度使用率或利用率不足的度量; CPU正在执行或处于等待状态的进程数。</p></li><li><p><strong>负载平均值</strong> - 是在给定的1,5和15分钟时间段内计算的平均系统负载。</p></li><li><p><strong>top 命令</strong> (定位到我们cpu高的进程)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> top</span></span><br><span class="line">top - 16:40:59 up 388 days,  1:04,  1 user,  load average: 0.00, 0.01, 0.05</span><br><span class="line">Tasks:  75 total,   1 running,  72 sleeping,   0 stopped,   2 zombie</span><br><span class="line"><span class="meta">%</span><span class="bash">Cpu(s):  0.7 us,  0.3 sy,  0.0 ni, 99.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span></span><br><span class="line">KiB Mem :  1883492 total,   247312 free,   473204 used,  1162976 buff/cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used.  1188144 avail Mem </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> uptime</span></span><br><span class="line"> 16:42:36 up 388 days,  1:06,  1 user,  load average: 0.00, 0.01, 0.05</span><br></pre></td></tr></table></figure><p>其中 <code>load average</code> 代表的是cpu的平均负载，三个数字分别代表1分钟、5分钟、15分钟内cpu的平均负载。</p><blockquote><p>负荷的大小跟cpu个数以及当前负荷有关系，例如1h 处理器，负载为5 则大概表面有1成的在running 4成的在等待，也就意味着此时可能服务器已经无法处理新的请求了，系统也就凉咯</p></blockquote><p>查看cpu个数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/cpuinfo | grep <span class="string">&quot;cpu cores&quot;</span></span></span><br></pre></td></tr></table></figure></li></ul><h3 id="定位具体线程"><a href="#定位具体线程" class="headerlink" title="定位具体线程"></a>定位具体线程</h3><ul><li><p><strong>jstack 命令</strong></p><p>例如我们由top定位到了某个异常的进程，拿到了pid，为9048</p><p>接下来我们使用 <code>jstack</code> 命令导出 9048 进程中线程栈的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jstack 9048 &gt; 9048.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> top -p 9048 -H <span class="comment"># 拿到所有线程的cpu信息，定位具体线程pid</span></span></span><br><span class="line">9243 root      20   0 2498028  59096   7008 S  91.0  3.1   0:00.00 java           </span><br><span class="line">9244 root      20   0 2498028  59096   7008 S  99.0  3.1   0:00.32 java</span><br><span class="line"><span class="meta">#</span><span class="bash"> 定位到线程pid为 9243 9244的cpu占用高</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">printf</span> <span class="string">&quot;%x&quot;</span> 9243 <span class="comment"># 转为16进制--&gt; 2353</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">printf</span> <span class="string">&quot;%x&quot;</span> 9244 <span class="comment"># 转为16进制--&gt; 2354</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在9048.txt 查找nid为 0x2353 和 0x2354的线程栈信息,最后发现是nio的WindowsSelectorImpl导致的</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat 9048.txt</span></span><br><span class="line"></span><br><span class="line">&quot;http-nio-8499-ClientPoller-0&quot; #27 daemon prio=5 os_prio=0 tid=0x4e69c800 nid=0x2353 runnable [0x5108f000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">at sun.nio.ch.WindowsSelectorImpl.resetWakeupSocket0(Native Method)</span><br><span class="line">at sun.nio.ch.WindowsSelectorImpl.resetWakeupSocket(Unknown Source)</span><br><span class="line">- locked &lt;0x257756d8&gt; (a java.lang.Object)</span><br><span class="line">at sun.nio.ch.WindowsSelectorImpl.doSelect(Unknown Source)</span><br><span class="line">at sun.nio.ch.SelectorImpl.lockAndDoSelect(Unknown Source)</span><br><span class="line">- locked &lt;0x257756b8&gt; (a sun.nio.ch.Util$2)</span><br><span class="line">- locked &lt;0x257756a8&gt; (a java.util.Collections$UnmodifiableSet)</span><br><span class="line">- locked &lt;0x2575d518&gt; (a sun.nio.ch.WindowsSelectorImpl)</span><br><span class="line">at sun.nio.ch.SelectorImpl.select(Unknown Source)</span><br><span class="line">at org.apache.tomcat.util.net.NioEndpoint$Poller.run(NioEndpoint.java:744)</span><br><span class="line">at java.lang.Thread.run(Unknown Source)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">- None</span><br></pre></td></tr></table></figure></li></ul><h2 id="基于-JvisualVM-的可视化监控"><a href="#基于-JvisualVM-的可视化监控" class="headerlink" title="基于 JvisualVM 的可视化监控"></a>基于 JvisualVM 的可视化监控</h2><h3 id="本地监控"><a href="#本地监控" class="headerlink" title="本地监控"></a>本地监控</h3><p>打开 JDK 安装目录 bin 文件夹下的 <code>jvisualvm.exe</code> ，在左侧的本地下可以看到正常运行的java 应用，除了正常的类似命令行界面化的操作外，我们可以安装别的好用的插件</p><blockquote><ol><li><p>工具–插件–设置–编辑 将URL修改为 <a href="https://visualvm.github.io/pluginscenters.html">https://visualvm.github.io/pluginscenters.html</a> 中对应的JDK版本下的地址，如JDK 8 Update 131 - 192</p><p><a href="https://visualvm.github.io/uc/8u131/updates.html">https://visualvm.github.io/uc/8u131/updates.xml.gz</a></p></li><li><p>切换TAB至可用插件，在其列表中选中 Visual GC 插件安装后重启<code>jvisualvm.exe</code> 即可看到多出的 Visual GC Tab</p></li></ol></blockquote><h3 id="远程监控"><a href="#远程监控" class="headerlink" title="远程监控"></a>远程监控</h3><h4 id="监控远程Tomcat"><a href="#监控远程Tomcat" class="headerlink" title="监控远程Tomcat"></a>监控远程Tomcat</h4><ul><li><p>修改 <code>Catalina.sh</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPTS=&quot;$JAVA_OPTS -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=xx -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Djava.net.preferlPv4Stack=true -Djava.rmi.server.hostname=xx.xx.xx.xx&quot;</span><br></pre></td></tr></table></figure></li></ul><h4 id="监控远程普通java进程"><a href="#监控远程普通java进程" class="headerlink" title="监控远程普通java进程"></a>监控远程普通java进程</h4><ul><li><p>添加启动参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=xx -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Djava.net.preferlPv4Stack=true -Djava.rmi.server.hostname=xx.xx.xx.xx -jar xx.jar &amp;</span><br></pre></td></tr></table></figure></li></ul><p><a href="https://visualvm.github.io/documentation.html">JvisualVM 参考链接</a></p><h2 id="基于Btrace的监控调试"><a href="#基于Btrace的监控调试" class="headerlink" title="基于Btrace的监控调试"></a>基于Btrace的监控调试</h2><p>Btrace可用动态的向目标应用程序的字节码注入追踪代码</p><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><ul><li><p>下载安装包</p><p><code>https://github.com/btraceio/btrace</code> 下载realse版本我这里是 <a href="https://github.com/btraceio/btrace/releases/download/v1.3.11.3/btrace-bin-1.3.11.3.zip">v1.3.11.3</a></p></li><li><p>解压并配置环境变量</p><p>新增环境变量 <code>BTRACE_HOME</code> ，Path 中追加 <code>%BTRACE_HOME%\bin</code></p></li></ul><h3 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h3><ul><li>在 <code>JVisualVM</code> 中添加Btrace插件，添加 <code>classpath</code></li><li>使用命令行 <code>btrace &lt;pid&gt; &lt;trace_script&gt;</code></li></ul><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><p>这里举在<code>JVisualVM</code> 中使用的例子，安装完Btrace插件后，对其中的 java 应用列表右键打开Trace application，例如对某个应用的某个查询方法的脚本如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.btrace.AnyType;</span><br><span class="line"><span class="keyword">import</span> com.sun.btrace.BTraceUtils;</span><br><span class="line"><span class="keyword">import</span> com.sun.btrace.annotations.BTrace;</span><br><span class="line"><span class="keyword">import</span> com.sun.btrace.annotations.Kind;</span><br><span class="line"><span class="keyword">import</span> com.sun.btrace.annotations.Location;</span><br><span class="line"><span class="keyword">import</span> com.sun.btrace.annotations.OnMethod;</span><br><span class="line"><span class="keyword">import</span> com.sun.btrace.annotations.ProbeClassName;</span><br><span class="line"><span class="keyword">import</span> com.sun.btrace.annotations.ProbeMethodName;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BTrace</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintArgDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@OnMethod(</span></span><br><span class="line"><span class="meta">clazz=&quot;com.itliusir.web.UserController&quot;,</span></span><br><span class="line"><span class="meta">method=&quot;query&quot;,</span></span><br><span class="line"><span class="meta">location=@Location(Kind.ENTRY)</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">queryTest</span><span class="params">(<span class="meta">@ProbeClassName</span> String className, <span class="meta">@ProbeMethodName</span> String methodName, AnyType[] args)</span> </span>&#123;</span><br><span class="line">BTraceUtils.printArray(args);</span><br><span class="line">BTraceUtils.println(className + <span class="string">&quot; &quot;</span> + methodName);</span><br><span class="line">BTraceUtils.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>勾上 <code>Output</code> <code>Class-Path</code> (Class-Path 可以用来增加第三方jar包)，点击 <code>Start</code> 即可等待执行到 <code>query</code> 方法后的打印输出</p><h4 id="Doc"><a href="#Doc" class="headerlink" title="Doc"></a>Doc</h4><ul><li><strong>普通方法 @OnMethod(clazz=””,method=””)</strong></li><li><strong>构造方法 @OnMethod(clazz=””,method=”“)</strong></li><li><strong>重载方法通过参数区分</strong></li><li><strong>Kind 拦截时机</strong><ul><li><strong>Kind.ENTRY 入口，默认值</strong></li><li><strong>Kind.RETURN 返回</strong></li><li><strong>Kind.THROW 异常</strong></li><li><strong>Kind.Line 行</strong></li></ul></li><li><strong>this: 形参+@Self 可以拦截this对象</strong></li><li><strong>复杂的参数可以通过反射获取</strong></li><li><strong>printXxx()</strong></li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>默认只能本地运行</strong></li><li><strong>生产环境下也可以使用，但是被修改的字节码不会被还原</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm monitor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM Param</title>
      <link href="/2019/JVM-Param/"/>
      <url>/2019/JVM-Param/</url>
      
        <content type="html"><![CDATA[<p>摘要: jvm param</p><span id="more"></span><h1 id="JVM-参数"><a href="#JVM-参数" class="headerlink" title="JVM 参数"></a>JVM 参数</h1><h2 id="JVM-参数类型"><a href="#JVM-参数类型" class="headerlink" title="JVM 参数类型"></a>JVM 参数类型</h2><h3 id="标准参数"><a href="#标准参数" class="headerlink" title="标准参数"></a>标准参数</h3><ul><li><strong>-help</strong></li><li><strong>-server -client</strong></li><li><strong>-version -showvesion</strong></li><li><strong>-cp -classpath</strong></li></ul><h3 id="X参数"><a href="#X参数" class="headerlink" title="X参数"></a>X参数</h3><p>非标准化参数</p><ul><li><p><strong>-Xint 解释执行</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -Xint -version</span></span><br><span class="line">java version &quot;1.8.0_144&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_144-b01)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.144-b01, interpreted mode)</span><br></pre></td></tr></table></figure></li><li><p><strong>-Xcomp 第一次使用就编译成本地代码</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -Xcomp -version</span></span><br><span class="line">java version &quot;1.8.0_144&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_144-b01)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.144-b01, compiled mode)</span><br></pre></td></tr></table></figure></li><li><p><strong>-Xmixed 混合模式，JVM自己来决定是否编译成本地代码</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -version</span></span><br><span class="line">java version &quot;1.8.0_144&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_144-b01)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.144-b01, mixed mode)</span><br></pre></td></tr></table></figure></li></ul><h3 id="XX参数"><a href="#XX参数" class="headerlink" title="XX参数"></a>XX参数</h3><p>非标准化参数，相对不稳定，主要用于JVM调优和调试</p><ul><li><p><strong>Boolean 类型</strong></p><p>格式：-XX:[+-] 表示启用或 者禁用name属性</p><p>exp ：-XX:+UseConcMarkSweepGC -XX:+UseG1GC</p></li><li><p><strong>非 Boolean 类型</strong></p><p>格式：-XX:= 表示name属性的值是value</p><p>exp ：-XX:MaxGCPauseMillis=500 -XX:GCTimeRatio=19</p></li><li><p><strong>-Xmx -Xms …参数</strong></p><p>不是X参数，而是XX参数</p><p>-Xms 等价于 -XX:InitialHeapSize= Heap初始化的大小</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jinfo.exe -flag InitialHeapSize 20016</span></span><br><span class="line">-XX:InitialHeapSize=1073741824 # 1G</span><br></pre></td></tr></table></figure><p>-Xmx 等价于 -XX:MaxHeapSize= Heap的最大值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jinfo.exe -flag MaxHeapSize 20016</span></span><br><span class="line">-XX:MaxHeapSize=1073741824 # 1G</span><br></pre></td></tr></table></figure><p>-Xss 等价于 -XX:ThreadStackSize= 线程栈的大小，默认1M</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jinfo.exe -flag ThreadStackSize 20016</span></span><br><span class="line">-XX:ThreadStackSize=1024 # 1M</span><br></pre></td></tr></table></figure><p>-Xmn 等价于 -XX:MaxNewSize= -XX:NewSize= 新生代的大小</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jinfo.exe -flag MaxNewSize 20016</span></span><br><span class="line">-XX:MaxNewSize=536870912 # 512M</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> jinfo.exe -flag NewSize 20016</span></span><br><span class="line">-XX:NewSize=536870912# 512M</span><br></pre></td></tr></table></figure></li></ul><h2 id="查看JVM运行时参数"><a href="#查看JVM运行时参数" class="headerlink" title="查看JVM运行时参数"></a>查看JVM运行时参数</h2><ul><li><p><strong>-XX:+PrintFlagsInitial</strong> 查看初始值</p></li><li><p><strong>-XX:+PrintFlagsFinal</strong> 查看最终值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -XX:+PrintFlagsFinal -version</span></span><br><span class="line">[Global flags]</span><br><span class="line">...</span><br><span class="line">bool UseConcMarkSweepGC                        = false</span><br><span class="line">    bool UseParallelGC                            := true</span><br><span class="line">    uintx MaxHeapSize                             := 4227858432                uintx MaxMetaspaceSize                         = 4294901760</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><blockquote><p>:= 代表被修改后的值</p><p>= 表示默认值</p></blockquote></li><li><p><strong>-XX:+UnlockExperimentalVMOptions</strong> 解锁实验参数</p></li><li><p><strong>-XX:+UnlockDiagnosticVMOptions</strong> 解锁诊断参数</p></li><li><p><strong>-XX:+PrintCommandLineFlags</strong> 打印命令行参数</p></li><li><p><strong>jinfo</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jinfo.exe -flags 20016</span></span><br><span class="line">Attaching to process ID 20016, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.144-b01</span><br><span class="line">Non-default VM flags: -XX:-BytecodeVerificationLocal -XX:-BytecodeVerificationRemote -XX:CICompilerCount=4 -XX:+CMSClassUnloadingEnabled -XX:CMSInitiatingOccupancyFraction=80 -XX:CMSMaxAbortablePrecleanTime=5000 ...</span><br></pre></td></tr></table></figure></li><li><p><strong>jps</strong> 类似ps命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jps</span></span><br><span class="line">20016 YssBaseAdminApplication</span><br><span class="line">11704 YssBaseAuthApplication</span><br><span class="line">20824 AuthDataSyncApplication</span><br><span class="line">14140 ApiGatewayApplication</span><br><span class="line">21564 Jps</span><br></pre></td></tr></table></figure></li><li><p><strong>jstat</strong></p><p><em>查看类装载信息</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jstat -class 20016 1000 3</span></span><br><span class="line">Loaded  Bytes  Unloaded  Bytes     Time</span><br><span class="line"> 17738 37286.3        0     0.0      14.17</span><br><span class="line"> 17738 37286.3        0     0.0      14.17</span><br><span class="line"> 17738 37286.3        0     0.0      14.17</span><br></pre></td></tr></table></figure><p><em>查看垃圾收集信息</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jstat -gc 20016 1000 3</span></span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">43648.0 43648.0 35638.4  0.0   436992.0 92098.5   524288.0   274918.1  116992.0 111496.1 14080.0 12956.9     26    1.148   0      0.000    1.148</span><br><span class="line">43648.0 43648.0 35638.4  0.0   436992.0 92281.4   524288.0   274918.1  116992.0 111496.1 14080.0 12956.9     26    1.148   0      0.000    1.148</span><br><span class="line">43648.0 43648.0 35638.4  0.0   436992.0 92305.6   524288.0   274918.1  116992.0 111496.1 14080.0 12956.9     26    1.148   0      0.000    1.148</span><br></pre></td></tr></table></figure><blockquote><p>_C 总量 _U使用量</p><p>S0、S1 S区</p><p>E Eden 区</p><p>O Old 区</p><p>M Metaspace 区</p><p>CC 压缩类空间</p><p>YGC Young GC 次数</p><p>YGCT Young GC 时间</p><p>FGC Full GC 次数</p><p>FGCT Full GC 时间</p><p>GCT 总的GC 时间</p></blockquote><p><em>查看JIT编译信息</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jstat -compiler 20016</span></span><br><span class="line">Compiled Failed Invalid   Time   FailedType FailedMethod</span><br><span class="line">   21115     11       0     5.54          1 org/apache/http/client/utils/URLEncodedUtils parse</span><br><span class="line">   </span><br><span class="line"><span class="meta">$</span><span class="bash"> jstat -printcompilation 20016</span></span><br><span class="line">Compiled  Size  Type Method</span><br><span class="line">   21127      9    1 org/apache/coyote/AbstractProcessor _jr$ip$socketWrapper</span><br></pre></td></tr></table></figure><blockquote><p>Compiled 编译的任务(把一个方法编译为本地方法)</p></blockquote><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html#BEHHGFAE">参数docs</a></p></li><li><p><strong>jmap</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jmap -dump:format=b,file=heap.hprof 20016</span></span><br><span class="line">Dumping heap to D:\arthas\heap.hprof ...</span><br><span class="line">Heap dump file created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> jmap -heap 20016</span></span><br><span class="line">Attaching to process ID 20016, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.144-b01</span><br><span class="line"></span><br><span class="line">using parallel threads in the new generation.</span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Concurrent Mark-Sweep GC</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = 40</span><br><span class="line">   MaxHeapFreeRatio         = 70</span><br><span class="line">   MaxHeapSize              = 1073741824 (1024.0MB)</span><br><span class="line">   NewSize                  = 536870912 (512.0MB)</span><br><span class="line">   MaxNewSize               = 536870912 (512.0MB)</span><br><span class="line">   OldSize                  = 536870912 (512.0MB)</span><br><span class="line">   NewRatio                 = 2</span><br><span class="line">   SurvivorRatio            = 10</span><br><span class="line">   MetaspaceSize            = 268435456 (256.0MB)</span><br><span class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB)</span><br><span class="line">   MaxMetaspaceSize         = 536870912 (512.0MB)</span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">New Generation (Eden + 1 Survivor Space):</span><br><span class="line">   capacity = 492175360 (469.375MB)</span><br><span class="line">   used     = 314702936 (300.12410736083984MB)</span><br><span class="line">   free     = 177472424 (169.25089263916016MB)</span><br><span class="line">   63.94122127527879% used</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 447479808 (426.75MB)</span><br><span class="line">   used     = 279453176 (266.50731658935547MB)</span><br><span class="line">   free     = 168026632 (160.24268341064453MB)</span><br><span class="line">   62.450454971143635% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = 44695552 (42.625MB)</span><br><span class="line">   used     = 35249760 (33.616790771484375MB)</span><br><span class="line">   free     = 9445792 (9.008209228515625MB)</span><br><span class="line">   78.8663713114003% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = 44695552 (42.625MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 44695552 (42.625MB)</span><br><span class="line">   0.0% used</span><br><span class="line">concurrent mark-sweep generation:</span><br><span class="line">   capacity = 536870912 (512.0MB)</span><br><span class="line">   used     = 318668000 (303.9054870605469MB)</span><br><span class="line">   free     = 218202912 (208.09451293945312MB)</span><br><span class="line">   59.35654044151306% used</span><br><span class="line"></span><br><span class="line">63573 interned Strings occupying 7445616 bytes.</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm param </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM ClassFile Structure</title>
      <link href="/2019/JVM-Specification-notes-2/"/>
      <url>/2019/JVM-Specification-notes-2/</url>
      
        <content type="html"><![CDATA[<p>摘要: ClassFile Structure</p><span id="more"></span><h1 id="Class-文件格式"><a href="#Class-文件格式" class="headerlink" title="Class 文件格式"></a>Class 文件格式</h1><h2 id="ClassFile-结构"><a href="#ClassFile-结构" class="headerlink" title="ClassFile 结构"></a>ClassFile 结构</h2><p>我们可以使用 <a href="https://github.com/zxh0/classpy">classpy</a> 来分析我们的 class 文件结构</p><p><a href="http://qiniu.itliusir.com/classfile.png"><img src="http://qiniu.itliusir.com/classfile.png" alt="classfile"></a>classfile</p><p>其结构在 Java虚拟机规范中有如下定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">   u4                 magic;</span><br><span class="line">   u2                 minor_version;</span><br><span class="line">   u2                 major_version;</span><br><span class="line">   u2                 constant_pool_count;</span><br><span class="line">   cp_info            constant_pool[constant_pool_count-1];</span><br><span class="line">   u2                 access_flags;</span><br><span class="line">   u2                 this_class;</span><br><span class="line">   u2                 super_class;</span><br><span class="line">   u2                 interfaces_count;</span><br><span class="line">   u2                 interfaces[interfaces_count];</span><br><span class="line">   u2                 fields_count;</span><br><span class="line">   field_info         fields[fields_count];</span><br><span class="line">   u2                 methods_count;</span><br><span class="line">   method_info        methods[methods_count];</span><br><span class="line">   u2                 attributes_count;</span><br><span class="line">   attribute_info     attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="magic"><a href="#magic" class="headerlink" title="magic"></a>magic</h3><p>魔数，判断文件是否是能被虚拟机接受的class文件，固定值为 <code>0xCAFEBABE</code></p><h3 id="minor-version、major-version"><a href="#minor-version、major-version" class="headerlink" title="minor_version、major_version"></a>minor_version、major_version</h3><p>副版本号和主版本号，高版本支持低版本，低版本不支持高版本</p><p><a href="http://qiniu.itliusir.com/classfile-version.png"><img src="http://qiniu.itliusir.com/classfile-version.png" alt="version"></a>version</p><h3 id="constant-pool-count"><a href="#constant-pool-count" class="headerlink" title="constant_pool_count"></a>constant_pool_count</h3><p>常量池计数器，constant_pool_count 的值等于 constant_pool 表中的成员数+1</p><p>constant_pool 表的索引值从1开始</p><h3 id="constant-pool"><a href="#constant-pool" class="headerlink" title="constant_pool []"></a>constant_pool []</h3><p>常量池，constant_pool 是一种表结构，包含如下内容</p><p><a href="http://qiniu.itliusir.com/classfile_constant_pool.png"><img src="http://qiniu.itliusir.com/classfile_constant_pool.png" alt="constant_pool"></a>constant_pool</p><p>可以看到常量池大致两类:</p><ol><li><p><strong>字面量</strong></p></li><li><p><strong>符号引用</strong></p><p>包括方法、字段、类信息等，通过 class_index 、name_and_type_index 索引找到 常量池中 Class 、NameAndType ，再通过 name_index 、descriptor_index 索引最终找到对应信息</p></li></ol><h3 id="access-flags"><a href="#access-flags" class="headerlink" title="access_flags"></a>access_flags</h3><p>访问标志，表示某个类或接口的访问权限和基础属性，如：ACC_PUBLIC、ACC_SUPER</p><h3 id="this-class-super-class"><a href="#this-class-super-class" class="headerlink" title="this_class/super_class"></a>this_class/super_class</h3><p><a href="http://qiniu.itliusir.com/this-class.png"><img src="http://qiniu.itliusir.com/this-class.png" alt="this_class/supper_class"></a>this_class/supper_class</p><p>class文件存储的类名类似完全限定名，但是把点换成了斜线，Java语言规范把这种名字叫作二进制名（binary names）。因为每个类都有名字，所以thisClass必须是有效的常量池索引</p><h3 id="interfaces-count-interface"><a href="#interfaces-count-interface" class="headerlink" title="interfaces_count/interface[]"></a>interfaces_count/interface[]</h3><p>接口计数器，表示当前类或接口的直接父接口数量，interface[] 表示接口表</p><h3 id="fields-count-fields"><a href="#fields-count-fields" class="headerlink" title="fields_count/fields[]"></a>fields_count/fields[]</h3><p>字段计数器，表示当前 Class 文件 fields[] 数组的成员个数</p><p><strong>源代码如下</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ClassFileDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static final boolean FLAG = true;</span><br><span class="line">    public static final byte BYTE = 123;</span><br><span class="line">    public static final char X = &#x27;X&#x27;;</span><br><span class="line">    public static final short SHORT = 12345;</span><br><span class="line">    public static final int INT = 123456789;</span><br><span class="line">    public static final long LONG = 12345678901L;</span><br><span class="line">    public static final float PI = 3.14f;</span><br><span class="line">    public static final double E = 2.71828;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Class File</strong></p><p><a href="http://qiniu.itliusir.com/fields.png"><img src="http://qiniu.itliusir.com/fields.png" alt="fields"></a>fields</p><h3 id="methods-count-methods"><a href="#methods-count-methods" class="headerlink" title="methods_count/methods[]"></a>methods_count/methods[]</h3><p>方法计数器，表示当前 class 文件 method[] 数组的成员个数</p><p><strong>源代码如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RuntimeException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Class File</strong></p><p><a href="http://qiniu.itliusir.com/methods.png"><img src="http://qiniu.itliusir.com/methods.png" alt="methods"></a>methods</p><p><code>&lt;init&gt;</code> 方法是编译器生成的默认构造方法</p><h3 id="attributes-count-attributes"><a href="#attributes-count-attributes" class="headerlink" title="attributes_count/attributes[]"></a>attributes_count/attributes[]</h3><p>属性计数器，表示当前 class 文件 attributes[] 表的成员个数</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> class </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018-年度总结</title>
      <link href="/2018/2018%20Annual-Summary/"/>
      <url>/2018/2018%20Annual-Summary/</url>
      
        <content type="html"><![CDATA[<p>摘要: 2018-年度总结</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文:"></a>正文:</h2><h2 id="2018-年度总结"><a href="#2018-年度总结" class="headerlink" title="2018 年度总结"></a>2018 年度总结</h2><p>今年的冬天格外的冷，各大公司裁员的消息铺面而来，虽说对我这种最底层的码畜毫无影响，但对今年总体学习与收获情况不太满意</p><h3 id="内容总结"><a href="#内容总结" class="headerlink" title="内容总结"></a>内容总结</h3><ol><li><p>今年除去公司内部 wiki，一共写了 33 篇博客，我始终认为写博客是一个很好的学习手段，不光是对自己知识点的梳理，也是一个验证自己理解是否正确的一个过程</p></li><li><p>只看了大概4本书</p><ul><li><strong>《Spring Cloud微服务实战》</strong></li><li><strong>《图解 HTTP》</strong></li><li><strong>《Docker容器与容器云 第二版》</strong></li><li><strong>《大话数据结构 1~6章节》</strong></li><li><strong>《Rest 论文》</strong></li></ul></li><li><p>断断续续的阅读了一些 <strong>JDK核心类</strong> 的源码：</p><blockquote><p><strong>ArrayList</strong> 、<strong>LinkedList</strong> 、 <strong>HashMap</strong> 、<strong>ConcurrentHashMap</strong> 、<strong>invoke</strong> 、<strong>CAS</strong> 、<strong>AQS</strong> 、<strong>ReentrantLock</strong></p></blockquote></li><li><p>粗略的阅读了Spring的部分代码，学习了它的底层流程，对自己更好的去使用很有帮助</p><blockquote><p> <strong>IOC</strong> 、<strong>AOP</strong>、<strong>Transaction</strong></p></blockquote></li><li><p>在微服务开发中，从0到1锻炼了自己的技术应用与落地能力，并组织了为期半年的技术分享</p></li><li><p>工作之余面了小赢科技、有利网、同程艺龙、网易这些公司的 Java岗位，个人认为面试也是验证自己所学知识点以及欠缺部分的一个重要手段</p></li></ol><h3 id="学习总结"><a href="#学习总结" class="headerlink" title="学习总结"></a>学习总结</h3><p>目前学习的主要途径是看书、极客专栏、源代码，对于扩展眼界的会去浏览一些知识星球和各种技术博客公众号的案例分享经验与问题。看书会深入的了解一样技术的发展由来和自身特性，而极客专栏可以丰富自己的深度，同时可以结合源代码自己去理解。看技术博客一定要找一些干货，乱花渐欲迷人眼，一些互抄互蹭热点的文章反而会消耗自己的精力</p><h3 id="面试总结"><a href="#面试总结" class="headerlink" title="面试总结"></a>面试总结</h3><p>面试的过程其实很重要，无论是我去面一些实习生或者自己去面别的公司，都是一个很重要的互相沟通过程，每个人都有自己擅长的地方，不但可以根据别人不同的理解与看法增加自己的感悟、也可以对自己方方面面做一次一次的总结，查缺补漏可谓是起到小学老师抽查背课文的作用</p><p>下面是对行业需求的知识点(面试点)的一个总结：<br><a href="http://itliusir.com/2018/2018%20Interview-Summary/">2018 面试题总结</a></p><h3 id="工作总结"><a href="#工作总结" class="headerlink" title="工作总结"></a>工作总结</h3><p>今年工作的主要核心内容就是Spring Cloud体系技术栈、期间穿梭在搭建基础组件与开发业务服务之间，这段时间对于自身所学做了很好的实践，也是成长最快的一个阶段，对于刚入行的小白提高广度也是很必要的。</p><p>工作中不做出头鸟，低调做人，高调做事。少些繁琐的事会给自己留更多的思考与学习空间</p><h3 id="生活总结"><a href="#生活总结" class="headerlink" title="生活总结"></a>生活总结</h3><p>emmm… 我有女票了，哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈</p><h3 id="整体收获总结"><a href="#整体收获总结" class="headerlink" title="整体收获总结"></a>整体收获总结</h3><p>自己目前掌握的知识也只能算是入行，作为非科班出身的自身而言无论是深度(如数据结构、数据库原理、网络协议、垃圾回收算法、分布式一致性协议) 还是 广度(高并发、大数据量) 都没达不到大厂码农的水平，自己着实给程序员拖后腿了，明年学习计划主要放在基础部分，想爬上树就得从底下开始</p><h3 id="2019-学习计划"><a href="#2019-学习计划" class="headerlink" title="2019 学习计划"></a>2019 学习计划</h3><h4 id="1-阅读计划"><a href="#1-阅读计划" class="headerlink" title="1. 阅读计划"></a>1. 阅读计划</h4><p>读5本打基础的书籍</p><ul><li><strong>《深入理解Java 虚拟机》</strong></li><li><strong>《并发编程的艺术》</strong></li><li><strong>《数据库索引设计与优化》</strong></li><li>…</li></ul><h4 id="2-JDK核心源码"><a href="#2-JDK核心源码" class="headerlink" title="2. JDK核心源码"></a>2. JDK核心源码</h4><ul><li><strong>J.U.C 剩余部分</strong></li><li><strong>HashMap 红黑树部分</strong></li></ul><h4 id="3-博客"><a href="#3-博客" class="headerlink" title="3. 博客"></a>3. 博客</h4><ul><li><strong>完成10篇高质量的博客</strong></li></ul><p>借助星爷喜剧之王的开头<strong>努力！ 奋斗！</strong> ， 尽管星爷当初只是个死跑龙套的，但是仍然有着自己的理想与抱负，不管最后是悲剧还是喜剧尽力演好自己的角色就好</p><p><em>只有小演员，没有小角色</em> </p><p><img src="http://qiniu.itliusir.com/xjzw.png"></p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring IOC Notes-Core method analysis</title>
      <link href="/2018/Spring-Study%20IOC2/"/>
      <url>/2018/Spring-Study%20IOC2/</url>
      
        <content type="html"><![CDATA[<p>摘要: Spring IOC 学习笔记-核心方法分析</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文:"></a>正文:</h2><h2 id="核心方法分析"><a href="#核心方法分析" class="headerlink" title="核心方法分析"></a>核心方法分析</h2><h3 id="scan–-gt-doScan"><a href="#scan–-gt-doScan" class="headerlink" title="scan–&gt;doScan"></a>scan–&gt;doScan</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">Assert.notEmpty(basePackages, <span class="string">&quot;At least one base package must be specified&quot;</span>);</span><br><span class="line"><span class="comment">// 使用Set可以去重，BeanDefinitionHolder对象已实现equals与hashCode方法</span></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet&lt;BeanDefinitionHolder&gt;();</span><br><span class="line"><span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line"> <span class="comment">// 扫描basePackage,并将带有@Componet、@ManagedBean(JSR-250)、@Named(JSR-330)的class装载入beanDefinition</span></span><br><span class="line">Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line"><span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line"> <span class="comment">// 判断Scope，若无则scopeName默认为singleton、scopedProxyMode默认为NO</span></span><br><span class="line">ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line"> <span class="comment">//生成BeanName,首先会判断@Componet..JSR.,然后未设置则会默认类名首字母小写的beanName</span></span><br><span class="line">String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">  <span class="comment">// 初始化candidate默认属性</span></span><br><span class="line">postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">  <span class="comment">// 判断属性值并赋值</span></span><br><span class="line">AnnotationConfigUtils.processCommonDefinitionAnnotations(</span><br><span class="line">(AnnotatedBeanDefinition) candidate);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//检查bean是否已经存在</span></span><br><span class="line"><span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">  <span class="comment">// 判断scopedProxyMode值确认是否需要代理创建</span></span><br><span class="line">definitionHolder =</span><br><span class="line">AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">beanDefinitions.add(definitionHolder);</span><br><span class="line">  <span class="comment">// 注册beanDefinitionMap、新增beanDefinitionNames、</span></span><br><span class="line">registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="refresh"><a href="#refresh" class="headerlink" title="refresh"></a>refresh</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁，避免并发refresh</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// 设置startupDate、active(启动状态)、标准环境的初始化、初始化ApplicationEvents</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是AnnotationConfigApplicationContext 会在 上个方法 doScan 中进行装载beanDefinitionMap，如果是ClassPathXmlApplicationContext 会在如下方法进行装载beanDefinitionMap</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置ClassLoader、beanPostProcessor、registerSingleton(特殊bean)、</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 留给子类的扩展点，可以在这里对beanFactory做一些特殊的操作</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接下来就是调用已注册子类的BeanFactoryPostProcessor的postProcessBeanFactory方法</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注册BeanPostProcessor的实现类，该接口的两个可以扩展的方法：</span></span><br><span class="line">            <span class="comment">// 1. postProcessBeforeInitialization Bean初始化之前执行</span></span><br><span class="line">            <span class="comment">// 2. postProcessAfterInitialization  Bean初始化之后执行</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注册messageSource</span></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注册SimpleApplicationEventMulticaster(事件广播器),不指定beanName会默认创建,无法自定义</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 留给子类的扩展点，可以在这里对特殊的bean进行初始化</span></span><br><span class="line">            onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注册ApplicationListener(事件监听器)的实现类</span></span><br><span class="line">            registerListeners();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 实例化所有剩余（非lazy-init）的singleton beans</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">            destroyBeans();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">            <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getBean–-gt-doGetBean"><a href="#getBean–-gt-doGetBean" class="headerlink" title="getBean–&gt;doGetBean"></a>getBean–&gt;doGetBean</h3><blockquote><p>Bean加载的大致流程如下：</p><ol><li>处理 <code>beanName</code> (别名、 <code>FACTORY_BEAN_PREFIX</code> )</li><li>尝试从缓存、<code>singletonFactories</code> 中加载</li><li> <code>Bean</code> 的实例化</li><li>初始化依赖部分(若存在)</li><li>针对不同 <code>scope</code> 进行 <code>Bean</code> 的创建</li><li>类型转换</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">final</span> String name, <span class="keyword">final</span> Class&lt;T&gt; requiredType, <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">// 处理beanName(别名、FACTORY_BEAN_PREFIX)</span></span><br><span class="line"><span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">Object bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查(缓存、singletonFactories)是否已创建</span></span><br><span class="line">Object sharedInstance = getSingleton(beanName);</span><br><span class="line"><span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line"><span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +</span><br><span class="line"><span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 如果不是FactoryBean则直接返回,若是则返回getObject();</span></span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 只有单例情况(缓存、提前暴露ObjectFactory)下才会尝试解决循环依赖，如果是Prototype则直接抛出异常</span></span><br><span class="line"><span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否已存在</span></span><br><span class="line">BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line"> <span class="comment">// 当前加载的配置是否包含beanName</span></span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line"><span class="comment">// 如果是FactoryBean则标记+&amp;</span></span><br><span class="line">String nameToLookup = originalBeanName(name);</span><br><span class="line"> <span class="comment">// 递归父BeanFactory结果</span></span><br><span class="line"><span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line"><span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line"><span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果不是仅仅做类型检查(创建 Bean )则要进行记录</span></span><br><span class="line"><span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line"> <span class="comment">//alreadyCreated.add(beanName)</span></span><br><span class="line">markBeanAsCreated(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="comment">// 转换为 RootBeanDefinition</span></span><br><span class="line"><span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">String[] dependsOn = mbd.getDependsOn();</span><br><span class="line"><span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="comment">// 若存在依赖则递归实例化依赖</span></span><br><span class="line"><span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line"><span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 缓存依赖调用-&gt;dependentBeanMap(dep,Set&lt;beanName&gt;)</span></span><br><span class="line">registerDependentBean(dep, beanName);</span><br><span class="line">getBean(dep);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果bean是singleton 则开始创建</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">sharedInstance = getSingleton(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">// 创建bean 见下文详细分析</span></span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line"><span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line"><span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">destroySingleton(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">  <span class="comment">// 如果不是FactoryBean则直接返回,若是则返回getObject();</span></span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果bean是prototype 则开始创建</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line"><span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line">  <span class="comment">// 创建bean</span></span><br><span class="line">prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 如果不是FactoryBean则直接返回,若是则返回getObject();</span></span><br><span class="line">bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非singleton和prototype的bean创建</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">String scopeName = mbd.getScope();</span><br><span class="line"><span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line"><span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object scopedInstance = scope.get(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">  <span class="comment">// 如果不是FactoryBean则直接返回,若是则返回getObject();</span></span><br><span class="line">bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line"><span class="string">&quot;Scope &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27; is not active for the current thread; consider &quot;</span> +</span><br><span class="line"><span class="string">&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;</span>,</span><br><span class="line">ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查类型</span></span><br><span class="line"><span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; bean != <span class="keyword">null</span> &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +</span><br><span class="line">ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getSingleton"><a href="#getSingleton" class="headerlink" title="getSingleton"></a>getSingleton</h3><blockquote><p>单例Bean的创建</p><ol><li>同步</li><li>检查缓存是否已加载过</li><li>记录创建状态</li><li>调用 <code>singletonFactory.getObject()</code> 初始化接口</li><li>删除创建状态</li><li>结果加入缓存( <code>singletonObjects</code> 、<code>registeredSingletons</code> )并清除一些辅助状态缓存( <code>singletonFactories</code> 、 <code>earlySingletonObjects</code> )<ul><li><code>Map&lt;String, Object&gt; singletonObjects</code> 保存 <code>beanName--&gt;beanInstance</code></li><li><code>Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories</code> 保存 <code>beanName--&gt;ObjectFactory</code></li><li> <code>Map&lt;String, Object&gt; earlySingletonObjects</code> 保存 <code>beanName--&gt;beanInstance</code> 在上文 <code>doGetBean()</code> 方法有调用到 <code>Object sharedInstance = getSingleton(beanName)</code> 与 <code>singletonObjects</code> 区别也即是此处，当bean在此处时在创建过程中就可以通过 <code>getBean --&gt; doGetBean()</code> 获取到了</li><li><code>Set&lt;String&gt; registeredSingletons</code> 保存 所有已注册的Bean</li></ul></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(beanName, <span class="string">&quot;&#x27;beanName&#x27; must not be null&quot;</span>);</span><br><span class="line">    <span class="comment">// 同步全局变量</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="comment">// 有则复用 无则创建</span></span><br><span class="line">        Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationNotAllowedException(beanName,</span><br><span class="line">                                                          <span class="string">&quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot;</span> +</span><br><span class="line">                                                          <span class="string">&quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Creating shared instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录正在创建的状态 --&gt;singletonsCurrentlyInCreation.add(beanName)</span></span><br><span class="line">            beforeSingletonCreation(beanName);</span><br><span class="line">            <span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">boolean</span> recordSuppressedExceptions = (<span class="keyword">this</span>.suppressedExceptions == <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">new</span> LinkedHashSet&lt;Exception&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 初始化</span></span><br><span class="line">                singletonObject = singletonFactory.getObject();</span><br><span class="line">                newSingleton = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                <span class="comment">// Has the singleton object implicitly appeared in the meantime -&gt;</span></span><br><span class="line">                <span class="comment">// if yes, proceed with it since the exception indicates that state.</span></span><br><span class="line">                singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Exception suppressedException : <span class="keyword">this</span>.suppressedExceptions) &#123;</span><br><span class="line">                        ex.addRelatedCause(suppressedException);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 删除正在创建的状态 --&gt;singletonsCurrentlyInCreation.remove(beanName)</span></span><br><span class="line">                afterSingletonCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">                <span class="comment">// 加入缓存(singletonObjects/registeredSingletons)、清除singletonFactories/earlySingletonObjects</span></span><br><span class="line">                addSingleton(beanName, singletonObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="createBean–-gt-doCreateBean"><a href="#createBean–-gt-doCreateBean" class="headerlink" title="createBean–&gt;doCreateBean"></a>createBean–&gt;doCreateBean</h3><blockquote><p>从上文中的 <code>doScan</code> 和 <code>doGetBean</code> 的命名方式可以看出，真正干活的都是 <code>doXxx</code> </p></blockquote><blockquote><p>而创建 Bean 也不例外，真正干活的在 <code>doCreateBean</code> 中</p><p>下面是创建 Bean 的流程</p><ol><li>如果是单例，则清除缓存</li><li><code>RootBeanDefinition --&gt; BeanWrapper</code> (初始化默认选择无参构造方法)</li><li>判断是否需要提前暴露</li><li>依赖循环处理，即将A提前放入缓存，依赖A的B在创建时会去缓存拿 <code>ObjectFactory</code> 来创建</li><li>填充属性</li><li>初始化</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate the bean.</span></span><br><span class="line">BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Object bean = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedInstance() : <span class="keyword">null</span>);</span><br><span class="line">Class&lt;?&gt; beanType = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedClass() : <span class="keyword">null</span>);</span><br><span class="line">mbd.resolvedTargetType = beanType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line"><span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line"><span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否需要提前暴露，是否单例&amp;允许循环依赖(default:true)&amp;正在创建状态(参考上文的getSingleton()--&gt;beforeSingletonCreation(beanName);)</span></span><br><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line"><span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 将创建实例先存入ObjectFactory</span></span><br><span class="line">addSingletonFactory(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="comment">// 若没有InstantiationAwareBeanPostProcessors则直接返回</span></span><br><span class="line"><span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the bean instance.</span></span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="comment">// 对bean属性注入，若依赖别的Bean则递归初始化依赖Bean</span></span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line"><span class="keyword">if</span> (exposedObject != <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *  初始化</span></span><br><span class="line"><span class="comment">  *  想起了生命周期没 /滑稽</span></span><br><span class="line"><span class="comment">  * 1. BeanPostProcessor.postProcessBeforeInitialization</span></span><br><span class="line"><span class="comment">  * 2. InitializingBean.afterPropertiesSet</span></span><br><span class="line"><span class="comment">  * 3. init-method</span></span><br><span class="line"><span class="comment">  * 4. BeanPostProcessor.postProcessAfterInitialization</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line"><span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断是否增强 (即在initializeBean()中有没有被改变)</span></span><br><span class="line"><span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">exposedObject = earlySingletonReference;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 判断当前Bean被其他Bean所依赖</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;(dependentBeans.length);</span><br><span class="line"><span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line"><span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">actualDependentBeans.add(dependentBean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 若互相依赖不一致则抛异常</span></span><br><span class="line"><span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line"><span class="string">&quot;抛异常&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean as disposable.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ioc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring IOC Notes-Obj Creation Process</title>
      <link href="/2018/Spring-Study%20IOC/"/>
      <url>/2018/Spring-Study%20IOC/</url>
      
        <content type="html"><![CDATA[<p>摘要: Spring IOC 学习笔记-对象创建过程</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文:"></a>正文:</h2><h2 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h2><p><code>Resource</code> (<code>xml</code> <code>annotation</code> <code>class</code> <code>properties/yml</code>) -&gt; <code>BeanDefinition</code> -&gt; <code>BeanWrapper</code> -&gt; <code>Object</code></p><h3 id="Resource-–-gt-BeanDefinition"><a href="#Resource-–-gt-BeanDefinition" class="headerlink" title="Resource –&gt; BeanDefinition"></a><code>Resource</code> –&gt; <code>BeanDefinition</code></h3><h4 id="For-Xml"><a href="#For-Xml" class="headerlink" title="For Xml"></a>For <code>Xml</code></h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itliusir.spring.entity.User&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;杰克&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;classes&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;aClass&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;aClass&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itliusir.spring.entity.Class&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;className&quot;</span> <span class="attr">value</span>=<span class="string">&quot;终极一班&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ClassPathXmlApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext</span><br><span class="line">        (<span class="string">&quot;classpath:bean.xml&quot;</span>);</span><br><span class="line">    User user = applicationContext.getBean(User.class);</span><br><span class="line">    log.info(user.getName());</span><br><span class="line">    log.info(user.getClasses().getClassName());</span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;杰克&quot;</span>, user.getName());</span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;终极一班&quot;</span>, user.getClasses().getClassName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> org.springframework.context.support.ClassPathXmlApplicationContext#</span><br><span class="line">ClassPathXmlApplicationContext(java.lang.String)</span><br><span class="line"><span class="number">2.</span> org.springframework.context.support.AbstractApplicationContext#</span><br><span class="line">refresh</span><br><span class="line"><span class="number">3.</span> org.springframework.context.support.AbstractApplicationContext#</span><br><span class="line">obtainFreshBeanFactory</span><br><span class="line"><span class="number">4.</span> org.springframework.context.support.AbstractRefreshableApplicationContext#</span><br><span class="line">refreshBeanFactory</span><br><span class="line"><span class="number">5.</span> org.springframework.context.support.AbstractXmlApplicationContext#</span><br><span class="line">loadBeanDefinitions(org.springframework.beans.factory.support.DefaultListableBeanFactory)</span><br><span class="line"><span class="number">6.</span> org.springframework.context.support.AbstractXmlApplicationContext#</span><br><span class="line">loadBeanDefinitions(org.springframework.beans.factory.xml.XmlBeanDefinitionReader)</span><br><span class="line"><span class="number">7.</span> org.springframework.beans.factory.support.AbstractBeanDefinitionReader#</span><br><span class="line">loadBeanDefinitions(org.springframework.core.io.Resource...)</span><br><span class="line"><span class="number">8.</span> org.springframework.beans.factory.xml.XmlBeanDefinitionReader#</span><br><span class="line">loadBeanDefinitions(org.springframework.core.io.Resource)</span><br><span class="line"><span class="number">9.</span> org.springframework.beans.factory.xml.XmlBeanDefinitionReader#</span><br><span class="line">loadBeanDefinitions(org.springframework.core.io.support.EncodedResource)</span><br><span class="line"><span class="number">10.</span> org.springframework.beans.factory.xml.XmlBeanDefinitionReader#</span><br><span class="line">doLoadBeanDefinitions</span><br><span class="line"><span class="number">11.</span> org.springframework.beans.factory.xml.XmlBeanDefinitionReader#</span><br><span class="line">registerBeanDefinitions</span><br><span class="line"><span class="number">12.</span> org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#</span><br><span class="line">registerBeanDefinitions</span><br><span class="line"><span class="number">13.</span> org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#</span><br><span class="line">doRegisterBeanDefinitions</span><br><span class="line"><span class="number">14.</span> org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#</span><br><span class="line">parseBeanDefinitions</span><br><span class="line"><span class="number">15.</span> org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#</span><br><span class="line">parseDefaultElement</span><br><span class="line"><span class="number">16.</span> org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#</span><br><span class="line">processBeanDefinition</span><br><span class="line"><span class="number">17.</span> org.springframework.beans.factory.support.BeanDefinitionReaderUtils#</span><br><span class="line">registerBeanDefinition</span><br><span class="line"><span class="number">18.</span> org.springframework.beans.factory.support.DefaultListableBeanFactory#</span><br><span class="line">registerBeanDefinition</span><br></pre></td></tr></table></figure><h4 id="For-Annotation"><a href="#For-Annotation" class="headerlink" title="For Annotation"></a>For <code>Annotation</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id = <span class="string">&quot;sss&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;simpleBeans&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(<span class="string">&quot;com.itliusir.spring.beans.annotation&quot;</span>);</span><br><span class="line">    SimpleBean simpleBean = applicationContext.getBean(SimpleBean.class);</span><br><span class="line">    log.info(simpleBean.getId());</span><br><span class="line">    log.info(simpleBean.getName());</span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;sss&quot;</span>, simpleBean.getId());</span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;simpleBeans&quot;</span>, simpleBean.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> org.springframework.context.annotation.AnnotationConfigApplicationContext#</span><br><span class="line">AnnotationConfigApplicationContext(java.lang.String...)</span><br><span class="line"><span class="number">2.</span> org.springframework.context.annotation.AnnotationConfigApplicationContext#</span><br><span class="line">scan</span><br><span class="line"><span class="number">3.</span> org.springframework.context.annotation.ClassPathBeanDefinitionScanner#</span><br><span class="line">scan</span><br><span class="line"><span class="number">4.</span> org.springframework.context.annotation.ClassPathBeanDefinitionScanner#</span><br><span class="line">doScan</span><br><span class="line"><span class="number">5.</span> org.springframework.context.annotation.ClassPathBeanDefinitionScanner#</span><br><span class="line">registerBeanDefinition</span><br><span class="line"><span class="number">6.</span> org.springframework.beans.factory.support.BeanDefinitionReaderUtils#</span><br><span class="line">registerBeanDefinition</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="BeanDefinition-–-gt-Object"><a href="#BeanDefinition-–-gt-Object" class="headerlink" title="BeanDefinition –&gt; Object"></a><code>BeanDefinition</code> –&gt; <code>Object</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> org.springframework.beans.factory.BeanFactory#</span><br><span class="line">getBean(java.lang.String)</span><br><span class="line"><span class="number">2.</span> org.springframework.beans.factory.support.AbstractBeanFactory#</span><br><span class="line">doGetBean</span><br><span class="line"><span class="number">3.</span> org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#</span><br><span class="line">createBean(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition, java.lang.Object[])</span><br><span class="line"><span class="number">4.</span> org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#</span><br><span class="line">createBean(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition, java.lang.Object[])</span><br><span class="line"><span class="number">5.</span> org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#</span><br><span class="line">doCreateBean</span><br></pre></td></tr></table></figure><h4 id="CreateBeanInstance"><a href="#CreateBeanInstance" class="headerlink" title="CreateBeanInstance"></a><code>CreateBeanInstance</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#</span><br><span class="line">createBeanInstance</span><br><span class="line"><span class="number">2.</span> org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#</span><br><span class="line">instantiateBean</span><br></pre></td></tr></table></figure><h4 id="PopulateBean"><a href="#PopulateBean" class="headerlink" title="PopulateBean"></a><code>PopulateBean</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#</span><br><span class="line">populateBean</span><br></pre></td></tr></table></figure><h4 id="InitializeBean"><a href="#InitializeBean" class="headerlink" title="InitializeBean"></a><code>InitializeBean</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#</span><br><span class="line">initializeBean(java.lang.String, java.lang.Object, org.springframework.beans.factory.support.RootBeanDefinition)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ioc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Spring Event解耦业务开发</title>
      <link href="/2018/Spring%20Boot-Spring%20Event/"/>
      <url>/2018/Spring%20Boot-Spring%20Event/</url>
      
        <content type="html"><![CDATA[<p>摘要: 使用Spring Event解耦业务开发</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文:"></a>正文:</h2><h2 id="使用Spring-Event解耦业务开发"><a href="#使用Spring-Event解耦业务开发" class="headerlink" title="使用Spring Event解耦业务开发"></a>使用Spring Event解耦业务开发</h2><h3 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h3><p>事件驱动模型通常被理解为<strong>观察者模式</strong>或者<strong>发布-订阅模型</strong></p><p>Spring 事件是观察者模式的一种体现，对象间的一对多关系，被观察者发出信号时候会通知监听该事件的观察者；而发布-订阅模型往往需要一个调度中心，如消息队列等</p><p><img src="http://qiniu.itliusir.com/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F1.png" alt="观察者模式"></p><h3 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h3><ul><li><strong>用户注册</strong></li><li><strong>发短信/确认邮件</strong></li><li><strong>送新人优惠券</strong></li><li><strong>送抽奖</strong></li><li>….</li></ul><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p><strong>主流程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册</span></span><br><span class="line">userMapper.saveUser(user);</span><br><span class="line"><span class="comment">//发确认邮件</span></span><br><span class="line">sendEmail(String email);</span><br><span class="line"><span class="comment">//发短信</span></span><br><span class="line">sendMessage(String mobile);</span><br><span class="line"><span class="comment">//送优惠券</span></span><br><span class="line">sendCoupon(String userId);</span><br><span class="line"><span class="comment">//送抽奖机会</span></span><br><span class="line">sendLottery(String userId);</span><br><span class="line"><span class="comment">//各种活动...</span></span><br><span class="line">send...();</span><br></pre></td></tr></table></figure><blockquote><p>尽管我们方法抽象的很好，但是当这种事件(注册后续操作)越来越多时，主方法就会显得很乱，并且随着业务需求的变化，这个维护起来也很麻烦</p></blockquote><h3 id="改进版"><a href="#改进版" class="headerlink" title="改进版"></a>改进版</h3><p><strong>主流程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册</span></span><br><span class="line">userMapper.saveUser(user);</span><br><span class="line"><span class="comment">//发送注册成功事件</span></span><br><span class="line">publisher.publishEvent(<span class="keyword">new</span> UserRegisterEvent(user));</span><br></pre></td></tr></table></figure><p><strong>注册事件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserRegisterEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">4829855648590354032L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserRegisterEvent</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (User) source;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不同监听</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发短信监听</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">UserRegisterEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(UserRegisterEvent event)</span> </span>&#123;</span><br><span class="line">    sendMessage(event.getUser().getMobile());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//发优惠券监听</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CouponListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">UserRegisterEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(UserRegisterEvent event)</span> </span>&#123;</span><br><span class="line">    sendCoupon(event.getUser().getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...监听</span></span><br></pre></td></tr></table></figure><h3 id="同步-OR-异步"><a href="#同步-OR-异步" class="headerlink" title="同步 OR 异步"></a>同步 OR 异步</h3><p>Spring 事件既可以同步又可以异步，对于重要的业务最好采用同步方式，对于不重要的或不希望其阻塞主线程从而导致响应变慢可以采用异步方式</p><h4 id="同步-default"><a href="#同步-default" class="headerlink" title="同步(default)"></a>同步(default)</h4><p>监听会加入到主线程的事务中，可以通过Order来调整bean装配的优先级来实现监听的执行顺序</p><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>需要配置线程池来实现，顺序无法保证</p><blockquote><p>综上所述，Spring 事件主要还是对代码层面的解耦</p></blockquote><h3 id="Spring-Event-实现细节"><a href="#Spring-Event-实现细节" class="headerlink" title="Spring Event 实现细节"></a>Spring Event 实现细节</h3><blockquote><p>Source: 4.2</p></blockquote><p>以 <code>publisher.publishEvent()</code> 为入口</p><p><code>org.springframework.context.support.AbstractApplicationContext#publishEvent(java.lang.Object, org.springframework.core.ResolvableType)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event, ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果是ApplicationEvent类型对象</span></span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationEvent类型对象) &#123;</span><br><span class="line">        applicationEvent = (ApplicationEvent) event;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则就new一个PayloadApplicationEvent</span></span><br><span class="line">        applicationEvent = <span class="keyword">new</span> PayloadApplicationEvent&lt;Object&gt;(<span class="keyword">this</span>, event);</span><br><span class="line">        <span class="keyword">if</span> (eventType == <span class="keyword">null</span>) &#123;</span><br><span class="line">            eventType = ((PayloadApplicationEvent)applicationEvent).getResolvableType();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Multicast right now if possible - or lazily once the multicaster is initialized</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationEvents != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.earlyApplicationEvents.add(applicationEvent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//实际执行是委托给ApplicationEventMulticaster</span></span><br><span class="line">        getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="同步or-异步"><a href="#同步or-异步" class="headerlink" title="同步or 异步"></a>同步or 异步</h4><p><code>org.springframework.context.event.SimpleApplicationEventMulticaster#multicastEvent(org.springframework.context.ApplicationEvent, org.springframework.core.ResolvableType)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">ResolvableType type = (eventType != <span class="keyword">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">final</span> ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">Executor executor = getTaskExecutor();</span><br><span class="line"><span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">invokeListener(listener, event);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">invokeListener(listener, event);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><code>org.springframework.context.support.AbstractApplicationContext#refresh</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    initApplicationEventMulticaster();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.springframework.context.support.AbstractApplicationContext#initApplicationEventMulticaster</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationEventMulticaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="comment">//手动实现了名称为applicationEventMulticaster的bean</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//否则就默认自定义一个名称为SimpleApplicationEventMulticaster的监听器容器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p><a href="https://github.com/itliusir/Spring-Event-Demo">Spring-Event-Demo</a></p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> Springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> event </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMM学习笔记</title>
      <link href="/2018/jvm-JMM/"/>
      <url>/2018/jvm-JMM/</url>
      
        <content type="html"><![CDATA[<p>摘要:JMM学习笔记</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文:"></a>正文:</h2><h2 id="Java-Memory-Model"><a href="#Java-Memory-Model" class="headerlink" title="Java Memory Model"></a>Java Memory Model</h2><h3 id="未同步的程序的行为"><a href="#未同步的程序的行为" class="headerlink" title="未同步的程序的行为"></a>未同步的程序的行为</h3><p><img src="http://qiniu.itliusir.com/%E9%87%8D%E6%8E%92%E5%BA%8F.png" alt="语句重排序"></p><p>如上面例子所示</p><p>有 A B 两个共享变量，r1 r2 两个局部变量 </p><p>要出现 **May observer r2 == 2，r1 == 1 ** 线程执行顺序应该是如下所示：</p><p><em>Thread 1：B=1</em><br><em>Thread 2：r1=B</em><br><em>Thread 2：A=2</em><br><em>Thread 1：r2=A</em></p><blockquote><p>而按照程序员视角看第一个原始指令与实际的结果，可能会感觉很困惑，其根本原因是Java 的语义允许编译器和微处理器进行优化，这则会影响<strong>未正确同步的代码的行为</strong> (如上代码是未同步的)。</p></blockquote><h3 id="非正式语义"><a href="#非正式语义" class="headerlink" title="非正式语义"></a>非正式语义</h3><p>看一个程序是否被正确的同步有两个关键概念</p><p><strong>冲突访问</strong></p><p>对共享元素存在数据竞争场景，如上文中的未同步程序的行为</p><p><strong>Happens-Before 关系</strong></p><p><code>happens-before</code> 关系可以对两个动作进行排序，如果一个动作 <code>happens-before</code> 另一个动作，则第一个对第二个可见，且第一个排在第二个之前。必须强调的是，两个动作之间存在 <code>happens-before</code> 关系并不意味着这些动作在Java中必须以这种顺序发生。<code>happens-before</code> 关系主要用于强调两个有冲突的动作之间的顺序，以及定义数据争用的发生时机</p><blockquote><p> 如果某个动作A <code>happens-before</code> 动作B，且B <code>happens-before</code> 动作C，则有A <code>happens-before</code> C</p></blockquote><h4 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h4><p>顺序一致性是程序执行过程中可见性和顺序的强有力保证，在顺序一致性内存模型中，每个操作都必须是原子执行且对所有线程可见</p><h4 id="final-字段"><a href="#final-字段" class="headerlink" title="final 字段"></a>final 字段</h4><p>声明为 final 的字段在 <strong>对象完全初始化后的时刻</strong> 值是不可变的，所以 final 字段也允许编程人员在不需要同步的情况下实现线程安全的不可变对象</p><h3 id="什么是内存模型"><a href="#什么是内存模型" class="headerlink" title="什么是内存模型"></a>什么是内存模型</h3><p>内存模型可以看做为一组规则，规定了一个线程的写操作何时会对另一个线程可见</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><strong>Shared variables/Heap memory</strong></p><p>能够在线程间共享的内存称为共享内存或堆内存，所有的实例字段，静态字段以及数组元素都存储在堆内存中，方法中的局部变量永远不会在线程间共享且不会被内存模型影响</p><p><strong>Inter-thread Actions</strong></p><p>线程间的动作是某一个线程执行的动作能被另一个线程探测或影响，比如lock某个管城、读写volatile变量</p><blockquote><p>我们无需关心 <em>Intra-thread</em> 动作(线程内部) ，每个单线程需要遵守正确的 <em>Intra-thread semantics</em></p></blockquote><p><strong>Intra-thread semantics</strong></p><p>线程内语义是单线程程序的标准语义，线程内语义决定着某个线程孤立的执行过程，当从堆中读取值时，值是由内存模型决定的</p><p><strong>Synchronization Actions</strong></p><p>同步动作包括锁、解锁、读写 volatile 变量等动作</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JMM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 核心特性之组件自动装配</title>
      <link href="/2018/Spring%20Boot-AutoConfiguration/"/>
      <url>/2018/Spring%20Boot-AutoConfiguration/</url>
      
        <content type="html"><![CDATA[<p>摘要: Spring Boot 核心特性之组件自动装配</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文:"></a>正文:</h2><h2 id="Spring-Boot-核心特性之组件自动装配"><a href="#Spring-Boot-核心特性之组件自动装配" class="headerlink" title="Spring Boot 核心特性之组件自动装配"></a>Spring Boot 核心特性之组件自动装配</h2><h3 id="Spring-Framework-手动装配"><a href="#Spring-Framework-手动装配" class="headerlink" title="Spring Framework 手动装配"></a>Spring Framework 手动装配</h3><h4 id="模式注解装配"><a href="#模式注解装配" class="headerlink" title="模式注解装配"></a>模式注解装配</h4><ul><li><strong>ex：<code>@Component</code>、<code>@Service</code>、<code>@Configuration</code>…</strong></li><li><strong>装配方式：<code>&lt;context:componet-scan&gt;</code>或<code>@ComponentScan</code></strong></li></ul><blockquote><p><code>@Component</code>是一种由Spring 容器托管的通用模式组件</p></blockquote><table><thead><tr><th align="center">Spring Framework 注解</th><th align="center">场景</th><th align="center">version</th></tr></thead><tbody><tr><td align="center"><code>@Repository</code></td><td align="center">数据仓储模式注解</td><td align="center">2.0</td></tr><tr><td align="center"><code>@Component</code></td><td align="center">通用组件模式注解</td><td align="center">2.5</td></tr><tr><td align="center"><code>@Service</code></td><td align="center">服务模式注解</td><td align="center">2.5</td></tr><tr><td align="center"><code>@Controller</code></td><td align="center">Web 控制器模式注解</td><td align="center">2.5</td></tr><tr><td align="center"><code>@Configuration</code></td><td align="center">配置类模式注解</td><td align="center">3.0</td></tr></tbody></table><ul><li><strong>自定义模式注解</strong></li></ul><blockquote><p>“派生性”(“基注解”&lt;”派生注解”)，可以参考以上注解实现自定义注解：</p><p><code>@Component</code>&lt;<code>@Repository</code>&lt;<code>CustomRepository</code></p></blockquote><h4 id="Enable-模块装配"><a href="#Enable-模块装配" class="headerlink" title="@Enable 模块装配"></a>@Enable 模块装配</h4><p>Spring Framework从3.1开始支持<code>@Enable 模块驱动</code> ，模块是指具备相同领域的功能组件集合组合成为一个独立的单元</p><p><strong>举例：</strong></p><table><thead><tr><th align="center">@Enable 注解模块</th><th align="center">模块说明</th></tr></thead><tbody><tr><td align="center"><code>@EnableWebMvc</code></td><td align="center">Web MVC模块</td></tr><tr><td align="center"><code>@EnableAsync</code></td><td align="center">异步处理模块</td></tr><tr><td align="center"><code>@EnableAutoConfiguration</code></td><td align="center">自动配置模块</td></tr><tr><td align="center"><code>@EnableEurekaClient</code></td><td align="center">Eureka Client模块</td></tr></tbody></table><ul><li><p><strong>注解驱动方式</strong></p><p><strong>version：3.0</strong></p><p><strong>举例：</strong></p><p><code>org.springframework.web.servlet.config.annotation.EnableWebMvc</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(DelegatingWebMvcConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableWebMvc &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>org.springframework.web.servlet.config.annotation.DelegatingWebMvcConfiguration</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatingWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>接口编程方式</strong></p><p><strong>version：3.1</strong></p><p><strong>举例：</strong></p><p><code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(EnableAutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>org.springframework.boot.autoconfigure.EnableAutoConfigurationImportSelector</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnableAutoConfigurationImportSelector</span></span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">AutoConfigurationImportSelector</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoConfigurationImportSelector</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">DeferredImportSelector</span>, <span class="title">BeanClassLoaderAware</span>, <span class="title">ResourceLoaderAware</span>,</span></span><br><span class="line"><span class="class"><span class="title">BeanFactoryAware</span>, <span class="title">EnvironmentAware</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="条件装配"><a href="#条件装配" class="headerlink" title="条件装配"></a>条件装配</h4><p>Spring Framework从3.1开始支持在Bean 装配时增加前置条件判断</p><ul><li><p><strong>@Profile 配置化方式条件装配</strong></p><p><strong>version：3.1</strong></p><p><strong>举例：</strong></p><ul><li><strong>class</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile(&quot;development&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandaloneDataConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile(&quot;production&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JndiDataConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>method</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;dataSource&quot;)</span></span><br><span class="line">    <span class="meta">@Profile(&quot;development&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">standaloneDataSource</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;dataSource&quot;)</span></span><br><span class="line">    <span class="meta">@Profile(&quot;production&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">jndiDataSource</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>激活</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">ctx.getEnvironment().setActiveProfiles(<span class="string">&quot;development&quot;</span>);</span><br><span class="line">ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);</span><br><span class="line">ctx.refresh();</span><br></pre></td></tr></table></figure></li><li><p><strong>@Conditional 编程方式条件装配</strong></p><p><strong>version：4.0</strong></p><p><strong>举例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Conditional(OnClassCondition.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConditionalOnClass &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>Spring-Boot的@Conditional：</strong></p><ul><li><em>ConditionalOnBean</em></li><li><em>ConditionalOnMissingBean</em></li><li><em>ConditionalOnClass</em></li><li><em>ConditionalOnMissingClass</em></li><li><em>ConditionalOnProperty</em></li><li><em>ConditionalOnJava</em></li><li><em>ConditionalOnWebApplication</em></li></ul></li></ul><h3 id="Spring-Boot-自动装配"><a href="#Spring-Boot-自动装配" class="headerlink" title="Spring Boot 自动装配"></a>Spring Boot 自动装配</h3><ul><li><p><strong>激活：<code>@EnableAutoConfiguration</code></strong></p><blockquote><p>Spring Boot 默认没有激活自动装配，存在<code>@SpringBootApplication</code>注解中</p><p>参考:org.springframework.boot.autoconfigure.AutoConfigurationImport</p><p>Selector#getCandidateConfigurations</p></blockquote></li><li><p><strong>配置：<code>/META-INF/spring.factories</code></strong></p><blockquote><p>规约文件，<code>META-INFO</code>指的是元信息目录，如<code>spring.handlers</code>、<code>spring.schemas</code>等</p><p>参考:<code>org.springframework.core.io.support.SpringFactoriesLoader</code></p></blockquote></li><li><p><strong>实现：<code>XxxAutoConfiguration</code></strong></p><blockquote><p>ex: <code>org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration</code></p></blockquote></li></ul><h3 id="Demo-Spring-Boot-Starter"><a href="#Demo-Spring-Boot-Starter" class="headerlink" title="Demo-Spring-Boot-Starter"></a>Demo-Spring-Boot-Starter</h3><p><a href="https://github.com/itliusir/demo-spring-boot-starter">Demo-Spring-Boot-Starter</a></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="ImportSelector部分"><a href="#ImportSelector部分" class="headerlink" title="ImportSelector部分"></a><code>ImportSelector</code>部分</h4><p><code>org.springframework.boot.autoconfigure.AutoConfigurationImportSelector#selectImports</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line"><span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line"><span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//加载spring-boot-autoconfigure-1.5.6.RELEASE.jar!\META-INF\spring-autoconfigure-metadata.properties</span></span><br><span class="line">AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader</span><br><span class="line">.loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">           <span class="comment">//获取EnableAutoConfiguration里的exclude和excludeName--&gt;LinkedHashMap--&gt;AnnotationAttributes</span></span><br><span class="line">AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">             <span class="comment">//获取依赖里所有的xx.jar!\META-INF\spring.factories的value</span></span><br><span class="line">List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,</span><br><span class="line">attributes);</span><br><span class="line">             <span class="comment">//利用Set去重</span></span><br><span class="line">configurations = removeDuplicates(configurations);</span><br><span class="line">             <span class="comment">//排序-&gt;先按照字母排序-&gt;再按照Order排序(ex:MessageSourceAutoConfiguration#@AutoConfigureOrder)-&gt;然后根据@AutoConfigureBefore @AutoConfigureAfter(ex:WebSocketAutoConfiguration#@AutoConfigureBefore)排序</span></span><br><span class="line">configurations = sort(configurations, autoConfigurationMetadata);</span><br><span class="line">             <span class="comment">//对attributes封装与去重得到exclusions</span></span><br><span class="line">Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">checkExcludedClasses(configurations, exclusions);</span><br><span class="line">             <span class="comment">//去掉exclusions里的XxAutoConf...</span></span><br><span class="line">configurations.removeAll(exclusions);</span><br><span class="line">             <span class="comment">//加载过滤器，对不满足ex:默认有一个OnClassCondition(org.springframework.boot.autoconfigure.AutoConfigurationImportSelector#getAutoConfigurationImportFilters()，见下图)的会排除掉()</span></span><br><span class="line">configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line"><span class="keyword">return</span> configurations.toArray(<span class="keyword">new</span> String[configurations.size()]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://qiniu.itliusir.com/importFilter.png" alt="importFilter"></p><h4 id="调用ImportSelector部分"><a href="#调用ImportSelector部分" class="headerlink" title="调用ImportSelector部分"></a>调用<code>ImportSelector</code>部分</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors</span><br><span class="line"></span><br><span class="line">org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry</span><br><span class="line"></span><br><span class="line">org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions</span><br><span class="line"></span><br><span class="line">org.springframework.context.annotation.ConfigurationClassParser#parse(java.util.Set&lt;org.springframework.beans.factory.config.BeanDefinitionHolder&gt;)</span><br><span class="line"></span><br><span class="line">org.springframework.context.annotation.ConfigurationClassParser#processDeferredImportSelectors</span><br><span class="line"></span><br><span class="line">String[] imports = deferredImport.getImportSelector().selectImports(configClass.getMetadata());</span><br><span class="line">processImports(configClass, asSourceClass(configClass), asSourceClasses(imports), <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> Springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> autoconfig </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker Notes-storage</title>
      <link href="/2018/Docker%20Notes-storage/"/>
      <url>/2018/Docker%20Notes-storage/</url>
      
        <content type="html"><![CDATA[<p>摘要: Docker Notes系列为学习Docker笔记，本文是Docker存储介绍</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文:"></a>正文:</h2><h2 id="Docker-存储管理"><a href="#Docker-存储管理" class="headerlink" title="Docker 存储管理"></a>Docker 存储管理</h2><h3 id="Docker-镜像元数据管理"><a href="#Docker-镜像元数据管理" class="headerlink" title="Docker 镜像元数据管理"></a>Docker 镜像元数据管理</h3><p>由上篇文章的镜像管理可知Docker以分层形式存储镜像，元数据与镜像文件的存储也是完全隔离开来</p><h4 id="repository-元数据"><a href="#repository-元数据" class="headerlink" title="repository 元数据"></a>repository 元数据</h4><p>repository 由具有某个功能的Docker镜像的所有迭代版本构成的镜像库，其本地持久化文件存放于<code>/var/lib/docker/image/&#123;Storage Driver&#125;/repositories.json</code>中，结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@cf /]# docker info | grep &#x27;Storage Driver&#x27;</span><br><span class="line">Storage Driver: overlay2</span><br><span class="line">[root@cf /]# cat /var/lib/docker/image/overlay2/repositories.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;Repositories&quot;: &#123;</span><br><span class="line">    &quot;busybox&quot;: &#123;</span><br><span class="line">      &quot;busybox:latest&quot;: &quot;sha256:8c811b4aec35f259572d0f79207bc0678df4c736eeec50bc9fec37ed936a472a&quot;,</span><br><span class="line">      &quot;busybox:test&quot;: &quot;sha256:357bb11d2c366a4c60bcb20580407694f2f66f091452c8680dadf2761dc3cba0&quot;,</span><br><span class="line">      &quot;busybox@sha256:141c253bc4c3fd0a201d32dc1f493bcf3fff003b6df416dea4f41046e0f37d47&quot;: &quot;sha256:8c811b4aec35f259572d0f79207bc0678df4c736eeec50bc9fec37ed936a472a&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;centos&quot;: &#123;</span><br><span class="line">      &quot;centos:7&quot;: &quot;sha256:49f7960eb7e4cb46f1a02c1f8174c6fac07ebf1eb6d8deffbcb5c695f1c9edd5&quot;,</span><br><span class="line">      &quot;centos@sha256:b67d21dfe609ddacf404589e04631d90a342921e81c40aeaf3391f6717fa5322&quot;: &quot;sha256:49f7960eb7e4cb46f1a02c1f8174c6fac07ebf1eb6d8deffbcb5c695f1c9edd5&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Docker 默认采用SHA256算法根据镜像元数据配置文件计算出镜像ID</p></blockquote><h4 id="image-元数据"><a href="#image-元数据" class="headerlink" title="image 元数据"></a>image 元数据</h4><p>image 元数据包括了如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">[root@cf /]# cat /var/lib/docker/image/overlay2/imagedb/content/sha256/8c811b4aec35f25...</span><br><span class="line">&#123;</span><br><span class="line">  &quot;architecture&quot;: &quot;amd64&quot;,</span><br><span class="line">  &quot;config&quot;: &#123;</span><br><span class="line">    &quot;Hostname&quot;: &quot;&quot;,</span><br><span class="line">    &quot;Domainname&quot;: &quot;&quot;,</span><br><span class="line">    &quot;User&quot;: &quot;&quot;,</span><br><span class="line">    &quot;AttachStdin&quot;: false,</span><br><span class="line">    &quot;AttachStdout&quot;: false,</span><br><span class="line">    &quot;AttachStderr&quot;: false,</span><br><span class="line">    &quot;Tty&quot;: false,</span><br><span class="line">    &quot;OpenStdin&quot;: false,</span><br><span class="line">    &quot;StdinOnce&quot;: false,</span><br><span class="line">    &quot;Env&quot;: [</span><br><span class="line">      &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;Cmd&quot;: [</span><br><span class="line">      &quot;sh&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;ArgsEscaped&quot;: true,</span><br><span class="line">    &quot;Image&quot;: &quot;sha256:3e8a1c5213eb57c6ea8ddb27d86a241698741ce60d9053b641f57a7e455f6842&quot;,</span><br><span class="line">    &quot;Volumes&quot;: null,</span><br><span class="line">    &quot;WorkingDir&quot;: &quot;&quot;,</span><br><span class="line">    &quot;Entrypoint&quot;: null,</span><br><span class="line">    &quot;OnBuild&quot;: null,</span><br><span class="line">    &quot;Labels&quot;: null</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;container&quot;: &quot;617bfbb850a66642161d4925e0c00f77caa46e22057409788207e7b2edb86c3e&quot;,</span><br><span class="line">  &quot;container_config&quot;: &#123;</span><br><span class="line">    &quot;Hostname&quot;: &quot;617bfbb850a6&quot;,</span><br><span class="line">    &quot;Domainname&quot;: &quot;&quot;,</span><br><span class="line">    &quot;User&quot;: &quot;&quot;,</span><br><span class="line">    &quot;AttachStdin&quot;: false,</span><br><span class="line">    &quot;AttachStdout&quot;: false,</span><br><span class="line">    &quot;AttachStderr&quot;: false,</span><br><span class="line">    &quot;Tty&quot;: false,</span><br><span class="line">    &quot;OpenStdin&quot;: false,</span><br><span class="line">    &quot;StdinOnce&quot;: false,</span><br><span class="line">    &quot;Env&quot;: [</span><br><span class="line">      &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;Cmd&quot;: [</span><br><span class="line">      &quot;/bin/sh&quot;,</span><br><span class="line">      &quot;-c&quot;,</span><br><span class="line">      &quot;#(nop) &quot;,</span><br><span class="line">      &quot;CMD [\&quot;sh\&quot;]&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;ArgsEscaped&quot;: true,</span><br><span class="line">    &quot;Image&quot;: &quot;sha256:3e8a1c5213eb57c6ea8ddb27d86a241698741ce60d9053b641f57a7e455f6842&quot;,</span><br><span class="line">    &quot;Volumes&quot;: null,</span><br><span class="line">    &quot;WorkingDir&quot;: &quot;&quot;,</span><br><span class="line">    &quot;Entrypoint&quot;: null,</span><br><span class="line">    &quot;OnBuild&quot;: null,</span><br><span class="line">    &quot;Labels&quot;: &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;created&quot;: &quot;2018-05-23T21:19:31.132152818Z&quot;,</span><br><span class="line">  &quot;docker_version&quot;: &quot;17.06.2-ce&quot;,</span><br><span class="line">  &quot;history&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;created&quot;: &quot;2018-05-23T21:19:30.902651601Z&quot;,</span><br><span class="line">      &quot;created_by&quot;: &quot;/bin/sh -c #(nop) ADD file:5f0439d8328ab58c087cd067c91ce92765da98916d91b083df6590477b7b9f19 in / &quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;created&quot;: &quot;2018-05-23T21:19:31.132152818Z&quot;,</span><br><span class="line">      &quot;created_by&quot;: &quot;/bin/sh -c #(nop)  CMD [\&quot;sh\&quot;]&quot;,</span><br><span class="line">      &quot;empty_layer&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;os&quot;: &quot;linux&quot;,</span><br><span class="line">  &quot;rootfs&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;layers&quot;,</span><br><span class="line">    &quot;diff_ids&quot;: [</span><br><span class="line">      &quot;sha256:432b65032b9466b4dadcc5c7b11701e71d21c18400aae946b101ad16be62333a&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="layer元数据"><a href="#layer元数据" class="headerlink" title="layer元数据"></a>layer元数据</h4><p>由上文可知layer负责与镜像层和容器层元数据有关的增删改查，并将其增删改查操作映射到实际存储镜像层文件系统的graphdriver模块。</p><p>用户在Docker宿主机上下载了某个镜像层之后，Docker会在宿主机上基于镜像层文件包和image元数据，构建本地的layer元数据，如diff、size等，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@cf /]# cat /var/lib/docker/image/overlay2/layerdb/sha256/432b65032b9466b4d.../</span><br><span class="line">cache-id           diff               size               tar-split.json.gz</span><br></pre></td></tr></table></figure><h3 id="Docker-存储驱动"><a href="#Docker-存储驱动" class="headerlink" title="Docker 存储驱动"></a>Docker 存储驱动</h3><p>为了支持镜像的分层(只读层、读写层)与写时复制等特性，Docker提供了存储驱动的接口。存储驱动根据操作系统底层的支持提供了针对某种文件系统的初始化操作以及对镜像层的增删改查和差异比较等操作</p><h4 id="常用存储驱动"><a href="#常用存储驱动" class="headerlink" title="常用存储驱动"></a>常用存储驱动</h4><ol><li><p><strong>aufs</strong></p><p>aufs是一种支持联合挂载的文件系统，相当于讲不同目录挂载到同一目录下，这些目录的挂载是分层次的，每一层都是一个普通的文件系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@cf /]# cd /var/lib/docker/aufs</span><br></pre></td></tr></table></figure></li><li><p><strong>device mapper</strong></p><p>device mapper是Linux 2.6内核中提供的一种从逻辑设备到物理设备的映射框架机制，用户可以很方便地根据自己的需要制定实现存储资源的管理策略</p><p>device mapper 本质功能就是根据映射关系描述IO处理规则，当映射设备接收到IO请求的时候，这个IO请求会根据映射表逐级转发，直到这个请求最终传到最底层的物理设备上</p><p><img src="http://qiniu.itliusir.com/device%20mapper.png" alt="device mapper"></p><p>如上图所示，映射设备是内核向外提供的逻辑设备，而目标设备即可以是物理设备也可以同样是映射设备</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@cf /]# cd /var/lib/docker/devicemapper</span><br></pre></td></tr></table></figure></li><li><p><strong>overlay</strong></p><p>overlayFS是一种新型联合文件系统，它允许用户将一个文件系统与另一个文件系统重叠(overlay)，在上层的文件系统中记录更改，而下层的文件系统保持不变</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@cf overlay2]# tree -L 2</span><br><span class="line">.</span><br><span class="line">├── 05f14d2b45bfa0ff20f...</span><br><span class="line">│   ├── diff</span><br><span class="line">│   ├── link</span><br><span class="line">│   ├── lower</span><br><span class="line">│   └── work</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker storage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker Notes-architecture</title>
      <link href="/2018/Docker%20Notes-architecture/"/>
      <url>/2018/Docker%20Notes-architecture/</url>
      
        <content type="html"><![CDATA[<p>摘要: Docker Notes系列为学习Docker笔记，本文是Docker架构介绍</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文:"></a>正文:</h2><h2 id="Docker-架构"><a href="#Docker-架构" class="headerlink" title="Docker 架构"></a>Docker 架构</h2><p>Docker 使用了传统的CS架构模式，用户通过Docker client与Docker daemon建立通信，并将请求发送给后者</p><p><img src="http://qiniu.itliusir.com/docker.png" alt="Docker Architecture"></p><h3 id="Docker-client"><a href="#Docker-client" class="headerlink" title="Docker client"></a>Docker client</h3><p>Docker Client是Docker架构中用户用来与Docker Daemon建立通信的客户端，可以是命令行工具docker，也可以是任何遵循Docker API的客户端</p><h3 id="Docker-daemon"><a href="#Docker-daemon" class="headerlink" title="Docker daemon"></a>Docker daemon</h3><p>Docker daemon 是Docker 架构中的主要接口，它提供了API Server用于接收Docker client的请求，然后根据不同请求分发给Docker daemon的不同模块执行相应的工作。</p><p>为了将这些系统调用抽象成为统一的操作接口方便调用者使用，Docker把这些操作分为了容器执行驱动、volume存储驱动、镜像存储驱动三种，对应下面3个模块：</p><ul><li><strong>exec driver</strong>  对linux操作系统的namespaces、cgroups等容器运行所需的系统操作进行的二次封装，本质作用类似LXC(linux container)，但是功能要更全面，主要由Docker官方编写的libcontainer库实现</li><li><strong>volume driver</strong>  负责volume数据卷的增删改查，统一不同底层驱动的接口，Docker中的默认实现是local，将文件存储在某个目录下，其他volume driver均是通过外部插件实现的</li><li><strong>graph driver</strong>  用户对镜像的操作(见下文的 <strong>image management</strong> 中的 <strong>layer</strong> 模块)会被映射成对graph维护的目录文件操作，它也是所有与容器镜像相关操作的最终执行者</li><li><strong>network</strong>  网络由libnetwork库独立维护，libnetwork抽象出了一个容器网络模型，并给调用者提供了一个统一的抽象接口</li></ul><h3 id="Docker-image-management"><a href="#Docker-image-management" class="headerlink" title="Docker image management"></a>Docker image management</h3><p>由上图可知，镜像管理是通过多个模块来实现：</p><ul><li><strong>distribution</strong>  负责与Docker registry交互，上传下载镜像以及存储相关的元数据等</li><li><strong>registry</strong>  负责与Docker registry有关的身份认证、镜像查找、镜像验证、管理registry mirror等</li><li><strong>image</strong>  负责与镜像元数据有关的存储、查找、镜像层的索引、tar导入导出等</li><li><strong>reference</strong>  负责存储本地所有镜像的repository和tag名，并维护与ID之间的映射关系</li><li><strong>layer</strong>  负责与镜像层和容器层元数据有关的增删改查，并将其增删改查操作映射到实际存储镜像层文件系统的graphdriver模块</li></ul>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker Notes-introduction</title>
      <link href="/2018/Docker%20Notes-introduction/"/>
      <url>/2018/Docker%20Notes-introduction/</url>
      
        <content type="html"><![CDATA[<p>摘要: Docker Notes系列为学习Docker笔记，本文是Docker总体介绍</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文:"></a>正文:</h2><h1 id="Docker-介绍"><a href="#Docker-介绍" class="headerlink" title="Docker 介绍"></a>Docker 介绍</h1><h2 id="Centents"><a href="#Centents" class="headerlink" title="Centents"></a>Centents</h2><ul><li>容器介绍</li><li>Docker是什么</li><li>Docker 架构</li><li>Docker 镜像</li><li>Dockerfile</li><li>Docker Hub</li></ul><h2 id="容器介绍"><a href="#容器介绍" class="headerlink" title="容器介绍"></a>容器介绍</h2><p>没有规范指定容器应该是什么</p><p>LXC(Linux Container)是一种操作系统级虚拟化方法，用于使用单个Linux内核在主机上运行多个隔离的Linux系统（容器）</p><p>Linux内核提供cgroups功能，允许限制和优先化资源（CPU，内存，块I / O，网络等），而无需启动任何虚拟机，以及允许完全隔离应用程序视图的命名空间隔离功能 操作环境，包括进程树，网络，用户ID和已安装的文件系统</p><h3 id="namespaces"><a href="#namespaces" class="headerlink" title="namespaces"></a>namespaces</h3><p>Docker Engine在Linux上使用的一些命名空间是：</p><table><thead><tr><th>namespace</th><th>系统调用参数</th><th>隔离内容</th></tr></thead><tbody><tr><td>UTS</td><td><code>CLONE_NEWUTC</code></td><td>主机名与域名</td></tr><tr><td>IPC</td><td><code>CLONE_NEWIPC</code></td><td>信号量、消息队列、共享内存</td></tr><tr><td>PID</td><td><code>CLONE_NEWPID</code></td><td>进程编号</td></tr><tr><td>Network</td><td><code>CLONE_NEWNET</code></td><td>网络栈、端口</td></tr><tr><td>Mount</td><td><code>CLONE_NEWNS</code></td><td>文件系统</td></tr></tbody></table><h3 id="cgroups"><a href="#cgroups" class="headerlink" title="cgroups"></a>cgroups</h3><p>cgroups可以限制、记录、隔离进程组所使用的物理资源（包括：CPU、memory、IO等），为容器实现虚拟化提供了基本保证，是构建Docker等一系列虚拟化管理工具的基石</p><p>cgroups现在全称是control groups，它为每种可以控制的资源定义了一个子系统</p><ul><li><strong>blkio</strong>  可以限制块设备的输入输出，如磁盘、USB</li><li><strong>cpu</strong> 可以限制进程的cpu 使用率</li><li><strong>cpuacct</strong> 可以生成cpu 使用报告</li><li><strong>cpuset</strong> 可以为cgroups中进程分配独立的CPU和内存</li><li><strong>devices</strong> 可以控制进程对设备的访问</li><li><strong>freezer</strong> 可以对进程进行挂起或恢复</li><li><strong>memory</strong> 可以对进程的memory使用量进行限制，并生成内存资源使用情况报告</li><li><strong>perf_event</strong> 可以对进程进行统一的性能测试</li><li><strong>net_cls</strong> 可以使用classid标记网络包，然后Linux流量控制程序识别从具体cgroups中生成的数据包</li></ul><p><img src="http://qiniu.itliusir.com/ct%20vs%20vm.png"></p><h2 id="Docker-是什么"><a href="#Docker-是什么" class="headerlink" title="Docker 是什么"></a>Docker 是什么</h2><p><img src="http://qiniu.itliusir.com/pre-1960.png"></p><p><img src="http://qiniu.itliusir.com/matrix%20from%20hell.png"></p><p><img src="http://qiniu.itliusir.com/solution.png"></p><p>Docker 是一个linux 容器引擎，其开源项目第一个版本是由dotcloud公司在2013年3月发布，使用golang，一开始是基于LXC来创建的，现在使用libcontainer。从使用上来讲就像一个虚拟机</p><blockquote><p>Why Go?</p><ol><li>静态编译<ul><li>“go build”将嵌入你需要的一切(不需要安装别的东西以运行)</li><li>除了动态库，如果使用cgo(cgo 允许你使用任何c库)</li><li>除了libc(但谁没有libc？)，你可以有一个真正的静态二进制文件</li><li>更易于安装，更易于测试，更易于使用 </li></ul></li><li>符合我们的需求<ul><li>优良的异步原语</li><li>大量的标准库和数据类型</li></ul></li><li>完善的开发者环境</li></ol></blockquote><h2 id="Docker-架构"><a href="#Docker-架构" class="headerlink" title="Docker 架构"></a>Docker 架构</h2><p><img src="http://qiniu.itliusir.com/architecture.png"></p><h3 id="Docker-Client"><a href="#Docker-Client" class="headerlink" title="Docker Client"></a>Docker Client</h3><p>Docker Client是Docker架构中用户用来与Docker Daemon建立通信的客户端</p><h4 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h4><ul><li>tcp://host:port</li><li>unix://path_to_socket</li><li>fd://socketfd</li></ul><h4 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h4><ul><li>Docker程序运行时所需提供的参数，如-d</li><li>Docker发送给Docker Server的实际请求参数，如 ps、pull xxx等</li></ul><h3 id="Docker-Daemon"><a href="#Docker-Daemon" class="headerlink" title="Docker Daemon"></a>Docker Daemon</h3><p>Docker daemon 是Docker 架构中的主要接口，它提供了API Server用于接收Docker client的请求，然后根据不同请求分发给Docker daemon的不同模块执行相应的工作</p><h2 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h2><p>Docker 镜像是一个只读的Docker 容器模块，含有启动Docker容器所需的文件系统结构及其内容，是启动一个Docker 容器的基础，Docker 镜像是Docker容器的静态视角，Docker容器是Docker镜像的运行状态</p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>docker 可以根据Dockerfile来自动构建镜像，Dockerfile是一个文本文档，其中包含用户可以在命令行上调用的所有需要进行自动化构建的命令，如下是一个简单的springboot应用镜像的Dockerfile文件内容</p><p><strong>example</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM xxx.cn/jdk8:alpine</span><br><span class="line">VOLUME /tmp</span><br><span class="line">ADD ./target/demo.war /app/</span><br><span class="line">CMD [&quot;sh&quot;, &quot;-c&quot;, &quot;java $&#123;JAVA_OPTS&#125; -Djava.security.egd=file:/dev/./urandom -jar /app/demo.war $&#123;RUN_ARGS&#125;&quot;]</span><br><span class="line">EXPOSE 8888</span><br></pre></td></tr></table></figure><h2 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h2><p>docker hub是类似github(gayhub)的一个官方镜像仓库，可以根据需求pull自己需要的镜像，也可以push自己构建的镜像，在社会主义特色开发下企业往往使用自己搭建的私有镜像仓库，如harbor等</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.kancloud.cn/infoq/docker-source-code-analysis">Docker源码分析</a></p><p><a href="https://www.slideshare.net/adityakonarde/introduction-to-docker-63666306?qid=e1fdaa4e-4170-4f30-93c9-22c6c0eb8f98&v=&b=&from_search=9">Introduction to Docker</a></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dockerintro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker Notes-cgroups</title>
      <link href="/2018/Docker%20Notes-cgroups/"/>
      <url>/2018/Docker%20Notes-cgroups/</url>
      
        <content type="html"><![CDATA[<p>摘要: Docker Notes系列为学习Docker笔记，本文是学习cgroups 资源限制的笔记</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文:"></a>正文:</h2><p>上节我们了解了Docker背后的资源隔离技术namespace，本节介绍另一个内核工具cgroups。</p><h4 id="cgroups作用"><a href="#cgroups作用" class="headerlink" title="cgroups作用"></a>cgroups作用</h4><p>cgroups可以限制、记录、隔离进程组所使用的物理资源（包括：CPU、memory、IO等），为容器实现虚拟化提供了基本保证，是构建Docker等一系列虚拟化管理工具的基石</p><p>cgroups提供：</p><ul><li><p><strong>资源限制</strong></p><p>对进程组的资源使用限制，如对应用运行时使用内存的限制</p></li><li><p><strong>优先级</strong></p><p>通过分配CPU的时间片数量和磁盘IO带宽大小</p></li><li><p><strong>资源统计</strong></p><p>统计系统的资源使用量</p></li><li><p><strong>控制</strong></p><p>对进程组挂起、恢复、重启动等操作</p></li></ul><h4 id="cgroups子系统"><a href="#cgroups子系统" class="headerlink" title="cgroups子系统"></a>cgroups子系统</h4><p>cgroups现在全称是control groups，它为每种可以控制的资源定义了一个子系统</p><ul><li><p><strong>blkio</strong></p><p>可以限制块设备的输入输出，如磁盘、USB</p></li><li><p><strong>cpu</strong></p><p>可以限制进程的cpu 使用率</p></li><li><p><strong>cpuacct</strong></p><p>可以生成cpu 使用报告</p></li><li><p><strong>cpuset</strong></p><p>可以为cgroups中进程分配独立的CPU和内存</p></li><li><p><strong>devices</strong></p><p>可以控制进程对设备的访问</p></li><li><p><strong>freezer</strong></p><p>可以对进程进行挂起或恢复</p></li><li><p><strong>memory</strong></p><p>可以对进程的memory使用量进行限制，并生成内存资源使用情况报告</p></li><li><p><strong>perf_event</strong></p><p>可以对进程进行统一的性能测试</p></li><li><p><strong>net_cls</strong></p><p>可以使用classid标记网络包，然后Linux流量控制程序识别从具体cgroups中生成的数据包</p></li></ul><h4 id="docker组的层级结构"><a href="#docker组的层级结构" class="headerlink" title="docker组的层级结构"></a>docker组的层级结构</h4><p>docker daemon会在每个子系统的控制组目录下创建一个叫docker的控制组，在这个组里为每一个容器创建一个容器id命名的容器控制组</p><ul><li><strong>如cpu子系统层级结构</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@cf /]# tree /sys/fs/cgroup/cpu/docker</span><br><span class="line">/sys/fs/cgroup/cpu/docker</span><br><span class="line">├── 69aa00d7aa3b6654b63280e66b671f509a3019a032ec5a09e299b793b37c6775</span><br><span class="line">│   ├── cgroup.clone_children</span><br><span class="line">│   ├── cgroup.event_control</span><br><span class="line">│   ├── cgroup.procs</span><br><span class="line">│   ├── cpuacct.stat</span><br><span class="line">│   ├── cpuacct.usage</span><br><span class="line">│   ├── cpuacct.usage_percpu</span><br><span class="line">│   ├── cpu.cfs_period_us</span><br><span class="line">│   ├── cpu.cfs_quota_us</span><br><span class="line">│   ├── cpu.rt_period_us</span><br><span class="line">│   ├── cpu.rt_runtime_us</span><br><span class="line">│   ├── cpu.shares</span><br><span class="line">│   ├── cpu.stat</span><br><span class="line">│   ├── notify_on_release</span><br><span class="line">│   └── tasks</span><br><span class="line">├── cgroup.clone_children</span><br><span class="line">├── cgroup.event_control</span><br><span class="line">├── cgroup.procs</span><br><span class="line">├── cpuacct.stat</span><br><span class="line">├── cpuacct.usage</span><br><span class="line">├── cpuacct.usage_percpu</span><br><span class="line">├── cpu.cfs_period_us</span><br><span class="line">├── cpu.cfs_quota_us</span><br><span class="line">├── cpu.rt_period_us</span><br><span class="line">├── cpu.rt_runtime_us</span><br><span class="line">├── cpu.shares</span><br><span class="line">├── cpu.stat</span><br><span class="line">├── notify_on_release</span><br><span class="line">└── tasks</span><br></pre></td></tr></table></figure><ul><li><p><strong>一些文件的作用</strong></p><ul><li><p><code>tasks</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@cf 69aa00d7aa3b6654b63280e66b671f509a3019a032ec5a09e299b793b37c6775]# cat tasks </span><br><span class="line">29001</span><br><span class="line">29058</span><br><span class="line">29059</span><br><span class="line">29060</span><br></pre></td></tr></table></figure><p>该文件罗列了所有在该groups中的进程id</p></li><li><p><code>cgroup.procs</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@cf 69aa00d7aa3b6654b63280e66b671f509a3019a032ec5a09e299b793b37c6775]# cat cgroup.procs </span><br><span class="line">29001</span><br></pre></td></tr></table></figure><p>该文件罗列了所有在该groups中的进程组id(第一个进程的pid)</p></li><li><p><code>notify_on_release</code></p><p>该文件默认0，表示cgroups是否在最后一个进程退出时通知运行release agent，0表示不运行</p></li><li><p><code>cpuacct.stat</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@cf 69aa00d7aa3b6654b63280e66b671f509a3019a032ec5a09e299b793b37c6775]# cat cpuacct.stat</span><br><span class="line">user 2435</span><br><span class="line">system 4548</span><br></pre></td></tr></table></figure><p>该文件统计了该控制组中进程用户态和内核态的 cpu 使用量</p></li><li><p><code>cpuacct.usage</code>&amp;<code>cpuacct.usage_percpu</code></p><p>该文件统计了该控制组中进程消耗的cpu时间，单位是纳秒</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cgroups </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker Notes-namespace</title>
      <link href="/2018/Docker%20Notes-namespace/"/>
      <url>/2018/Docker%20Notes-namespace/</url>
      
        <content type="html"><![CDATA[<p>摘要: Docker Notes系列为学习Docker笔记，本文是学习namespace 资源隔离的笔记</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文:"></a>正文:</h2><p>对于开发者而言，Docker的大热让人们思考容器隔离的实现，如对主机名与域名的隔离、资源隔离、网络的隔离、进程间通信的隔离、用户权限的隔离、PID的隔离等。Linux内核中提供了以下6种namespace隔离的系统调用</p><table><thead><tr><th align="center">namespace</th><th align="center">系统调用参数</th><th align="center">隔离内容</th></tr></thead><tbody><tr><td align="center">UTS</td><td align="center"><code>CLONE_NEWUTC</code></td><td align="center">主机名与域名</td></tr><tr><td align="center">IPC</td><td align="center"><code>CLONE_NEWIPC</code></td><td align="center">信号量、消息队列、共享内存</td></tr><tr><td align="center">PID</td><td align="center"><code>CLONE_NEWPID</code></td><td align="center">进程编号</td></tr><tr><td align="center">Network</td><td align="center"><code>CLONE_NEWNET</code></td><td align="center">网络栈、端口</td></tr><tr><td align="center">Mount</td><td align="center"><code>CLONE_NEWNS</code></td><td align="center">文件系统</td></tr><tr><td align="center">User</td><td align="center"><code>CLONE_NEWUSER</code></td><td align="center">用户与用户组</td></tr></tbody></table><ul><li><p><strong>namespace api</strong></p><p>创建一个namespace一般使用clone()来创建，其API还包括setns()、unshare()、<a href="https://zh.wikipedia.org/wiki/Procfs">/proc目录</a>下的一些文件</p><p>然后通过不同的参数来确定使用哪种隔离方式</p><ul><li><p><strong>clone()</strong></p><p><code>clone()</code>是<code>fork()</code>的一种变种，<code>fork()</code>是一种创建自身进程副本的操作，clone()可以通过flags参数来控制使用多少功能</p><blockquote><p>fork()在父进程中返回新创建子进程的进程ID，在子进程中返回0，出现错误返回负值</p></blockquote></li><li><p><strong>setns()</strong></p><p>在使用Docker exec在运行的容器中执行一个新的命令就需要该方法，进程从原来的namespace加入到另一个namespace，通常会在setns()执行后使用clone()创建子进程继续执行命令，让原进程结束运行</p><blockquote><p>加入namespace后可以通过引入execve()函数执行用户命令(调用/bin/bash 接收参数，运行起一个shell)</p></blockquote></li><li><p><strong>unshare()</strong></p><p>unshare()与clone()很像，不同的是unshare()不需要启动一个新进程</p></li></ul></li></ul><ul><li><p><strong>UTS</strong></p><p>通过在clone()方法的flags中选择CLONE_NEWUTS参数来实现隔离不同namespace下的主机名与域名</p></li><li><p><strong>IPC</strong></p><p>同上面一样，通过CLONE_NEWIPC参数来实现不同namespace下的进程间通信隔离(信号量、消息队列、共享内存)，下列的不同namespace不再重复介绍传参方式</p></li><li><p><strong>PID</strong></p><p>PID namespace隔离非常实用会对进程PID重新编号，所以不同namespace下PID可以相同</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@cf proc]# docker exec -ti 69aa00d7aa3b /bin/bash</span><br><span class="line">root@69aa00d7aa3b:/data# echo $$</span><br><span class="line">18</span><br><span class="line">root@69aa00d7aa3b:/data# exit</span><br><span class="line">exit</span><br><span class="line">[root@cf proc]# echo $$</span><br><span class="line">28512</span><br></pre></td></tr></table></figure><p>Unix系统中，PID为1的进程是init，它是所有进程的父进程，负责维护进程表，因此若在Docker容器中运行多个进程，最先启动的进程应该是具有资源管理能力的，init进程还可以对信号进行捕捉，如Docker中接收容器结束信号后结束容器进程回收资源</p><blockquote><p>在PID namespace下unshare()与setns()方法会有一些变化，其方法的调用者进程并不进入新的PID namespace，接下来的创建子进程才会在新的namespace。例如在docker中，docker exec会使用setns()加入一个已存在的namespace，但是最终还是会调用clone()函数</p></blockquote></li><li><p><strong>MOUNT</strong></p><p>MOUNT namespace是第一个Linux namespace，所以标识符并不是CLONE_NEWMOUNT而是CLONE_NEWNS。创建MOUNT namespace时，会把当前的文件结构复制给新的namespace，新的namespace中的mount操作只会影响自身的文件系统，然后通过挂载传播来决定挂载事件的传播到别的挂载对象</p></li><li><p><strong>Network</strong></p><p>Network namespace主要是对网络资源的隔离，不同的Network namespace间可以通过创建veth pair(虚拟网络设备对，一端在新的namespace下，一端在原先的namespace中连接物理网络设备)来实现通信</p><blockquote><p>在建立veth pair之前新旧namespace使用pipe(管道)来通信</p></blockquote><p><img src="http://qiniu.itliusir.com/network%20namespace.png"></p></li><li><p><strong>User</strong></p><p>User namespace主要是对用户ID、root目录、特殊权限等的隔离</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> namespace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rest Notes-架构上的教训(论文部分完结)</title>
      <link href="/2018/Rest%20Notes-Experience%20and%20Evaluation3/"/>
      <url>/2018/Rest%20Notes-Experience%20and%20Evaluation3/</url>
      
        <content type="html"><![CDATA[<p>摘要: 从现代Web架构和由REST识别出的问题中，可以总结出很多通用的架构上的教训</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文:"></a>正文:</h2><h3 id="架构上的教训"><a href="#架构上的教训" class="headerlink" title="架构上的教训"></a>架构上的教训</h3><h4 id="基于网络的API的优势"><a href="#基于网络的API的优势" class="headerlink" title="基于网络的API的优势"></a>基于网络的API的优势</h4><p>将现代Web与其他中间件相区分的是它使用HTTP作为一个基于网络的API，其实并非一向如此，早期的Web设计利用了一个程序库(CERN的libwww)作为所有的客户端和服务器端软件所使用的的单个协议实现库。<code>CERN libwww</code>提供了一个基于库的API来建造可互操作的Web组件</p><h4 id="HTTP不是RPC"><a href="#HTTP不是RPC" class="headerlink" title="HTTP不是RPC"></a>HTTP不是RPC</h4><p>人们常常错误地将HTTP称为一种远程调用(RPC)机制，仅仅是因为它也包括了请求和响应。</p><p>RPC是调用远程机器上的一个过程，在RPC协议中，调用方识别出过程并且传递一组固定的参数，然后等待在使用相同接口返回的一个消息中提供的回答。Java的RMI(远程方法调用)就很类似，差异仅仅是将过程标识为一个对象、方法的组合，而不是一个简单的服务过程。</p><p>当然，将HTTP与RPC区分开的并不是上面的语法和特性，其重要的区别是：HTTP是请求被定向到使用一个有标准语义的通用接口的资源，中间组件几乎完全相同的方式来解释这些语义，结果就是使得一个应用能够支持转换的分层和独立于信息来源的间接层，这对于一个满足互联网规模、多个组织、无法控制的可伸缩性需求的信息系统来说是非常有用的；RPC的机制是根据语言的API来定义的，而不是根据基于网络应用的需求来定义的</p><h4 id="HTTP不是一种传输协议"><a href="#HTTP不是一种传输协议" class="headerlink" title="HTTP不是一种传输协议"></a>HTTP不是一种传输协议</h4><p>HTTP并非被设计为一种传输协议，它是一种移交协议</p><blockquote><p>Web各组件都能理解HTTP语义，从而可以独自的完成HTTP的响应，而不必一定到达最终的源服务器，这也是为什么它是移交不是传输协议的原因</p></blockquote><h4 id="媒体类型的设计"><a href="#媒体类型的设计" class="headerlink" title="媒体类型的设计"></a>媒体类型的设计</h4><p>REST有一个对架构风格来说不同寻常的方面，那就是它对于Web架构中数据元素的定义影响程度</p><ul><li><p><strong>应用状态</strong></p><p>应用的开发者经常违背的就是应用状态和无状态交互架构约束。将应用状态放错地方而造成架构不匹配并不仅限于上篇文章提到的<code>Cookie</code>，还有HTML中引入的<code>frame</code>，在一个子窗口中选择链接而导致的状态迁移与正常的状态迁移是无法区分的</p><blockquote><p>作者认为frame和cookie的失败之处在于，用户代理无法管理或解释它们所提供的间接应用状态。替代的设计是将这些信息放到一个主要的表述中，并且告知用户代理如何去管理这个存放了指定的资源领域的工作区</p></blockquote></li><li><p><strong>Java VS JavaScript</strong></p><p>通过使用REST，我们能够知道为何一些媒体类型与其他类型相比在Web架构中得到了更加广泛的接受，甚至这些类型并未取得开发者偏爱的情况下(例如Java Applet对抗JavaScript)</p><blockquote><p>作者认为JavaScript在Web上比Java更成功体现在可见的交互性影响较少、复杂性比较小、用户感知的延迟</p></blockquote></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>REST论文的阅读到此结束了，可以看出来REST主要是提供了一套指导原则，可以根据这些原则来识别架构中的缺陷，现代Web是REST架构风格的一个架构实例。在一个理想的世界里，软件系统的实现与它的设计有着精确的匹配，现代Web架构的一些功能确实完全符合它们在REST中的设计标准，例如通过URI标识资源，使用MediaTypes标识数据格式等</p><p>REST既贡献了现代Web软件架构背后的基础理论，也为我们上了重要的一课，展示了软件工程原则如何能够被系统地应用在一个真实的软件系统的设计与评估之中</p><blockquote><p>接下来会去阅读网络协议与RestFul API最佳的设计等</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> REST </category>
          
      </categories>
      
      
        <tags>
            
            <tag> REST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rest Notes-将REST应用于HTTP</title>
      <link href="/2018/Rest%20Notes-Experience%20and%20Evaluation2/"/>
      <url>/2018/Rest%20Notes-Experience%20and%20Evaluation2/</url>
      
        <content type="html"><![CDATA[<p>摘要: 超文本移交协议(HTTP)在Web架构中既作为在Web组件之间通信的主要的应用级协议，也作为特别为移交资源的表述而设计的唯一的协议(<strong>现在并不是唯一，还有COAP协议</strong>)。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文:"></a>正文:</h2><h3 id="将REST应用于HTTP"><a href="#将REST应用于HTTP" class="headerlink" title="将REST应用于HTTP"></a>将REST应用于HTTP</h3><p>超文本移交协议(HTTP)在Web架构中既作为在Web组件之间通信的主要的应用级协议，也作为特别为移交资源的表述而设计的唯一的协议(<strong>现在并不是唯一，还有COAP协议</strong>)。</p><p>REST用来识别早期HTTP协议中的问题，并指定了一个可以和HTTP1.0互操作的协议子集，然后分析HTTP1.1的扩展提议，并最终诞生了HTTP1.1</p><h4 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h4><p>REST的主要目标之一是在一个已部署的架构中支持逐渐的和片段的修改</p><ul><li><p><strong>协议版本控制</strong></p><p>通过主版本和次版本号来区分（1.0 1.1 2.0），其版本信息代表的是消息发送者对协议的支持能力</p></li><li><p><strong>可扩展的协议元素</strong></p><p>通过将解析和转发HTTP消息的规则与新的HTTP协议元素的相关语义分离开，解决了中间组件更新部署问题</p><p>扩大了响应码区间，100-599</p></li><li><p><strong>升级</strong></p><p>HTTP1.1新增了Upgrade头，用来再通信双方进行协商协议版本</p></li></ul><h4 id="自描述的信息"><a href="#自描述的信息" class="headerlink" title="自描述的信息"></a>自描述的信息</h4><p>REST要求组件之间消息是自描述的，以便支持中间组件对于交互的处理。然而早期HTTP协议的一些方面并不是自描述的(请求中缺乏主机标识、无法根据语法来区分消息控制数据和表述元数据等)</p><ul><li><p><strong>Host(主机)</strong></p><p>早期的HTTP请求中不会携带host头部信息，这导致了无法区分我访问的到底是服务器上的哪个站点</p><blockquote><p>例如我们使用Github pages搭建静态博客时候，都将域名解析到Github的某个IP(192.30.252.154)，大家通过不同域名访问的却是不同页面。这个就是通过不同的Host来区分的</p></blockquote></li><li><p><strong>分层编码</strong></p><p>HTTP为了描述表述的元数据，继承了多用途互联网邮件扩展(MIME)的语法,MIME没有定义分层的媒体类型</p></li><li><p><strong>语义独立性</strong></p><p>如上面<strong>可扩展的协议元素</strong>所述，HTTP消息的解析与其语义是相分离的</p></li><li><p><strong>传输独立性</strong></p><p>早期的HTTP协议包括大多数的HTTP/1.0的实现，使用底层的传输协议来表示响应消息的结束。服务器通过关闭TCP连接来表明响应消息的结束，但不幸的是则会导致：客户端没有办法区分一个完成的响应和因为某种故障异常而断开的响应。为了解决这个问题在HTTP/1.0中重新定义了Content-Length头信息字段，以表示消息体的字节长度，并且在HTTP/1.1中引入了“chunked”(分块)这个移交编码</p><blockquote><p>chunked编码允许表述在其生成阶段的开始时尺寸是未知的，通过一系列分块来描述它的界限，每个分块的尺寸可在被发送之前单独设置</p></blockquote></li><li><p><strong>尺寸限制</strong></p><p>对于应用层协议的灵活性而言，常见的障碍是在协议的参数上过度指定尺寸限制的倾向</p><blockquote><p>在HTTP协议中并没有限制URI的长度、头信息字段的长度、表述的长度、任何由一列条目组成的字段值的长度</p></blockquote></li><li><p><strong>缓存控制</strong></p><p>REST努力在高效率的、低效率的行为和其所期待的语义透明的缓存行为之间取得平衡，因此它允许由应用确定缓存需求，而不是将该需求硬编码在协议本身之中，这对于HTTP协议来说是至关重要的</p><blockquote><p>HTTP/1.1通过添加Cache-Control、Age、Etag、Vary几个头信息字段来达到这个目标</p></blockquote></li></ul><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><ul><li><p><strong>持久连接</strong></p><p>早期的HTTP协议每个连接只能发送单个请求/响应，尽管实现起来简单，但是它对于底层TCP传输机制的使用非常低效。原因在于每次交互都要付出重新建立连接的开销</p><p>对于HTTP/1.0，通过使用在Connection头信息字段中的“keep-alive”指令来达到这个目标，但是如果转发给不理解该指令的中间组件会造成连接关闭，HTTP1.1最终把默认的持久连接作为了默认的选项，如果要关闭连接，则需要发送close的指令</p></li><li><p><strong>直写式缓存</strong></p><p>HTTP协议不支持回写式缓存，HTTP缓存不能假设通过它写入的消息与来自相同资源的后续请求可能获取的内容是相同的，因此它不能缓存一个PUT请求的消息体，并且将其内容重用于稍后的GET请求的响应</p><p>缺乏回写式缓存并不会对性能产生严重影响</p><blockquote><p>这里的PUT请求是写入动作，幂等的，相当于对资源赋值操作</p></blockquote></li></ul><h4 id="REST在HTTP中的不匹配"><a href="#REST在HTTP中的不匹配" class="headerlink" title="REST在HTTP中的不匹配"></a>REST在HTTP中的不匹配</h4><p>在HTTP协议中存在一些架构不匹配，一些是由于标准过程之外部署的第三方扩展所导致的，其他的则是由于与已部署的HTTP/1.0组件保持兼容的必要性所导致的</p><ul><li><p><strong>区分非权威的响应</strong></p><p>没有一致的机制来区分一个响应是来自于源服务器还是中间的某一个组件(走的缓存没有走来源服务器)，虽然HTTP1.1中定义了Warning消息头，但是在实践中并未广泛使用。</p></li><li><p><strong>Cookie</strong></p><p>Cookie是不透明的数据，来源服务器通过将它包括在一个Set-Cookie响应头信息字段中，将它设置给一个用户代理，用户代理在所有将来的请求中包括这个相同的Cookie，直到被替换或者过期</p><blockquote><p>Cookie违反了REST，因为它们允许数据在没有充分表明其语义的情况下对其进行传递，这会成为一个安全和隐私方面的关注点(结合使用Cookie和Referer头信息字段，有可能当用户多个站点浏览时对其进行跟踪)</p></blockquote></li><li><p><strong>响应与请求相匹配</strong></p><p>当需要描述哪一个响应属于哪一个请求的时候，HTTP消息并不是自描述的</p><p>早期的HTTP协议并没有考虑到需要将响应与相关的请求绑定在一起的消息控制数据，因此请求的顺序决定了响应的顺序，这意味着HTTP依赖于传输层的连接来确定这一匹配</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> REST </category>
          
      </categories>
      
      
        <tags>
            
            <tag> REST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rest Notes-将REST应用于URI</title>
      <link href="/2018/Rest%20Notes-Experience%20and%20Evaluation1/"/>
      <url>/2018/Rest%20Notes-Experience%20and%20Evaluation1/</url>
      
        <content type="html"><![CDATA[<p>摘要: 自1994年以来，REST架构风格就被用来指导现代Web架构的设计和开发，本篇描述了在创作超文本移交协议(HTTP)和统一资源标识符(URI)两个互联网规范的过程中，以及将这些技术部署在libwww-perl客户端库、Apache HTTP服务器项目、协议标准的其他实现的过程中，应用REST所学到的经验和教训</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文:"></a>正文:</h2><h2 id="将REST应用于URI"><a href="#将REST应用于URI" class="headerlink" title="将REST应用于URI"></a>将REST应用于URI</h2><h3 id="Web标准化"><a href="#Web标准化" class="headerlink" title="Web标准化"></a>Web标准化</h3><p>开发REST的动机是为Web的运转方式创建一种架构模式，使之成为Web协议标准的指导框架。REST被用来描述期待的Web架构，帮助识别出现有的问题，对各种替代方案进行比较，并且保证协议的扩展不会违反使Web成功的那些核心架构约束。</p><p>行业内的压力不断增长，要求对Web接口协议的某个版本或某些版本进行标准化。Berners-Lee(Web之父)创建了W3C，将其作为Web架构的智库，并为Web编写规范以及实现相关所需的资源，但是标准化本身是由IETF及其URI、HTTP和HTML工作组来掌管的。由于作者在开发Web软件方面的经验被IETF选出来创作相对URL的规范，后来又与Henrik FrystykNielsen共同创作了HTTP/1.0规范，后来Fielding博士成了HTTP/1.1的主要架构师，并且最终创作了URI通用语法标准的URL规范的修订版</p><p>REST的第一版开发于1994年10月和1995年8月之间，起初是作者Fielding博士作为编写HTTP1.0的一种概念方法。在随后的5年中以迭代的方式不断改进，并且用于各种Web协议标准的修行版和扩展之中。REST<strong>最初被称作“HTTP对象模型”</strong>，很容易被误解为它使一个HTTP服务器的实现模型，<strong>而REST(表述性状态移交)是有意唤起人们对于一个设计良好的Web应用如何运转的印象：Web应用是一个由网页组成的网络（一个虚拟状态机），用户通过选择链接（状态迁移）在应用中前进，引导系统把下一个页面（代表应用的下一个状态）的数据移交给用户，并且呈现出来，以便用户使用</strong>。<strong>其中承载包含应用状态的部分是有超媒体来负责的，这也是为什么REST强调HATEOAS（Hypermedia As The Engine Of Application Statue）的原因所在</strong></p><h3 id="将REST应用于URI-1"><a href="#将REST应用于URI-1" class="headerlink" title="将REST应用于URI"></a>将REST应用于URI</h3><p>REST既被用来为URI规范定义“资源”这个术语，也被用来定义通过它们的表述来操作资源的通用接口的全部语义</p><h4 id="重新定义资源"><a href="#重新定义资源" class="headerlink" title="重新定义资源"></a>重新定义资源</h4><p>早期Web架构将URI定义为文档的标识符，创作者往往是根据网络上一个文档的位置来定义标识符，然后就能够使用Web协议来获取那个文档</p><p>然而，这个定义并不是令人满意，首先，它暗示创作者正在标识所移交的内容，这意味着任何时候当内容改变了这个标识符都应该改变(后移)。其次，存在很多地址对应的一个服务，而不是一个文档；最后，可能有一段时间没有这个文档</p><p>REST对于“资源”的定义有一个前提：<strong>标识符应该尽可能的少改变</strong>，因为Web使用内嵌的标识符而不是链接服务器。创作者需要的是一个能够与通过超媒体引用来表达的语义紧密匹配的标识符，允许这个引用保持静态，甚至是在访问该引用的结果可能会随时间而变化的情况下，<strong>REST通过将一个资源定义为创作者想要标识的语义，而不是创建引用时那些语义的对应值。然后留给创作者来保证所选择的这个标识符确实真正标识出了他所想要表达的语义</strong></p><h4 id="表述"><a href="#表述" class="headerlink" title="表述"></a>表述</h4><p>把资源定义为URI标识的一个”概念”而不是具体文档，用户如何操作一个资源(“概念”)呢？</p><p><strong>REST引入了“表述”这个中间层，即通过资源的表述来操作资源，而不是直接在资源本身上进行操作</strong></p><p>资源和接口背后的实现细节都应该是被隐藏起来的，<strong>通过接口和表述这两个独立的概念来隔离接口和资源的这两者的具体实现，这也是REST的统一接口这个架构约束的动机</strong>。URI和HTTP组成了接口，HTML作为资源的表述，</p><p>使得来源服务器对接口和资源的具体实现得以统一化，例如基于URI和HTTP提供接口没变，服务端对应的语言变更或者架构变更对客户端来说并没有影响</p><h4 id="将语义绑定到URI"><a href="#将语义绑定到URI" class="headerlink" title="将语义绑定到URI"></a>将语义绑定到URI</h4><p>一个资源可以拥有多个标识符，或者说存在两个或更多的不同URI在访问服务端时具有相同的语义。</p><p>对于服务器或客户端不需要知道或理解URI的含义(如在网页点击一些按钮，对于Web层来说可能只是一个POST请求而已)，这个语义应该是由用户来解读</p><h4 id="REST在URI中的不匹配"><a href="#REST在URI中的不匹配" class="headerlink" title="REST在URI中的不匹配"></a>REST在URI中的不匹配</h4><p>就像大多数现实中系统一样，并非所有已部署的Web架构组件都服从Web架构设计给出的每一个架构约束。</p><blockquote><p> REST既可以被用作改进架构的方法，也可以被用来识别架构不匹配的地方。尽管无法避免这种不匹配，但是可以识别出他们</p></blockquote><p>尽管URI的设计和REST中标识符的概念相匹配，但是仅仅依靠URI的语法规则是不足以约束不匹配的行为的。其中的一种滥用就是在所有的URL中包括标识当前用户的信息，这样的办法可以用于维护服务器会话的状态，但是也会降低共享缓存的效率，也会降低服务器的可伸缩性，并且如果一个用户把这个URL发给其他的用户时，会得到不希望看到的结果(可能看到的就是别人的数据)。这其实时违反了REST的无状态的约束。另外一个便是把Web看作是一个分布式的文件系统的时候，因为文件系统其实是暴露了其实现细节</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> REST </category>
          
      </categories>
      
      
        <tags>
            
            <tag> REST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rest Notes-REST架构的视图</title>
      <link href="/2018/Rest%20Notes-REST%20Architectural%20Views/"/>
      <url>/2018/Rest%20Notes-REST%20Architectural%20Views/</url>
      
        <content type="html"><![CDATA[<p>摘要: 上一篇我们已经孤立的了解了REST的架构元素，接下来我们可以使用架构视图来描述这些元素如何协作以形成一个架构。为了展示REST的设计原则，需要使用三种视图：过程视图、连接器视图、数据视图</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文:"></a>正文:</h2><h2 id="REST架构的视图"><a href="#REST架构的视图" class="headerlink" title="REST架构的视图"></a>REST架构的视图</h2><h3 id="过程视图-Process-View"><a href="#过程视图-Process-View" class="headerlink" title="过程视图(Process View)"></a>过程视图(Process View)</h3><p>过程视图的主要作用是通过展示数据在系统中的流动路径，得出组件之间的交互关系。下图提供了一个基于REST的架构的过程视图</p><p><img src="http://qiniu.itliusir.com/processView.png" alt="process view"></p><p>一个用户代理正在处理三个并行的交互(a、b、c)，用户代理的客户端连接器的缓存无法满足请求，因此它根据每个资源标识符的属性和客户端连接器的配置将每个请求转发到资源的来源服务器</p><ol><li>请求a被发送到一个本地代理，然后代理通过DNS查找到了一个网关，该网关把这个请求发送到一个可以满足该请求的来源服务器</li><li>请求b被直接发送到了一个来源服务器</li><li>请求c被发送到了一个本地代理，它能够直接访问WAIS(一种与Web架构相分离的信息服务)，并将WAIS的响应翻译为一种通用的连接器接口能够识别的格式</li></ol><blockquote><p>REST通过强制要求消息具有自描述性来支持中间组件的处理，其具体体现为：请求之间的交互是无状态的、使用标准的方法和媒体类型来表达语义和交换信息、以及响应可以明确地表名其可缓存性</p></blockquote><h3 id="连接器视图-Connector-View"><a href="#连接器视图-Connector-View" class="headerlink" title="连接器视图(Connector View)"></a>连接器视图(Connector View)</h3><p>连接器视图聚焦于组件之间的通信机制，客户连接器检查资源标识符，以便为每个请求选择一个合适的通信机制。例如标识符如果是一个本地资源，则连接到一个处理本地资源的代理组件</p><blockquote><p>REST并不限制通信只能使用一种特殊的协议，比如上面过程视图中请求c将http转成了wais。尽管如此，与其他协议的服务的交互被限制为只能使用REST连接器的语义</p></blockquote><h3 id="数据视图-Data-View"><a href="#数据视图-Data-View" class="headerlink" title="数据视图(Data View)"></a>数据视图(Data View)</h3><p>数据视图展示了信息在组件之间流动时的应用状态。因为REST被明确定位于分布式信息系统，它将应用看作是一种信息和控制的聚合体，用户可以通过这个聚合体执行它们想要完成的任务。</p><p>REST将所有的控制状态都集中在从交互的响应中接收到的表述之中，其目的是通过使服务器无需维护当前请求之外的客户端状态从而改善服务器的可伸缩性。</p><p>REST的模型应用是一个引擎，它通过检查和选择当前表述集合中的状态跃迁选项从一个状态移动到下一个状态。</p><blockquote><p>前几篇文章介绍了REST的风格推导到REST架构元素和REST架构视图。作者描述了指导REST的软件工程原则和为支持这些原则而选择的交互约束，并将它们与其他架构的约束进行了对比</p></blockquote><blockquote><p>下一篇将介绍REST应用于现代Web架构的设计、规范、部署过程中的经验与教训以及对REST架构的评估</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> REST </category>
          
      </categories>
      
      
        <tags>
            
            <tag> REST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rest Notes-REST架构的元素</title>
      <link href="/2018/Rest%20Notes-REST%20Elements/"/>
      <url>/2018/Rest%20Notes-REST%20Elements/</url>
      
        <content type="html"><![CDATA[<p>摘要: 上篇文章是对REST的风格推导，本篇是对REST架构中元素做解释</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文:"></a>正文:</h2><h2 id="REST架构的元素"><a href="#REST架构的元素" class="headerlink" title="REST架构的元素"></a>REST架构的元素</h2><h3 id="数据元素-Data-Elements"><a href="#数据元素-Data-Elements" class="headerlink" title="数据元素(Data Elements)"></a>数据元素(Data Elements)</h3><p>在分布式对象风格中，所有的数据被封装和隐藏在数据的处理组件之中。于分布式对象不同的是，REST的关键方面之一是架构的数据元素的性质和状态。在分布式超媒体的特性中，当用户选择了一个链接后，该链接所指向的信息需要从其存储地移动到其使用地。对于一个分布式超媒体系统的架构师而言，他只能在三种选项中做出选择：</p><ul><li>在数据所在地对数据进行呈现，并向接收者发送一个固定格式的镜像；</li><li>把数据和呈现引擎封装起来，一起发送给接收者；</li><li>发送原始数据可一些描述数据类型的元数据，让接收者自己去呈现。</li></ul><p>第一种选项对应于传统的客户-服务器风格，将与数据的自然特性有关的所有信息都被隐藏在数据发送者之中，简化了客户端的实现。但是也严重限制了接收者的功能，并且将大部分处理负担都放在了发送者这一边，从来导致伸缩性的问题</p><p>第二种对应于可移动对象风格，它支持对于信息的隐藏还可以通过唯一的呈现引擎来支持对于数据的专门处理。但是它将接收者的功能限制在引擎所能预测的范围之内，还大幅增加需要移交的数据量</p><p>第三种选项允许发送者保持简单性和可伸缩性，同时使得需要移交的数据最小化。但是它丧失了信息隐藏的优点，并且要求发送者和接收者都必须理解相同的数据类型</p><blockquote><p>REST提供的是所有三种选项的一个混合体，通过以一种数据格式移交资源的表述来进行通信，可以基于接收者的能力和所期待的格式以及内容中动态的选择所使用的数据格式。至于表述是否与资源的原始格式相同，则被隐藏在了接口的背后</p></blockquote><p>通过发送一个表述，可以获得近似于可移动对象风格的好处，这个表述由一个封装过的呈现引擎的标准数据格式中的指令组成。REST因此获得了客户-服务器风格的分离关注点的好处，而且不存在服务器的可伸缩性问题，它允许通过一个通用的接口来隐藏信息，从而支持封装和服务的进化，并且可以通过下载功能引擎来提供一组不同的功能</p><table><thead><tr><th align="center">数据元素</th><th align="center">现代Web实例</th></tr></thead><tbody><tr><td align="center">资源</td><td align="center">一个超文本引用所指向的概念性目标</td></tr><tr><td align="center">资源标识符</td><td align="center">URL、URN</td></tr><tr><td align="center">表述</td><td align="center">HTML 文档、JPEG图片</td></tr><tr><td align="center">表述元数据</td><td align="center">媒体类型、最后修改时间</td></tr><tr><td align="center">资源元数据</td><td align="center">source link、alternates、vary</td></tr><tr><td align="center">控制数据</td><td align="center">if-modified-since、cache-control</td></tr></tbody></table><h4 id="资源和资源标识符"><a href="#资源和资源标识符" class="headerlink" title="资源和资源标识符"></a>资源和资源标识符</h4><p>REST对于信息的核心抽象是<code>资源</code>，任何能够被命名的信息都能够作为一个资源：一份文档、一张图片、北京的天气等</p><p><code>资源标识符</code>则是对一个资源的唯一标识，由命名权威来为资源分配标识符，映射的语义同样由命名权威来负责</p><h4 id="表述"><a href="#表述" class="headerlink" title="表述"></a>表述</h4><p>REST使用<code>表述</code>来描述资源的当前状态或预期状态，由数据、描述数据的元数据、以及(有时候存在的)描述元数据的元数据组成(通常用来验证消息的完整性)</p><p>元数据以名称-值对的形式出现，名称对应于一个定义值的结构和语义的标准。响应消息可以同时包括<code>表述元数据</code>和<code>资源元数据</code></p><p><strong>控制数据</strong> 定义了在组件之间移交的消息的用途，例如被请求的动作或响应的含义。也用于提供请求的参数，或覆盖某些连接元素的默认行为</p><p>表述的数据格式被称为媒体类型(media type)，发送者能够将一个表述包含在一个消息中发给接收者，接收者根据消息中的<code>控制数据</code>和媒体类型的性质对该消息进行处理。媒体类型有些是用来做自动处理，有些是用来呈现给用户查看的</p><p>媒体类型的设计能够直接影响到一个分布式超媒体系统的用户感知的性能。例如接收者对表述呈现之前需要接收一些数据造成的交互的延迟。在网络性能相同的情况下，增量会比整个文档全部接收的浏览器在用户感知层面更好</p><h3 id="连接器-Connectors"><a href="#连接器-Connectors" class="headerlink" title="连接器(Connectors)"></a>连接器(Connectors)</h3><table><thead><tr><th align="center">连接器</th><th align="center">现代互联网实例</th></tr></thead><tbody><tr><td align="center">客户</td><td align="center">libwww、libwww-perl</td></tr><tr><td align="center">服务器</td><td align="center">libwww、Apache API、NSAPI</td></tr><tr><td align="center">缓存</td><td align="center">浏览器缓存、Akamai缓存网络</td></tr><tr><td align="center">解析器(resolver)</td><td align="center">绑定(DNS查找库)</td></tr><tr><td align="center">隧道(tunnel)</td><td align="center">SOCKS、HTTP CONNECT之后的SSL</td></tr></tbody></table><p>如上列表所示，REST使用不同的连接器类型来对访问资源和移交资源表述的活动进行封装。连接器代表了一个组件通信的抽象接口，通过提供清晰的关注点分离、并且隐藏资源的底层实现和通信机制，改善了架构的简单性，接口的通用性也使得组件的可替换性变得可能。</p><p>所有的REST交互都是无状态的，这一限制得到了四个功能：</p><ul><li>它使得连接器无须在请求之间保持应用的状态，改善了可伸缩性，降低了物理资源的消耗</li><li>它允许对交互进行并行处理，处理机制无须理解交互的语义</li><li>它允许中间件孤立的查看和理解一个请求，当对服务进行动态“编排”时这个是必须的</li><li>它强制每个请求都必须包含可能会影响到一个已缓存响应的可重用性的所有信息</li></ul><p>上面列表的前两种都是很容易理解的，第三种缓存连接器可以位于客户或服务器连接器的接口处，以便保存当前交互的可缓存的响应；</p><p>第四种解析器负责将部分或完整的资源标识符翻译成创建组件间链接所需的网络地址信息(例如Web浏览器会从URI中提取出主机名并利用DNS解析器来获得该命名权威的互联网协议(IP)地址)；</p><p>第五种隧道，它简单地跨越连接的边界(如防火墙)对通信进行中继(例如当响应一个connect方法请求时，http代理会切换到一个隧道，从而允许其客户使用一种不同的协议来直接与不支持代理的远程服务器通信。当两端终止通信时隧道就会消失)</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><table><thead><tr><th align="center">组件</th><th align="center">现代Web实例</th></tr></thead><tbody><tr><td align="center">来源服务器(origin server)</td><td align="center">Apache httpd、微软IIS</td></tr><tr><td align="center">网关(gateway)</td><td align="center">Squid、CGI、反向代理</td></tr><tr><td align="center">代理(proxy)</td><td align="center">CERN代理、Netscape代理、Gauntlet</td></tr><tr><td align="center">用户代理(user agent)</td><td align="center">Netscape Navigator、Lynx、MOMspider</td></tr></tbody></table><p><code>来源服务器</code>使用服务器连接管理被请求资源的命名空间，每个来源服务器都以资源层次结构的形式，为期所暴露的服务提供一个通用的接口。资源的实现细节被隐藏在这一接口的背后</p><p><code>网关</code>也叫反向代理，是由网络或来源服务器强加的中间组件，为其他服务提供接口封装，以执行数据转换、性能增强或安全增强</p><p><code>代理</code>组件是由客户选择的中间件，用来为其他的服务、数据转换、性能增强、安全保护提供接口封装</p><p><code>用户代理</code>使用客户连接器发起请求，并作为响应的最终接收者，常见的例子是Web浏览器</p><blockquote><p>网关与代理的区别是，何时使用代理是由客户来决定的</p></blockquote><blockquote><p>下篇会写REST架构中的视图部分~</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> REST </category>
          
      </categories>
      
      
        <tags>
            
            <tag> REST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rest Notes-表述性状态移交(Representational State Transfer ,REST)</title>
      <link href="/2018/Rest%20Notes-Representational%20State%20Transfer(REST)/"/>
      <url>/2018/Rest%20Notes-Representational%20State%20Transfer(REST)/</url>
      
        <content type="html"><![CDATA[<p>摘要: 上篇文章提到的“新的架构风格(REST)”就是专门为分布式超媒体系统设计的，它由几种<a href="http://itliusir.com/2018/Rest%20Notes-Web%20Based%20Architecture%20Styles/">基于网络的架构风格</a>中衍生而来的一种混合架构风格，并且添加了一些额外的架构约束，用来定义统一的连接器接口</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文:"></a>正文:</h2><h3 id="推导REST"><a href="#推导REST" class="headerlink" title="推导REST"></a>推导REST</h3><p>Web架构背后的设计基础理论可以描述为<strong>由一组应用于架构中元素之上的架构约束组成的架构风格</strong></p><h4 id="从“空”风格-Null-Style-开始"><a href="#从“空”风格-Null-Style-开始" class="headerlink" title="从“空”风格(Null Style)开始"></a>从“空”风格(Null Style)开始</h4><p>无论是建筑还是软件，架构过程有着两种常见的观点：</p><ol><li>设计者一切从0开始最后建造出一个架构，直到架构满足系统需求</li><li>设计者从一个整体的系统需求出发，此时没有任何约束(空风格)，通过增量的识别出各种约束应用于系统的架构元素之上，不了解架构元素的可以回看<a href="http://itliusir.com/2018/Rest%20Notes-Software%20Architecture/">第一篇文章</a></li></ol><p>REST正是使用第二种观点开发出来的，从架构的观点来看，空风格描述了一个组件之间没有明显边界的系统，这就是我们描述REST的起点</p><p><img src="http://oze7h7cqk.bkt.clouddn.com/nullStyle.png" alt="null style"></p><h4 id="客户-服务器"><a href="#客户-服务器" class="headerlink" title="客户-服务器"></a>客户-服务器</h4><p>首先添加一个<a href="http://itliusir.com/2018/Rest%20Notes-Web%20Based%20Architecture%20Styles/">客户-服务器</a>约束，该约束背后原则是分离关注点，通过分离用户界面和数据存储这两个关注点，提高了<strong>可移植性</strong>、<strong>可伸缩性</strong>。对于Web而言最重要的是这种关注点分离使得组件可以<strong>独立的部署与进化</strong></p><p><img src="http://qiniu.itliusir.com/CS.png" alt="cs"></p><h4 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h4><p>接下来添加一个<a href="http://itliusir.com/2018/Rest%20Notes-Web%20Based%20Architecture%20Styles/">无状态</a>约束：通信必须在本质上是无状态的，从客户端到服务器的每个请求都必须包含理解该请求所必需的所有信息，<strong>会话状态要全部保存在客户端</strong></p><p>这一约束产生了<strong>可见性</strong>、<strong>可靠性</strong>和<strong>可伸缩性</strong>三个架构属性，原因可以去查看上面无状态的超链接，这里不重复解释</p><p><img src="http://qiniu.itliusir.com/css.png" alt="css"></p><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存."></a>缓存.</h4><p>为了改善网络的效率，我们添加了缓存这个架构约束，好处在于减少了一些交互，从而提高效率和用户感知性能</p><p><img src="http://qiniu.itliusir.com/ccss.png" alt="ccss"></p><p><strong>早期的Web架构(1994年之前)是通过客户-缓存-无状态-服务器的架构约束集合(风格)来定义的</strong>，交互的通信协议仅包含了对非共享缓存(non-shared caches)的支持，并没有限定接口要对所有的资源提供一组一致的语义。相反地，Web依赖于使用一个公共的客户-服务器实现库(CERN的libwww)来维护Web应用之间的一致性</p><p><img src="http://qiniu.itliusir.com/earlywww.png" alt="早期Web架构"></p><p>由于Web实现的开发者们早已超越了这种早期的设计，请求除了静态的文档之外还能够识别出动态生成的响应，也以代理和共享缓存的形式开展了对中间件的开发工作，但是必须对现有的协议进行扩展，这样中间件才能可靠的通信。以下三个架构约束（<strong>统一接口，分层系统，按需代码</strong>）则是对早期Web架构的扩充，以便用来对现代的Web架构的扩展加以指导</p><h4 id="统一接口"><a href="#统一接口" class="headerlink" title="统一接口"></a>统一接口</h4><p>本约束也是使得REST风格与别的风格产生区别的核心特征，通过在组件接口上应用通用性的软件工程原则来简化系统架构，也改善了交互的可见性，也使得它们提供的服务与实现是解耦的，促进了独立的可进化性。当然任何东西都有两面性，统一接口的代价就是降低了效率。因为信息都是使用标准的形式来移交的，而不是特定于应用需求的形式。</p><p>统一接口的意义在于凡是参与到每一个http通信的所有组件(浏览器、http代理、服务网关、web服务器、应用服务器等)，都可以理解这个请求。构成这个请求的是uri、http、mime、html，用url标识资源，用http操作资源的表述，用mime协商请求双方都接收的媒体类型(html、json、xml等)</p><blockquote><p>REST接口被设计为可以高效的移交大粒度的超媒体数据，并对Web的场景情况做了优化，但是这也导致该接口对于其他形式的架构交互而言并不是最优的</p></blockquote><p><img src="http://qiniu.itliusir.com/uccss.png" alt="uccss"></p><p>为了获得统一接口，需要多个架构约束来指导组件的行为，REST由四个接口架构约束来定义：</p><ul><li>资源的识别</li><li>通过表述来操作资源</li><li>自描述的信息</li><li>超媒体作为应用程序状态的引擎（HATEOAS）</li></ul><h4 id="分层系统"><a href="#分层系统" class="headerlink" title="分层系统"></a>分层系统</h4><p>为了进一步改善与互联网规模这个需求相关的行为，我们添加了分层系统架构约束，为整个系统的复杂性设置了边界，并且提高了底层独立性。我们能够使用层级来封装遗留服务，使新的服务免受遗留客户端的影响。</p><p>中间件还可以支持负载均衡来<strong>改善系统的可伸缩性</strong>。然而，分层系统会增加数据处理的开销和延迟，因此<strong>降低用户感知的性能</strong>。不过对于一个支持缓存的架构来说，则可以通过在中间层使用共享缓存来弥补这一缺点。此外还可以通过这些中间层实施安全策略（比如防火墙）。</p><p><img src="http://qiniu.itliusir.com/ulccss.png" alt="ulccss"></p><p>分层系统架构约束与统一接口架构约束相结合，产生了与<a href="http://itliusir.com/2018/Rest%20Notes-Web%20Based%20Architecture%20Styles/">统一管道和过滤器风格</a>类似的架构属性。在REST中，中间组件能够主动的转换消息的内容，因为这些消息是自描述的，并且其语义对于中间组件是可见的</p><h4 id="按需代码"><a href="#按需代码" class="headerlink" title="按需代码"></a>按需代码</h4><p>我们为REST添加的最后架构约束来自<a href="http://itliusir.com/2018/Rest%20Notes-Web%20Based%20Architecture%20Styles/">基于网络应用的架构风格</a>的按需代码约束，REST允许通过下载并执行applet形式或脚本形式的代码，对客户端的功能进行扩展。这样通过减少预先实现的功能的数目，简化了客户端的开发，允许部署之后下载功能代码也<strong>改善了系统的可扩展性</strong>。但是这样做<strong>降低了可见性（REST的连接器和组件并无法理解这些脚本），</strong>因此它只是REST的一个可选的架构约束</p><p><img src="http://qiniu.itliusir.com/rest.png" alt="rest风格"></p><h4 id="风格推导小节"><a href="#风格推导小节" class="headerlink" title="风格推导小节"></a>风格推导小节</h4><p>REST架构风格由一组经过选择的架构约束组成，通过这些架构约束在候选架构上产生所期待的架构属性，夏天是根据<a href="http://itliusir.com/2018/Rest%20Notes-Web%20Based%20Architecture%20Styles/">基于网络应用的架构风格</a>图形化描述了REST架构风格的架构约束来源</p><p><img src="http://qiniu.itliusir.com/rest1.png" alt="推导REST"></p><blockquote><p>本篇文章主要是对rest风格的推导，下一篇文章会介绍REST架构中的架构元素</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> REST </category>
          
      </categories>
      
      
        <tags>
            
            <tag> REST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rest Notes-设计Web架构：问题与领悟</title>
      <link href="/2018/Rest%20Notes-Designing%20Web%20Problems%20and%20Insights/"/>
      <url>/2018/Rest%20Notes-Designing%20Web%20Problems%20and%20Insights/</url>
      
        <content type="html"><![CDATA[<p>摘要: 本文介绍Web架构的需求，以及作者在对Web通信协议做设计评估遇到的问题，根据上篇文章的调查和分类获得的领悟推导出了开发某种架构风格的方法，用来改进现代Web架构的设计工作提供指导</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文:"></a>正文:</h2><h2 id="设计Web架构：问题与领悟"><a href="#设计Web架构：问题与领悟" class="headerlink" title="设计Web架构：问题与领悟"></a>设计Web架构：问题与领悟</h2><h3 id="Web应用领域的需求"><a href="#Web应用领域的需求" class="headerlink" title="Web应用领域的需求"></a>Web应用领域的需求</h3><p>Berners-Lee(Web之父)写到：“Web’s major goal was to be a shared information space<br>through which people and machines could communicate”，意思是Web的主要目的是旨在形成一种共享的信息空间(链接众多文档的广域的超媒体信息检索系统)，人类和机器都可以通过它来进行沟通</p><p>这个系统最初期望的用户是分散在世界各地的、通过互联网连接的各个大学和政府的高能物理研究实验室。他们的机器是不同种类的终端、工作站、服务器和超级计算机的大杂烩，所以他们的操作系统和文件格式也是一个大杂烩。构建一个这样的系统所面临的挑战是为这些信息文档提供统一的接口，使得这些信息可以在众多的平台上进行交流通信，以及当新的设备接入到这个系统时，可以进行增量的部署。</p><h4 id="低门槛"><a href="#低门槛" class="headerlink" title="低门槛"></a>低门槛</h4><p>参与创建和构造信息是自愿的，因此采用“低门槛”策略是十分必要的。</p><p>选择<a href="http://line-mode.cern.ch/www/hypertext/WWW/WhatIs.html">超媒体</a>作为用户界面是因为其简单性和通用性。</p><ol><li>无论信息来源何处都能使用相同的界面进行呈现</li><li>链接的关系可以形成一个关系“网状结构”</li></ol><p>对于创作者而言，超媒体的创作语言也必须是简单的，能够使用现有的编辑工具来进行创建，无论是否连接到互联网，都可以使用此超媒体格式来保存创作的内容。</p><p>对于应用开发者而言，简单性也是一个目标，因此所有的协议都被定义为文本格式，以方便对通信进行观察和测试。</p><h4 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h4><p>简单性使得我们部署一个分布式系统的最初实现成为了可能，可扩展性使得我们避免了永远陷入已部署系统的局限之中。就像社会的变化一样，一个系统如果想要像Web那么长寿就必须要做好应对变化的准备</p><h4 id="分布式超媒体"><a href="#分布式超媒体" class="headerlink" title="分布式超媒体"></a>分布式超媒体</h4><p><a href="http://line-mode.cern.ch/www/hypertext/WWW/WhatIs.html">超媒体</a>是由应用控制信息来定义的，这些信息内嵌在信息的表述之中。分布式超媒体系统允许在远程地点存储表达控制信息，因此分布式超媒体系统中的用户操作需要将大量的数据从其存储地移交到其使用地，所以Web的架构必须支持大粒度的数据移交。超媒体交互的可用性很容易影响到用户感知的性能（比如用户选择了一个链接，到链接的界面呈现之间的时间），因为Web的交互的信息是跨域整个互联网的，则Web的架构必须尽量的减少网络交互的次数以改善用户感知的性能。</p><h4 id="互联网规模"><a href="#互联网规模" class="headerlink" title="互联网规模"></a>互联网规模</h4><p>Web旨在成为一个互联网规模的分布式超媒体系统，这意味着它的内涵远远不止仅仅是地理上的分布。互联网是跨越组织便捷互相连接的信息网络。信息服务的提供商必须能够有能力满足无法控制的<code>可伸缩性</code>和软件组件的<code>独立部署</code>两方面的要求</p><ul><li><p>可伸缩性</p><p>无法控制的可伸缩性指的是架构元素可能会于其组织边界之外的元素进行通信，当它们遇到如下的情况时仍能正常运行：未曾预料到的负载、收到错误的数据或者恶意的数据等等</p></li><li><p>独立部署</p><p>多个组织边界也意味着系统应该可以应对新旧组件的共存，而不妨碍新组件使用它们的新功能。同时现有的架构元素在设计的时候需要考虑到以后会添加新功能，旧的实现也必须能够方便的识别出来，从而把这些遗留的行为封装起来，不会对新元素造成不利影响。对于Web这样的系统来说，强制要求架构中的所有组件都整齐划一的来部署是不现实的事情</p></li></ul><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>尽管为Web的成功而欢欣鼓舞，但互联网开发者社区开始担心Web使用的快速增长率，因为最早的HTTP0.9是一个非常简单的协议，是为单个请求响应设计的，新的站点越来越多的采用了图片作为网页的一部分，导致出现了不同的浏览模式。此时的Web架构已经无法满足这样的需求了，随后在IETF形成了三个工作小组HTTP,URI和HTML。<strong>这些工作组的主要任务是定义现有架构性通信的子集（早期Web中普遍的一致的实现），然后指定一组规范来解决这些问题。这些工作带来的挑战是如何把一组新功能引入到一个已经被广泛部署的系统中；以及如何确保新功能的引入不会对那些使得Web成功的架构属性带来不利的影响甚至是毁灭性的影响</strong></p><h4 id="解决之道"><a href="#解决之道" class="headerlink" title="解决之道"></a>解决之道</h4><ol><li>识别出一组存在于早期Web架构(HTTP1.0和HTTP1.1之前)中的架构约束，这些架构约束负责产生出所期待的架构属性</li><li>识别出在互联网规模的分布式超媒体系统中所期待的架构属性，然后选择额外的会产生那些架构属性的架构风格，将它们与早期的Web架构中的约束相结合，形成一种新的风格</li><li>使用新的架构风格作为指导，对修改和扩展Web架构的提议进行评估，看其是否存在冲突，如果存在冲突则表明这个提议违反了一个或多个Web背后的设计原则</li></ol><p>上面的1、2、3实际上是一种无顺序的、迭代的方式来应用的</p><p>修正后的协议规范是根据”<strong>新的架构风格</strong>“的指导来编写的，最后通过修订后规范，开发实现它，然后进行部署。这些解决之道是源自于Fielding博士直接参与了Apache Http服务器的项目和libwww-perl客户端库，以及为网景的Navigator、Lynx和微软的IE的开发者提供建议得到的经验</p><blockquote><p>下篇文章就要介绍上面的“新的架构风格”(REST)推导过程</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> REST </category>
          
      </categories>
      
      
        <tags>
            
            <tag> REST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rest Notes-基于网络应用的架构风格</title>
      <link href="/2018/Rest%20Notes-Web%20Based%20Architecture%20Styles/"/>
      <url>/2018/Rest%20Notes-Web%20Based%20Architecture%20Styles/</url>
      
        <content type="html"><![CDATA[<p>摘要: 上章节划定了我们要讨论的范围是基于网络应用的架构，接下来对基于网络应用的常见架构风格进行了调查，并针对每个风格进行多方面的评估</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文:"></a>正文:</h2><h2 id="基于网络应用的架构风格"><a href="#基于网络应用的架构风格" class="headerlink" title="基于网络应用的架构风格"></a>基于网络应用的架构风格</h2><h3 id="数据流风格"><a href="#数据流风格" class="headerlink" title="数据流风格"></a>数据流风格</h3><table><thead><tr><th align="center">风格</th><th align="center">继承</th><th align="center">网络性能</th><th align="center">用户感知性能</th><th align="center">简单性</th><th align="center">可进化性</th><th align="center">可配置性</th><th align="center">可扩展性</th><th align="center">可重用性</th><th align="center">可见性</th></tr></thead><tbody><tr><td align="center">PF</td><td align="center"></td><td align="center"></td><td align="center">±</td><td align="center">+</td><td align="center">+</td><td align="center">+</td><td align="center">+</td><td align="center">+</td><td align="center"></td></tr><tr><td align="center">UPF</td><td align="center">PF</td><td align="center">-</td><td align="center">±</td><td align="center">++</td><td align="center">+</td><td align="center">++</td><td align="center">+</td><td align="center">++</td><td align="center">+</td></tr></tbody></table><p>(-)是消极影响，(+)是积极影响，(±)是表示影响的性质取决于问题领域的某个方面，(空)是没有约束</p><h4 id="管道和过滤器-Pipe-and-Filter-PF"><a href="#管道和过滤器-Pipe-and-Filter-PF" class="headerlink" title="管道和过滤器(Pipe and Filter,PF)"></a>管道和过滤器(Pipe and Filter,PF)</h4><p> 每个过滤器(组件)从输入端读取数据流，在输出端产出数据流，通常会对输入数据流应用一种转换并增量的处理它们</p><p><strong>缺点：</strong></p><ul><li>长管道会增加延迟</li><li>不能增量处理只能批量顺序处理，降低用户感知性能</li></ul><h4 id="统一管道和过滤器-Uniform-Pipe-and-Filter-UPF"><a href="#统一管道和过滤器-Uniform-Pipe-and-Filter-UPF" class="headerlink" title="统一管道和过滤器(Uniform Pipe and Filter,UPF)"></a>统一管道和过滤器(Uniform Pipe and Filter,UPF)</h4><p>在PF风格的基础上增加了必须具有相同接口的约束</p><p>如Unix操作系统中，其中过滤器进程具有一个字符输入流(stdin)和两个字符输出数据流(stdout和siderr)组成的接口</p><p>通过限定使用这个接口就可以排列组合独立的过滤器形成新的应用，理解过滤器的运转也会变得简单</p><p><strong>缺点：</strong></p><ul><li>当数据需要转换时候这个约束可能会降低网络性能</li></ul><h3 id="复制风格"><a href="#复制风格" class="headerlink" title="复制风格"></a>复制风格</h3><table><thead><tr><th align="center">风格</th><th align="center">继承</th><th align="center">用户感知的性能</th><th align="center">效率</th><th align="center">可伸缩性</th><th align="center">简单性</th><th align="center">可靠性</th></tr></thead><tbody><tr><td align="center">RR</td><td align="center"></td><td align="center">++</td><td align="center"></td><td align="center">+</td><td align="center"></td><td align="center">+</td></tr><tr><td align="center">$</td><td align="center">RR</td><td align="center">+</td><td align="center">+</td><td align="center">+</td><td align="center">+</td><td align="center"></td></tr></tbody></table><h4 id="复制仓库-Replicated-Repository-RR"><a href="#复制仓库-Replicated-Repository-RR" class="headerlink" title="复制仓库(Replicated Repository,RR)"></a>复制仓库(Replicated Repository,RR)</h4><p>利用多个进程提供相同的服务来改善数据的可访问性、可伸缩性，给客户端制造出只有一个集中服务的幻觉</p><p><strong>优点：</strong></p><ul><li>改善了用户感知的性能<ul><li>减少处理正常请求的延迟</li><li>在主服务器故障或断网时候支持离线操作</li></ul></li></ul><p><strong>缺点：</strong></p><ul><li>复制所导致的复杂性</li></ul><h4 id="缓存-Cache"><a href="#缓存-Cache" class="headerlink" title="缓存(Cache,$)"></a>缓存(Cache,$)</h4><p>缓存风格继承复制仓库风格，复制个别请求结果以便后面的请求复用</p><p><strong>优点：</strong></p><ul><li>缓存风格实现起来要更容易</li></ul><p><strong>缺点：</strong></p><ul><li>用户感知的性能层面上改善不大，因为会存在大量没有命中缓存的请求，离线操作也只会是历史数据</li></ul><h3 id="分层风格"><a href="#分层风格" class="headerlink" title="分层风格"></a>分层风格</h3><table><thead><tr><th align="center">风格</th><th align="center">继承</th><th align="center">网络性能</th><th align="center">用户感知性能</th><th align="center">效率</th><th align="center">可伸缩性</th><th align="center">简单性</th><th align="center">可进化性</th><th align="center">可重用性</th><th align="center">可见性</th><th align="center">可移植性</th><th align="center">可靠性</th></tr></thead><tbody><tr><td align="center">CS</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">+</td><td align="center">+</td><td align="center">+</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">LS</td><td align="center"></td><td align="center"></td><td align="center">-</td><td align="center"></td><td align="center">+</td><td align="center"></td><td align="center">+</td><td align="center">+</td><td align="center"></td><td align="center">+</td><td align="center"></td></tr><tr><td align="center">L+CS</td><td align="center">CS+LS</td><td align="center"></td><td align="center">-</td><td align="center"></td><td align="center">++</td><td align="center">+</td><td align="center">++</td><td align="center">+</td><td align="center"></td><td align="center">+</td><td align="center"></td></tr><tr><td align="center">CSS</td><td align="center">CS</td><td align="center">-</td><td align="center"></td><td align="center"></td><td align="center">++</td><td align="center">+</td><td align="center">+</td><td align="center"></td><td align="center">+</td><td align="center"></td><td align="center">+</td></tr><tr><td align="center">CSS+$</td><td align="center">CSS+$</td><td align="center">-</td><td align="center">+</td><td align="center">+</td><td align="center">++</td><td align="center">+</td><td align="center">+</td><td align="center"></td><td align="center">+</td><td align="center"></td><td align="center">+</td></tr><tr><td align="center">LC$SS</td><td align="center">LCS+C$SS</td><td align="center">-</td><td align="center">±</td><td align="center">+</td><td align="center">+++</td><td align="center">++</td><td align="center">++</td><td align="center">+</td><td align="center">+</td><td align="center">+</td><td align="center">+</td></tr><tr><td align="center">RS</td><td align="center">CS</td><td align="center"></td><td align="center"></td><td align="center">+</td><td align="center">-</td><td align="center">+</td><td align="center">+</td><td align="center"></td><td align="center">-</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">RDA</td><td align="center">CS</td><td align="center"></td><td align="center"></td><td align="center">+</td><td align="center">-</td><td align="center">-</td><td align="center"></td><td align="center"></td><td align="center">+</td><td align="center"></td><td align="center">-</td></tr></tbody></table><h4 id="客户-服务器-Client-Server-CS"><a href="#客户-服务器-Client-Server-CS" class="headerlink" title="客户-服务器(Client-Server,CS)"></a>客户-服务器(Client-Server,CS)</h4><p>这个是最常见的架构风格，服务端提供接口(服务)，客户端通过连接器发送请求执行这个接口(服务)，服务端收到后进行正常操作</p><h4 id="分层-客户-服务器-Layered-Client-Server-LCS"><a href="#分层-客户-服务器-Layered-Client-Server-LCS" class="headerlink" title="分层-客户-服务器(Layered-Client-Server,LCS)"></a>分层-客户-服务器(Layered-Client-Server,LCS)</h4><p>分层系统(Layered System,LS)是按照层次来组织的，下面一层给上面一层提供服务，底层则会隐藏细节；在基于网络的系统中(前文提到的讨论范围)，分层系统仅限于与CS相结合，形成LCS风格</p><p>LCS是在CS的基础上添加了代理(proxy)组件和网关(gateway)组件，例如我们目前前端开发使用的转发代理和API网关，这样额外的工作为系统添加了多个层，从而实现例如LoadBlance和Security Check</p><p><strong>优点：</strong></p><ul><li>通过隐藏和封装的层级关系，减少了耦合，改善了可进化性和可重用性</li></ul><p><strong>缺点：</strong></p><ul><li>增加了处理数据的开销和延迟</li><li>降低了用户感知性能</li></ul><h4 id="客户-无状态-服务器-Client-Stateless-Server-CSS"><a href="#客户-无状态-服务器-Client-Stateless-Server-CSS" class="headerlink" title="客户-无状态-服务器(Client-Stateless-Server,CSS)"></a>客户-无状态-服务器(Client-Stateless-Server,CSS)</h4><p>该风格强调的是在服务端不允许有会话状态(session state)，所以客户端给服务端发的每个请求都必须包含理解(解析到)请求的必备信息，会话状态交给客户端保存</p><p><strong>优点：</strong></p><ul><li><p>可见性</p><p>以前需要看很多请求数据才可以确定请求的全部性质，现在看一个就行啦</p></li><li><p>可靠性</p><p>使故障的恢复更简单(无状态嘛)</p></li><li><p>可伸缩性</p><p>不保存多个请求的状态</p></li></ul><p><strong>缺点：</strong></p><ul><li>每次请求都需要添加类似重复的数据</li><li>降低网络性能，增大了交互的开销</li></ul><h4 id="客户-缓存-无状态-服务器-Client-Cache-Stateless-Server-CSS"><a href="#客户-缓存-无状态-服务器-Client-Cache-Stateless-Server-CSS" class="headerlink" title="客户-缓存-无状态-服务器(Client-Cache-Stateless-Server,CSS)"></a>客户-缓存-无状态-服务器(Client-Cache-Stateless-Server,CSS)</h4><p>在CSS风格基础上增加了缓存风格，在客户端与服务端中间斡旋，重用历史的请求响应</p><p><strong>优点：</strong></p><ul><li>减少了一些交互，从而提高效率和用户感知性能</li></ul><h4 id="远程会话-Remote-Session-RS"><a href="#远程会话-Remote-Session-RS" class="headerlink" title="远程会话(Remote Session,RS)"></a>远程会话(Remote Session,RS)</h4><p>该风格属于CS的一种变体，试图将客户端的复杂性最小化，可重用性(客户端)最大化，可以理解为“客户端的分布式会话”</p><p><strong>优点：</strong></p><ul><li>集中维护服务端接口更加容易</li><li>利用会话上下文提高效率</li></ul><p><strong>缺点：</strong></p><ul><li>减低了服务端的可伸缩性(毕竟需要保存状态，这点和无状态刚好是反的)</li><li>降低了交互的可见性</li></ul><h4 id="远程数据访问-Remote-Data-Access-RDA"><a href="#远程数据访问-Remote-Data-Access-RDA" class="headerlink" title="远程数据访问(Remote Data Access,RDA)"></a>远程数据访问(Remote Data Access,RDA)</h4><p>该风格是CS的一种变体，将应用状态分布在客户端和服务端上，如客户端发送一个查询格式(sql或者自定义查询参数)给服务端，服务端执行这个查询，返回一个结果集，客户端可以拿到结果集进行数据筛选或拼接</p><p>有点类似在某险看到的数据服务，提供查询接口，根据自定义参数返回想要的数据</p><p><strong>优点：</strong></p><ul><li>提高了可见性(sql或约定好的参数规则)</li><li>服务端可以进行数据的筛选，避免巨结果集在网络的传输</li></ul><p><strong>缺点：</strong></p><ul><li>降低了服务端的可伸缩性</li><li>部分的故障会导致可靠性的损失</li></ul><h3 id="移动代码风格"><a href="#移动代码风格" class="headerlink" title="移动代码风格"></a>移动代码风格</h3><table><thead><tr><th align="center">风格</th><th align="center">继承</th><th align="center">网络性能</th><th align="center">用户感知的性能</th><th align="center">效率</th><th align="center">可伸缩性</th><th align="center">简单性</th><th align="center">可进化性</th><th align="center">可扩展性</th><th align="center">可定制性</th><th align="center">可配置性</th><th align="center">可重用性</th><th align="center">可见性</th><th align="center">可移植性</th><th align="center">可靠性</th></tr></thead><tbody><tr><td align="center">VM</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">±</td><td align="center"></td><td align="center">+</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">-</td><td align="center">+</td><td align="center"></td></tr><tr><td align="center">REV</td><td align="center">CS+VM</td><td align="center"></td><td align="center"></td><td align="center">+</td><td align="center">-</td><td align="center">±</td><td align="center"></td><td align="center">+</td><td align="center">+</td><td align="center"></td><td align="center"></td><td align="center">-</td><td align="center">+</td><td align="center">-</td></tr><tr><td align="center">COD</td><td align="center">CS+VM</td><td align="center"></td><td align="center">+</td><td align="center">+</td><td align="center">+</td><td align="center">±</td><td align="center"></td><td align="center">+</td><td align="center"></td><td align="center">+</td><td align="center"></td><td align="center">-</td><td align="center"></td><td align="center"></td></tr></tbody></table><h4 id="虚拟机-Virtual-Machine-VM"><a href="#虚拟机-Virtual-Machine-VM" class="headerlink" title="虚拟机(Virtual Machine,VM)"></a>虚拟机(Virtual Machine,VM)</h4><p>所有的移动代码都需要以某种方式来执行，这正是是虚拟机风格，虚拟机通常被当做某些语言的引擎，如JVM</p><p><strong>优点：</strong></p><ul><li>改善了可扩展性(指令和实现的分离，如JVM的Indy指令)</li></ul><p><strong>缺点：</strong></p><ul><li>明显会降低了可见性、简单性</li></ul><h4 id="远程求值-Remote-Evaluation-REV"><a href="#远程求值-Remote-Evaluation-REV" class="headerlink" title="远程求值(Remote Evaluation,REV)"></a>远程求值(Remote Evaluation,REV)</h4><p>顾名思义，类似我们在一些开源组件看到的GLUE模式，或者说Web IDE这种，客户端将需要执行的代码发到服务端，服务端进行执行</p><h4 id="按需代码-Code-on-Demand-COD"><a href="#按需代码-Code-on-Demand-COD" class="headerlink" title="按需代码(Code on Demand,COD)"></a>按需代码(Code on Demand,COD)</h4><p>该风格与上面的REV核心方向是相反的，由客户端访问服务端拿到想要的代码在客户端本地执行</p><p>这种风格在做流程自动化机器人有用到，访问服务端接口拿到动态脚本，客户端这边执行自动化脚本实现页面自动化操作</p><h3 id="点对点-Peer-to-Peer"><a href="#点对点-Peer-to-Peer" class="headerlink" title="点对点(Peer-to-Peer)"></a>点对点(Peer-to-Peer)</h3><table><thead><tr><th align="center">风格</th><th align="center">继承</th><th align="center">网络性能</th><th align="center">用户感知的性能</th><th align="center">效率</th><th align="center">可伸缩性</th><th align="center">简单性</th><th align="center">可进化性</th><th align="center">可扩展性</th><th align="center">可配置性</th><th align="center">可重用性</th><th align="center">可见性</th><th align="center">可移植性</th><th align="center">可靠性</th></tr></thead><tbody><tr><td align="center">EBI</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">+</td><td align="center">–</td><td align="center">±</td><td align="center">+</td><td align="center">+</td><td align="center">+</td><td align="center">+</td><td align="center">-</td><td align="center"></td><td align="center">-</td></tr><tr><td align="center">C2</td><td align="center">EBI+LCS</td><td align="center"></td><td align="center">-</td><td align="center">+</td><td align="center"></td><td align="center">+</td><td align="center">++</td><td align="center">+</td><td align="center">+</td><td align="center">++</td><td align="center">±</td><td align="center">+</td><td align="center">±</td></tr></tbody></table><h4 id="基于事件的集成-Event-based-Integration-EBI"><a href="#基于事件的集成-Event-based-Integration-EBI" class="headerlink" title="基于事件的集成(Event-based Integration,EBI)"></a>基于事件的集成(Event-based Integration,EBI)</h4><p>该风格也被称为隐式调用风格或者事件系统风格，通过消除了解连接器接口的标识信息的必要性，降低了组件之间的耦合</p><p>组件调用是通过发布事件或者广播，由系统本身来调用订阅该事件的组件，基于事件的这种风格为可扩展性、可重用性和可进化性(这些架构属性在第二篇基于网络的架构有详细介绍)提供了强有力的支持</p><p><strong>缺点：</strong></p><ul><li>事件风暴(可伸缩性问题)</li><li>缺乏可理解性</li><li>不适合交换大粒度的数据</li></ul><h4 id="C2"><a href="#C2" class="headerlink" title="C2"></a>C2</h4><p>C2风格是对上面EBI的一个加强，通过增加分层-客户-服务器(LCS)风格来达到支持大粒度的重用和解决了可伸缩问题</p><blockquote><p><code>异步通知</code>消息向下传送，<code>异步请求</code>消息向上传送</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> REST </category>
          
      </categories>
      
      
        <tags>
            
            <tag> REST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rest Notes-基于网络应用的架构</title>
      <link href="/2018/Rest%20Notes-Web%20Based%20Architecture/"/>
      <url>/2018/Rest%20Notes-Web%20Based%20Architecture/</url>
      
        <content type="html"><![CDATA[<p>摘要: 本文为Rest论文的第二章节基于网络应用的架构学习总结，该章同第一章软件架构一样继续讨论论文的背景，主要是对论文要讨论的范围进行一个定义</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文:"></a>正文:</h2><h2 id="基于网络应用的架构"><a href="#基于网络应用的架构" class="headerlink" title="基于网络应用的架构"></a>基于网络应用的架构</h2><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>本文讨论的范围限制在<code>基于网络</code>应用的架构风格</p><h4 id="基于网络-VS-分布式"><a href="#基于网络-VS-分布式" class="headerlink" title="基于网络 VS 分布式"></a>基于网络 VS 分布式</h4><p>基于网络的架构组件之间的通信仅限于消息传递或者消息传递的等价物</p><p>Tanenbaum和van Renesse是这样区分两者：基于网络的系统有能力跨越网络运行，分布式好像是普通的集中式系统，但是运行在多个独立的CPU上</p><h4 id="应用软件-VS-网络软件"><a href="#应用软件-VS-网络软件" class="headerlink" title="应用软件 VS 网络软件"></a>应用软件 VS 网络软件</h4><p>应用软件的架构是对于整个系统的一种抽象，用户动作的目的可以被表示为功能性的架构属性，而网络抽象目的则是将bit从一个地点移动到另一个地点，不关心为何移动</p><blockquote><p>只有在应用的层面上我们才可以拿到详细的运行参数(交互参数、应用状态参数、吞吐量等)等去评估设计上的权衡，所以我们讨论的范围需要限制在对应用软件架构的讨论</p></blockquote><h3 id="关键关注点的架构属性"><a href="#关键关注点的架构属性" class="headerlink" title="关键关注点的架构属性"></a>关键关注点的架构属性</h3><h4 id="性能-Performance"><a href="#性能-Performance" class="headerlink" title="性能(Performance)"></a>性能(Performance)</h4><p>基于网络应用的性能首先取决于应用的需求，然后是所选择的交互风格，接下来是实现架构，最后是每个组件的实现</p><ul><li><p><strong>网络性能(Network Performance)</strong></p><ul><li><strong>吞吐量</strong> 信息在组件之间移交的速率</li><li><strong>开销</strong> 分为初始化开销和每次交互产生的开销</li><li><strong>带宽</strong> 特定网络连接上可用的最大吞吐量</li><li><strong>可用带宽</strong> 应用实际可用的那部分带宽</li></ul></li><li><p><strong>用户感知的性能(User-perceived Performance)</strong></p><ul><li><strong>延迟</strong> 指从最初的触发请求到得到最早的响应指示之间持续的时间</li><li><strong>完成时间</strong> 完成一个应用动作所花费的时间</li></ul><p>延迟与完成时间区别在于一个能够增量的处理数据一个是全部处理完。例如页面的异步加载与全部加载完毕</p></li><li><p><strong>网络效率(Network Efficiency)</strong></p><p>最佳的应用性能是通过不适用网络而获得的，对于基于网络的应用来说有效的减少网络交互才是最高效的架构风格</p><p>我们可以利用缓存、对数据的迁移路径缩短减少某些交互的必要性</p></li></ul><h4 id="可伸缩性-Scalability"><a href="#可伸缩性-Scalability" class="headerlink" title="可伸缩性(Scalability)"></a>可伸缩性(Scalability)</h4><p>我们可以通过以下方法来改善可伸缩性：简化组件、将服务分布到很多组件(对交互去中心化)、以及通过监控对交互和配置进行一般控制</p><p><strong>影响</strong>：</p><ul><li>交互的频率</li><li>组件负载随时间的分布</li><li>强一致性or弱一致性</li><li>同步or异步</li><li>环境</li></ul><h4 id="可修改性-Modifiability"><a href="#可修改性-Modifiability" class="headerlink" title="可修改性(Modifiability)"></a>可修改性(Modifiability)</h4><p>可修改性包括可进化性(一个组件改变不会对其他组件产生负面影响)、可扩展性、可定制性(临时定义的支持)、可配置性(部署之后修改的支持)、可重用性，我们在对一个已部署的应用做出改变时候，不应该去停止和重新启动整个系统，还要准备好应对随着时间的变化产生的兼容性</p><h4 id="可见性-Visibility"><a href="#可见性-Visibility" class="headerlink" title="可见性(Visibility)"></a>可见性(Visibility)</h4><p>可见性是指一个组件对于其他两个组件之间的交互进行监视和斡旋(wo xuan)的能力</p><p>拥有了可见性之后，就能够通过多个交互共享的缓存来改善性能、通过分层服务来改善可伸缩性、通过反射式监控来改善性能、通过允许防火墙等中间件对交互做检查来改善安全性</p><h4 id="可移植性-Portability"><a href="#可移植性-Portability" class="headerlink" title="可移植性(Portability)"></a>可移植性(Portability)</h4><p>这里的可移植性指的是软件能够在不同环境下运行，例如虚拟机架构风格以及那些限制只使用标准格式的数据元素的架构风格</p><h4 id="可靠性-Reliability"><a href="#可靠性-Reliability" class="headerlink" title="可靠性(Reliability)"></a>可靠性(Reliability)</h4><p>从应用的架构角度来说，可靠性可以被看作架构元素出现故障影响的程度</p><p>可以通过避免单点故障、增加冗余、允许监视、以及将故障的范围缩小到一个可恢复的动作</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> REST </category>
          
      </categories>
      
      
        <tags>
            
            <tag> REST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rest Notes-软件架构</title>
      <link href="/2018/Rest%20Notes-Software%20Architecture/"/>
      <url>/2018/Rest%20Notes-Software%20Architecture/</url>
      
        <content type="html"><![CDATA[<p>摘要: 本文为Rest论文的第一章节软件架构学习总结，该章从Rest论文的背景出发，先引入了一些软件架构的概念术语，然后定义了一套自洽的软件架构术语，文中出现的很多人(Perry、Wolf、Shaw、Garlan)都是最早从事软件体系结构研究的</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文:"></a>正文:</h2><h2 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h2><p>一个系统的软件体系结构是由组件(构件)集合、组件(构件)之间的交互、连接器以及互相结合的约束限制和描述来组成的。服务器、数据库、某层次架构的层等都算是所属架构的组件实例</p><h3 id="抽象原则-核心"><a href="#抽象原则-核心" class="headerlink" title="抽象原则(核心)"></a>抽象原则(核心)</h3><p>通过封装隐藏内部源码实现的细节，架构的设计与源代码结构的设计关系应该是相互分离的</p><h3 id="架构元素-Elements"><a href="#架构元素-Elements" class="headerlink" title="架构元素(Elements)"></a>架构元素(Elements)</h3><p>作者将软件架构定义为一些架构元素(组件、连接器和数据)的配置，这些元素之间的关系受到约束，以获得所期待的一组架构属性。</p><blockquote><p>作者认为软件架构不应该包括基础原理这块，虽然基础原理可以影响到一个架构的开发，但是一个架构一旦建成，它将脱离其所基于的基本原理而独立存在。就好像一个大楼建成后蓝图和计划被烧毁了但是楼并不会倒塌。</p></blockquote><h4 id="组件-Components"><a href="#组件-Components" class="headerlink" title="组件(Components)"></a>组件(Components)</h4><p>组件在Perry和Wolf的定义中属于处理元素，也即是执行数据转换的元素，Garlan和Shaw将组件简单描述为执行计算的元素，作者试图更加精确的将组件和连接器区分开来：组件是软件指令和内部状态的抽象单元，通过其接口提供数据的转换能力(包括数据的计算、转换、封装等)</p><blockquote><p>组件的定义应该由其提供的接口和服务来定义而不是隐藏在该接口之后的实现来定义</p></blockquote><h4 id="连接器-Connectors"><a href="#连接器-Connectors" class="headerlink" title="连接器(Connectors)"></a>连接器(Connectors)</h4><p>连接器在Perry和Wolf定位中属于连接元素，也即是将架构的不同部分结合在一起的粘合剂</p><p>**example:**远程过程调用、消息传递协议、数据流</p><p>通过例子可以看出来其连接器其实是来支持组件之间的通信，其内部可能也是通过组件对数据的转换、移交、反转换来达到通信的目的，然而从架构层面可以忽略这些细节</p><h4 id="数据-Data"><a href="#数据-Data" class="headerlink" title="数据(Data)"></a>数据(Data)</h4><p>数据是组件通过连接器接收或发送的信息元素</p><blockquote><p>在对架构做评估时候，一定要去考虑数据元素，一种是直接与组件进行交互，第二种是将组件转化为一个数据元素通过网络进行传输，然后进行反转换得到一个能够在本地与之交互的组件</p></blockquote><h3 id="配置-Configurations"><a href="#配置-Configurations" class="headerlink" title="配置(Configurations)"></a>配置(Configurations)</h3><p>配置是在系统运行期间的组件、连接器和数据之间的架构关系的结构</p><blockquote><p>Abowd等人将架构的描述定义为：组件可以定义为<strong>计算的所在地</strong>，连接器定义为<strong>组件之间的交互</strong>，配置定义为<strong>相互交互的组件和连接器的集合</strong></p></blockquote><h3 id="架构属性-Properties"><a href="#架构属性-Properties" class="headerlink" title="架构属性(Properties)"></a>架构属性(Properties)</h3><p>架构属性比较抽象，举个例子：组件的可重用率、效率、扩展性等非功能属性和具体的功能属性都属于架构属性</p><blockquote><p>架构设计的目标是创建了一个包含一组架构属性的架构，不同架构属性的相对重要性取决于所期待的系统的本身特性</p></blockquote><h3 id="架构风格-Styles"><a href="#架构风格-Styles" class="headerlink" title="架构风格(Styles)"></a>架构风格(Styles)</h3><p>架构<code>风格</code>是一种机制，用来对架构进行分类并且定义它们的公共特征，并约束了架构元素的角色和功能以及元素之间的关系</p><blockquote><p>”风格“常用于描述个性化，使用风格来描述架构约束常常令人迷惑，Loerke将风格描述为挑剔者对过去架构的观点，Loerke认为在传统的建筑架构设计中风格的真正来源是一组应用于设计之上的约束，达到或复制一种特定的风格应该是设计者的最低目标。这样将架构设计的约束称为一种更为抽象的风格表达变的更加容易。可以认为一种架构风格是一组相互协作的架构约束，给它取了个名字罢了</p></blockquote><p>Perry和Wolf认为一种架构风格封装了关于架构元素(组件、连接器、数据)的重要决策，强调元素之间关系的约束</p><p>Garlan和Shaw认为一种架构风格决定了在此架构风格的架构中能够使用哪些组件和连接器</p><blockquote><p>作者认为他们对架构风格的定义比较狭隘，原因是他们将架构看作是形式化的描述，而不是正在运行的系统</p></blockquote><p>虽然一些架构风格常常被描述为适合所有软件的”银弹”式解决方案，但是一个好的设计者应该去选择最为匹配的架构风格。选择一个正确的架构风格需要去理解应用的领域，通信的需求，预测每种交互风格对基于网络通信的特性的敏感度</p><h3 id="模式与模式语言-Patterns-and-Pattern-Lang"><a href="#模式与模式语言-Patterns-and-Pattern-Lang" class="headerlink" title="模式与模式语言(Patterns and Pattern Lang)"></a>模式与模式语言(Patterns and Pattern Lang)</h3><p>在Java这种OOP编程语言领域，一种<code>设计模式</code>被定义为一种重要的和重复出现的系统构造，而一种<code>模式语言</code>是一个模式的系统</p><p>模式的<code>设计空间</code>包括了如java的类继承和接口组合或者更高层次的设计，这个<code>设计空间</code>应该是在架构风格(约束)之下，促使系统出现所期待的架构属性</p><h3 id="视图-Views"><a href="#视图-Views" class="headerlink" title="视图(Views)"></a>视图(Views)</h3><p>架构视图常常特定于应用，并且基于应用而千变万化，而视图的种类更是多种多样</p><p>Perry和Wolf描述了三种重要的软件架构视图：</p><ul><li><p>处理视图</p><p>侧重于流经组件的数据流</p></li><li><p>数据视图</p><p>侧重于处理的流程，而不是连接器</p></li><li><p>连接视图</p><p>侧重于组件之间的关系和通信状态</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> REST </category>
          
      </categories>
      
      
        <tags>
            
            <tag> REST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>API 网关的安全</title>
      <link href="/2018/API-Gateway-Safety/"/>
      <url>/2018/API-Gateway-Safety/</url>
      
        <content type="html"><![CDATA[<p>摘要: 本篇文章是总结工作中遇到的安全问题</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文:"></a>正文:</h2><h1 id="API-网关的安全"><a href="#API-网关的安全" class="headerlink" title="API 网关的安全"></a>API 网关的安全</h1><h2 id="XSRF-CSRF"><a href="#XSRF-CSRF" class="headerlink" title="XSRF/CSRF"></a>XSRF/CSRF</h2><p>**跨站请求伪造(Cross-site request forgery)**是一种挟制用户在当前已登录的web程序上执行非本意的操作的攻击方法，简单来说就是你在浏览器打开了两个页面，其中一个页面通过窃取另一个页面的cookie来发送伪造请求</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>某一家银行转账操作的url地址为：<a href="http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName">http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName</a></p><p>藏身于恶意网站的某代码片段：<code>&lt;img src=&quot;http://www.examplebank.com/withdraw?account=Alice&amp;amount=1000&amp;for=Badman&quot;&gt;</code></p><p>若账户人员为Alice的用户访问了恶意网站，其登录信息尚未过期，就会丢失1000资金</p><p>CSRF攻击并不是直接获取用户账户控制权，而是欺骗用户浏览器，让其已用户的名义执行操作</p><h3 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h3><ol><li><code>HTTP</code>头<code>Referer</code>字段，这个字段用以标明请求来源于哪个地址，看其<code>url</code>是否与要请求地址位于同一域名下</li><li>添加校验<code>Token</code>,恶意网站的请求不带Token无法通过校验</li></ol><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>**跨站脚本(Cross-site scripting)**是一种网站应用程序的安全漏洞攻击，是代码注入的一种。</p><h3 id="防御措施-1"><a href="#防御措施-1" class="headerlink" title="防御措施"></a>防御措施</h3><ol><li><p>过滤特殊字符(转义)</p></li><li><p>使用浏览器自带的xss-filter</p><ul><li>X-XSS-Protection</li></ul></li><li><p>CSP(Content Security Policy)</p><ul><li><p>如限制script src Content-Security-Policy: script-src ‘self’</p></li><li><p>frame-ancestors 限制了当前页面可以被哪些页面以iframe,frame,object等方式加载 </p></li><li><p>Github的CSP参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: default-src &#x27;none&#x27;; </span><br><span class="line">base-uri &#x27;self&#x27;;</span><br><span class="line">block-all-mixed-content;</span><br><span class="line">connect-src &#x27;self&#x27; uploads.github.com status.github.com collector.githubapp.com api.github.com www.google-analytics.com github-cloud.s3.amazonaws.com github-production-repository-file-5c1aeb.s3.amazonaws.com github-production-upload-manifest-file-7fdce7.s3.amazonaws.com github-production-user-asset-6210df.s3.amazonaws.com wss://live.github.com;</span><br><span class="line">font-src assets-cdn.github.com;</span><br><span class="line">form-action &#x27;self&#x27; github.com gist.github.com;</span><br><span class="line">frame-ancestors &#x27;none&#x27;;</span><br><span class="line">frame-src render.githubusercontent.com;</span><br><span class="line">img-src &#x27;self&#x27; data: assets-cdn.github.com identicons.github.com collector.githubapp.com github-cloud.s3.amazonaws.com *.githubusercontent.com; manifest-src &#x27;self&#x27;;</span><br><span class="line">media-src &#x27;none&#x27;;</span><br><span class="line">script-src assets-cdn.github.com;</span><br><span class="line">style-src &#x27;unsafe-inline&#x27; assets-cdn.github.com</span><br></pre></td></tr></table></figure></li></ul></li><li><p>X-Frame-Options:SAMEORIGIN 这个页面只允许同源页面加载</p></li><li><p>Http-Only 保护cookie</p></li></ol><h2 id="JWT的安全"><a href="#JWT的安全" class="headerlink" title="JWT的安全"></a>JWT的安全</h2><p>JWT一种基于JSON的、用于在网络上声明某种主张的令牌，由三部分组成，<strong>头部</strong>、<strong>消息体</strong>与<strong>签名</strong>。</p><p>前端将JWT通过HTTP Header发送给服务端可以有效防护CSRF，但是服务端既然无状态，Token在客户端存储位置就是一个问题</p><h3 id="存放位置"><a href="#存放位置" class="headerlink" title="存放位置"></a>存放位置</h3><ul><li><p>存在Cookie,要使用Http-Only 保护cookie</p></li><li><p>存在Local Storage 无法防止XSS</p><p>LocalStorage 的API通过JavaScript提供的，攻击者可以通过XSS攻击窃取信息，如Token等</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">localStorage</span>.length)&#123;</span><br><span class="line">  <span class="keyword">for</span>(i <span class="keyword">in</span> <span class="built_in">localStorage</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">localStorage</span>.getItem(i));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM Specification notes 1 -Jvm Structure</title>
      <link href="/2018/JVM-Specification-notes-1/"/>
      <url>/2018/JVM-Specification-notes-1/</url>
      
        <content type="html"><![CDATA[<p>摘要: Jvm Structure</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文:"></a>正文:</h2><h2 id="Java-虚拟机结构"><a href="#Java-虚拟机结构" class="headerlink" title="Java 虚拟机结构"></a>Java 虚拟机结构</h2><h3 id="Class文件格式"><a href="#Class文件格式" class="headerlink" title="Class文件格式"></a>Class文件格式</h3><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li>原始类型(基本类型)<ul><li>数值类型{整数[byte8 short16 int32 long64 char16]、浮点[float32 double64]}</li><li>布尔类型{boolean8}</li><li>returnAddress类型{表示一条字节码指令的操作码}</li></ul></li><li>引用类型</li></ul><blockquote><p>编译器应当在编译期间尽最大努力完成可能的类型检查，使得虚拟机在运行期间无需进行这些操作</p><p>编译器会在编译期或运行期会将byte和short类型的数据带符号扩展（Sign-Extend）为相应的int类型数据，将boolean和char类型数据零位扩展（Zero-Extend）为相应的int类型数据</p></blockquote><h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><p>程序运行期间会使用到的运行时数据区</p><h4 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h4><p>每一个虚拟机线程都有自己的PC寄存器，保存Java虚拟机正在执行的字节码指令的地址</p><h4 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h4><p>栈与线程同时创建，存储局部变量与一些过程结果的地方</p><h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>可供各条线程共享的运行时内存区域，也是供所有类实例和数组对象分配内存的区域</p><p>Java堆在虚拟机启动的时候就被创建，它存储了被自动内存管理系统所管理的各种对象，这些受管理的对象无需，也无法显式地被销毁    </p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>可供各条线程共享的运行时内存区域</p><p>方法区在虚拟机启动的时候被创建，存储了每一个类的结构信息，例如运行时常量池、字段和方法数据、构造函数和普通方法的字节码内容、还包括一些在类、实例、接口初始化时用到的特殊方法</p><blockquote><p>虽然方法区是堆的逻辑组成部分，但是简单的虚拟机实现可以选择在这个区域不实现垃圾收集</p></blockquote><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>每一个类或接口的常量池的运行时表示形式，它包括了若干种不同的常量：从编译期可知的数值字面量到必须运行期解析后才能获得的方法或字段引用</p><blockquote><p>每一个运行时常量池都分配在Java虚拟机的方法区之中，在类和接口被加载到虚拟机后，对应的运行时常量池就被创建出来</p></blockquote><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>如果支持本地方法栈，则会在线程创建的时候按线程分配</p><h3 id="栈帧-Frame"><a href="#栈帧-Frame" class="headerlink" title="栈帧(Frame)"></a>栈帧(Frame)</h3><p>用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接、方法返回值和异常分派</p><p>栈帧随着方法调用而创建，随着方法结束而销毁，无论方法是正常完成还是异常完成</p><p>栈帧的存储空间分配在Java虚拟机栈</p><p>每一个栈帧都有自己的局部变量表、操作数栈和指向当前方法所属的类的运行时常量池的引用</p><p>栈帧容量的大小仅仅取决于Java虚拟机的实现和方法调用时可被分配的内存</p><p>一条线程只有正在执行某个方法的栈帧是活动的，叫做当前栈帧，对应的方法叫当前方法，定义这个方法的类叫当前类。对局部变量表和操作数栈的各种操作，通常指的是当前栈帧进行的操作</p><blockquote><p>栈帧是线程本地私有的数据，不可能在一个栈帧之中引用另外一条线程的栈帧</p><p>如果当前方法调用了其他方法，或者当前方法执行结束，那这个方法的栈帧就不再是当前栈帧了。当一个新的方法被调用，则会新建一个栈帧并成为当前栈帧，当方法返回时会将结果（当前新的栈帧）返回给上一个栈帧，当前栈帧丢弃，上一个栈帧重新成为当前栈帧。</p></blockquote><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>长度由编译期决定，存储于类和接口的二进制表示之中，既通过方法的Code属性保存及提供给栈帧使用</p><ul><li>一个局部变量可以保存类型boolean、byte、char、short、float、reference和returnAddress的数据</li><li>两个局部变量可以保存类型为long和double的数据</li></ul><p>当方法被调用时候，参数将会传递至从0开始的连续的局部变量表里。如果是实例方法被调用则第0个局部变量一定是this</p><blockquote><p>局部变量使用索引来进行定位访问，0-max</p><p>long和double这种需要两个局部变量的类型，索引取最小的那个局部变量。</p></blockquote><h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>同局部变量表，长度由编译期决定，存储于类和接口的二进制表示之中，既通过方法的Code属性保存及提供给栈帧使用</p><p>操作数栈所属的栈帧在刚刚被创建的时候，操作数栈是空的。</p><p>Java虚拟机提供一些字节码指令来从局部变量表或者对象实例的字段中复制常量或变量值到操作数栈中，也提供了一些指令用于从操作数栈取走数据、操作数据和把操作结果重新入栈。在方法调用的时候，操作数栈也用来准备调用方法的参数以及接收方法返回结果，例子参考<a href="http://itliusir.com/2018/JVM-Instruction-Execution-Flow/">初识jvm指令执行流程</a></p><blockquote><p>一个long或者double类型的数据会占用两个单位的栈深度，其他数据类型则会占用一个单位深度</p></blockquote><h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>在Class文件里面，描述一个方法调用了其他方法，或者访问其成员变量是通过符号引用来表示的，动态链接的作用就是将这些符号引用所表示的方法转换为实际方法的直接引用</p><p>类加载的过程中将要解析掉尚未被解析的符号引用，并且将变量访问转化为访问这些变量的存储结构所在的运行时内存位置的正确偏移量</p><blockquote><p>由于动态链接的存在，通过晚期绑定（Late Binding）使用的其他类的方法和变量在发生变化时，将不会对调用它们的方法构成影响</p></blockquote><h3 id="浮点算法"><a href="#浮点算法" class="headerlink" title="浮点算法"></a>浮点算法</h3><p>Java虚拟机采纳了《IEEE Standard for Binary Floating-Point Arithmetic》（ANSI/IEEE Std. 754-1985，New York）浮点算法规范中的部分子集</p><h4 id="Java虚拟机和IEEE-754中的浮点算法"><a href="#Java虚拟机和IEEE-754中的浮点算法" class="headerlink" title="Java虚拟机和IEEE 754中的浮点算法"></a>Java虚拟机和IEEE 754中的浮点算法</h4><ul><li><p>在Java虚拟机中的浮点操作在遇到非法操作，如被零除（Divison By Zero）、上限溢出（Overflow）、下限溢出（Underflow）和非精确（Inexact）时，不会抛出exception、trap或者其他IEEE 754异常情况中定义的信号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d = <span class="number">1</span>;</span><br><span class="line">System.out.println(d/<span class="number">0</span>); <span class="comment">//Infinity 非exception </span></span><br></pre></td></tr></table></figure></li><li><p>Java虚拟机里面，将浮点数转化为整型数是使用向零舍入(去尾操作)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d = <span class="number">1.61</span>;</span><br><span class="line">System.out.println((<span class="keyword">int</span>)d);<span class="comment">//1 非2</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="初始化方法的特殊命名"><a href="#初始化方法的特殊命名" class="headerlink" title="初始化方法的特殊命名"></a>初始化方法的特殊命名</h3><ul><li><p><code>&lt;init&gt;</code></p><p>在Java虚拟机层面上，Java语言中的构造函数是以一个名为<code>&lt;init&gt;</code>的特殊实例初始化方法的形式出现的</p><p><code>&lt;init&gt;</code>这个方法名称是由编译器命名的，因为它并非一个合法的Java方法名字，不可能通过程序编码的方式实现。实例初始化方法只能在实例的初始化期间，通过Java虚拟机的<code>invokespecial</code>令来调用，只有在实例正在构造的时候，实例初始化方法才可以被调用访问</p></li><li><p><code>&lt;clinit&gt;</code></p><p>类或者接口是通过<code>&lt;clinit&gt;</code>方法完成初始化的，这个名字也是由编译器命名的，没有任何虚拟机字节码指令可以调用这个方法，只有在类的初始化阶段中会被虚拟机自身调用</p></li></ul><h3 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h3><p>抛异常的本质实际上是程序控制权的一种即时的、非局部（Nonlocal）的转换——从异常抛出的地方转换至处理异常的地方</p><ul><li><p>同步异常</p><p>当前线程执行的某个操作所导致的异常</p></li><li><p>异步异常</p><p>其他线程中出现的异常</p></li></ul><blockquote><p>由Java虚拟机执行的每一个方法都会配有零至多个异常处理器（Exception Handlers），异常处理器描述了其在方法代码中的有效作用范围（通过字节码偏移量范围来描述）、能处理的异常类型以及处理异常的代码所在的位置</p><p>当有异常被抛出时，Java虚拟机会搜索当前方法的包含的各个异常处理器，如果能找到可以处理该异常的异常处理器，则将代码控制权转向到异常处理器中描述的处理异常的分支之中</p></blockquote><h3 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h3><p>Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的操作码（Opcode）以及跟随其后的零至多个代表此操作所需参数的操作数（Operands）所构成。虚拟机中许多指令并不包含操作数，只有一个操作码。<br>如果忽略异常处理，那Java虚拟机的解释器使用下面这个伪代码的循环即可有效地工作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123; </span><br><span class="line">  自动计算PC寄存器以及从PC寄存器的位置取出操作码;</span><br><span class="line">  <span class="keyword">if</span> (存在操作数) 取出操作数;</span><br><span class="line">  执行操作码所定义的操作</span><br><span class="line">&#125; <span class="keyword">while</span> (处理下一次循环);</span><br></pre></td></tr></table></figure><p>如果要将一个16位长度的无符号整数使用两个无符号字节存储起来，如下所示</p><p><code>(byte1 &lt;&lt; 8) | byte2</code></p><h4 id="加载和存储指令"><a href="#加载和存储指令" class="headerlink" title="加载和存储指令"></a>加载和存储指令</h4><ul><li><p>xload</p><p>从局部变量加载到操作数栈</p></li><li><p>xstore</p><p>从操作数栈存储到局部变量表</p></li><li><p>xpush，xdc，xconst</p><p>将一个常量加载到操作数栈</p></li><li><p>wide</p><p>扩充局部变量表的访问索引</p></li></ul><h4 id="运算指令"><a href="#运算指令" class="headerlink" title="运算指令"></a>运算指令</h4><p>对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶</p><ul><li><p>整型数据运算</p><p>如：iadd，isub，imul，idiv</p></li><li><p>浮点型数据运算</p><p>如：fadd，fsub，fmul，fdiv</p></li></ul><h4 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h4><p>将两种Java虚拟机数值类型进行相互转换</p><ul><li><p>宽化类型转换</p><p>小范围类型向大范围类型的安全转换，无需显式的转换指令</p></li><li><p>窄化类型转换</p><p>(i2b，i2c，i2s，l2i，f2i，f2l，d2i，d2l，d2f)可能会导致转换结果产生不同的正负号、不同的数量级，数值丢失精度等</p></li></ul><blockquote><p>注意：</p><ol><li>浮点型转整型 NaN-&gt;0</li><li>尽管可能发生上限溢出、下限溢出和精度丢失等情况，但是Java虚拟机中数值类型的窄化转换永远不可能导致虚拟机抛出运行时异常</li></ol></blockquote><h4 id="对象创建与操作"><a href="#对象创建与操作" class="headerlink" title="对象创建与操作"></a>对象创建与操作</h4><ul><li>创建类实例：new</li><li>创建数组：newarray，anewarray，multianewarray</li><li>访问类字段(static)和实例字段(!static)：getfield，putfield，getstatic，putstatic</li><li>将一个数组元素加载到操作数栈：xaload</li><li>将一个操作数栈值储存到数组元素中：xastore</li><li>取数组长度的指令：arraylenth</li><li>检查类实例类型的指令：instanceof，checkcast</li></ul><h4 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h4><ul><li><p>条件分支</p><p>ifeq，iflt，ifle，ifne，ifgt，ifge，ifnull，ifnonnull，if_icmpeq，if_icmpne，if_icmplt，if_icmpgt，if_icmple，if_icmpge，if_acmpeq和if_acmpne</p></li><li><p>复合条件分支</p><p>tableswitch，lookupswitch</p></li><li><p>无条件分支</p><p>goto，goto_w，jsr，jsr_w，ret</p></li></ul><blockquote><p>各种类型的比较最终都会转化为int类型的比较操作：</p><p>boolean类型、byte类型、char类型和short类型的条件分支比较操作，都使用int类型的比较指令来完成。而对于long类型、float类型和double类型的条件分支比较操作，则会先执行相应类型的比较运算指令，运算指令会返回一个整形值到操作数栈中，随后再执行int类型的条件分支比较操作来完成整个分支跳转</p></blockquote><h4 id="方法调用与返回指令"><a href="#方法调用与返回指令" class="headerlink" title="方法调用与返回指令"></a>方法调用与返回指令</h4><ul><li><p>方法调用</p><p>invokevirtual(调用对象的实例方法)；</p><p>invokeinterface(调用接口方法-&gt;找到实现接口的对象-&gt;找出适合的方法；</p><p>invokespecial(调用特殊处理的实例方法：初始化方法 私有方法 父类方法)；</p><p>invokestatic(调用类方法)</p></li><li><p>方法返回</p><p>return(void)</p><p>xreturn(返回类型x)</p></li></ul><h4 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h4><p>在程序中显式抛出异常的操作会由athrow指令实现，除了这种情况，还有别的异常会在其他Java虚拟机指令检测到异常状况时由虚拟机自动抛出</p><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步</p><ul><li><p>方法级同步</p><p>隐式，无需通过字节码指令来控制</p></li><li><p>指令集序列同步</p><p>通常是由Java语言的synchronized块来表示，java虚拟机的指令集有monitorenter和monitorexit两条指令来支持synchronized关键字的语义</p></li><li><p>结构化锁定</p><p>方法调用期间每一个管程退出都与前面的管程进入相匹配的情形，持有与释放次数相等</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM-Spec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识JVM指令执行流程</title>
      <link href="/2018/JVM-Instruction-Execution-Flow/"/>
      <url>/2018/JVM-Instruction-Execution-Flow/</url>
      
        <content type="html"><![CDATA[<p>摘要: 记录下学习JVM指令执行流程的理解</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文:"></a>正文:</h2><h1 id="初识JVM指令执行流程"><a href="#初识JVM指令执行流程" class="headerlink" title="初识JVM指令执行流程"></a>初识JVM指令执行流程</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 0: aload_0</span></span><br><span class="line"><span class="comment"> * 1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"><span class="comment"> * 4: return</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liugang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018-04-28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example1</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为主方法创建一个frame并将其推入线程栈</span></span><br><span class="line"><span class="comment">     * 用于执行方法的是method frame，该frame由两个主要部分组成:</span></span><br><span class="line"><span class="comment">     *  1. local variables Array 局部变量数组--存储方法参数和局部变量位置</span></span><br><span class="line"><span class="comment">     *  2. Operand Stack        操作数栈--执行方法的计算</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * Code:</span></span><br><span class="line"><span class="comment">          * 0: iconst_2</span></span><br><span class="line"><span class="comment">          * 1: iconst_3</span></span><br><span class="line"><span class="comment">          * 2: invokestatic  #2                  // Method add:(II)I</span></span><br><span class="line"><span class="comment">          * 5: istore_1</span></span><br><span class="line"><span class="comment">          * 6: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line"><span class="comment">          * 9: iload_1</span></span><br><span class="line"><span class="comment">          * 10: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V</span></span><br><span class="line"><span class="comment">          * 13: return</span></span><br><span class="line"><span class="comment">          *</span></span><br><span class="line"><span class="comment">          * 步骤：</span></span><br><span class="line"><span class="comment">          * local variables: args(0) result(1)</span></span><br><span class="line"><span class="comment">          * 2 3放入操作数栈中</span></span><br><span class="line"><span class="comment">          * invoke static add a=2 b=3</span></span><br><span class="line"><span class="comment">          * add(int a, int b);</span></span><br><span class="line"><span class="comment">          * add GG,main的操作数栈保存add的return值:5</span></span><br><span class="line"><span class="comment">          * istore_1 将其弹出并将其设置为索引为1(variable result)的变量的值</span></span><br><span class="line"><span class="comment">          * */</span></span><br><span class="line">        <span class="keyword">int</span> result = add(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  get static将java/lang/System.out压入操作数栈</span></span><br><span class="line"><span class="comment">         *  现在操作数栈里有两个值 out和5</span></span><br><span class="line"><span class="comment">         *  invoke virtual 调用PrintStream.println方法</span></span><br><span class="line"><span class="comment">         *  它从操作数栈中弹出两个元素：</span></span><br><span class="line"><span class="comment">             *  第一个元素是一个要传递给println方法的整数参数</span></span><br><span class="line"><span class="comment">             *  第二个元素是对将要调用println方法的对象的引用</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * iload 将局部变量表的0 1位置int型变量2 3加载到栈顶</span></span><br><span class="line"><span class="comment">     * iadd从栈顶弹出两个数 相加 把和送入到栈顶</span></span><br><span class="line"><span class="comment">     * 最后，ireturn弹出顶层元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 0: iload_0</span></span><br><span class="line"><span class="comment">     * 1: iload_1</span></span><br><span class="line"><span class="comment">     * 2: iadd</span></span><br><span class="line"><span class="comment">     * 3: ireturn</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> liugang 2018-04-28 10:47</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考链接:</strong><a href="https://blog.takipi.com/jvm-architecture-101-get-to-know-your-virtual-machine/">jvm-architecture-101-get-to-know-your-virtual-machine</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM-Instruction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈的应用——四则运算表达式</title>
      <link href="/2018/Data-Structure-StackApply1/"/>
      <url>/2018/Data-Structure-StackApply1/</url>
      
        <content type="html"><![CDATA[<p>摘要:本文是看《大话数据结构》栈章节的学习总结</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文:"></a>正文:</h2><h1 id="栈的应用——四则运算表达式"><a href="#栈的应用——四则运算表达式" class="headerlink" title="栈的应用——四则运算表达式"></a>栈的应用——四则运算表达式</h1><blockquote><p>栈的应用场景有很多，如浏览器的后退，编辑软件的回退等，今天要谈的是栈的基本应用之四则运算表达式(中缀转后缀表达式)</p></blockquote><p>大家都知道用计算器可以很方便的计算出两数运算的结果，但是如果遇到有优先级的四则运算，计算器又是如何去精确的计算出结果呢？</p><p>在20世纪50年代有一个叫**<a href="https://zh.wikipedia.org/wiki/%E6%89%AC%C2%B7%E5%8D%A2%E5%8D%A1%E8%A5%BF%E7%BB%B4%E8%8C%A8">Jan Łukasiewicz</a><strong>的波兰数学家想到了</strong>一种不需要括号的后缀表达式，我们称为<a href="https://zh.wikipedia.org/wiki/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95">逆波兰表示法</a>** ，逆波兰记法不需要括号来标识操作符的优先级</p><h2 id="中缀转后缀表达式"><a href="#中缀转后缀表达式" class="headerlink" title="中缀转后缀表达式"></a>中缀转后缀表达式</h2><p>我们平时所用的标准四则运算表达式，如：</p><p><strong><code>150-(7+5)*2+30*2</code></strong></p><p>叫做中缀表达式，因为所有的运算符号都在两个数字之间，现在我们通过使用栈将其转为后缀表达式</p><blockquote><p>规则：</p><p>从左到右遍历上面中缀表达式的每个数字符号</p><ol><li>如果是数字则直接输出</li><li>如果是符号则判断与栈顶中的符号优先级，是右括号的或者比栈顶中符号优先级低的依次去括号出栈输出</li><li>否则在栈中等待最后遍历完依次输出</li></ol></blockquote><h3 id="转换过程"><a href="#转换过程" class="headerlink" title="转换过程"></a>转换过程</h3><ol><li>按照上述规则依次遍历<code>150-(7+5)*2+30*2</code>，150是数字直接输出，<code>-</code>号进栈，第三个是左括号也是符号依然进栈，7是数字直接输出，如下图一所示。</li></ol><p><img src="http://qiniu.itliusir.com/stack1.png" alt="图一"></p><ol start="2"><li>下面接着<code>+</code>号进栈，5输出，接下注意的是右括号，遇到右括号需要匹配前面的左括号，并依次去括号出栈输出(输出了<code>+</code>)。接着<code>*</code>号进栈，2输出，如下图二所示。</li></ol><p><img src="http://qiniu.itliusir.com/stack2-1.png" alt="图二"></p><ol start="3"><li>此时栈顶是<code>*</code>,然后<code>+</code>号<strong>准备进栈</strong>，对比发现<code>+</code>优先级低于栈顶，则栈顶元素依次输出，完了后<code>+</code>号<strong>进栈</strong> 。接着30输出，<code>*</code>比栈顶<code>+</code>优先级高，直接进栈不输出，然后2输出。如下图三所示。</li></ol><p><img src="http://qiniu.itliusir.com/stack3.png" alt="图三"></p><ol start="4"><li>最后遍历结束栈中符号依次输出，最终的后缀表达式结果是**<code>150 7 5 + 2 * - 30 2 * +</code>**</li></ol><h2 id="后缀表达式计算结果"><a href="#后缀表达式计算结果" class="headerlink" title="后缀表达式计算结果"></a>后缀表达式计算结果</h2><p>上述结果：**<code>150 7 5 + 2 * - 30 2 * +</code>**， 可能很多人问转这个有什么用，接下来看的是该后缀表达式的计算过程。</p><blockquote><p>计算规则：从左到右遍历每个数字和符号，遇到数字就进栈，遇到符号将处于栈顶的两个元素出栈并运算，运算结果进栈，一直到最后算出最终结果</p></blockquote><ol><li><strong>150 7 5</strong>依次进栈，<code>+</code>号是符号，将栈顶的 <strong>7 5</strong>出栈并运算(+)，结果是<strong>12</strong>并进栈，<strong>2</strong>是数字同样进栈。如下图四所示。</li></ol><p><img src="http://qiniu.itliusir.com/stack4.png" alt="图四"></p><ol start="2"><li>接着是<code>*</code>号，将栈顶的两个元素运算并重新入栈(<em><em>12 <em>2</em></em>)；然后是<code>-</code>号，栈顶两个元素分别是</em>*150 24<strong>，结果是</strong>126<strong>入栈；然后数字</strong>30 2**依次入栈。如下图五所示。</li></ol><p><img src="http://qiniu.itliusir.com/stack5.png" alt="图五"></p><ol start="3"><li>遍历到<code>*</code>，将栈顶元素<strong>30 2</strong>运算并重新进栈，最后是<code>+</code>号，所以结果是186出栈，栈变为空。如下图六所示。</li></ol><p><img src="http://qiniu.itliusir.com/stack6.png" alt="图六"></p><p><strong>上述过程都充分的利用了栈的后进先出特性来处理的，所以该表达式的转换和计算是栈的经典应用之一，对理解栈本身也有很大的帮助~</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 集群规范</title>
      <link href="/2018/database-redis-cluster-spec/"/>
      <url>/2018/database-redis-cluster-spec/</url>
      
        <content type="html"><![CDATA[<p>摘要:参考官方文档Redis Cluster spec总结的Redis规范</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文:"></a>正文:</h2><h1 id="Redis-集群规范"><a href="#Redis-集群规范" class="headerlink" title="Redis 集群规范"></a>Redis 集群规范</h1><h2 id="安全写入"><a href="#安全写入" class="headerlink" title="安全写入"></a>安全写入</h2><p>两个写入丢失的可能</p><ul><li><p>写入操作到达主节点，主节点异步冗余备份还没传播到从节点时候主节点挂了，该写入会丢失</p><blockquote><p>几率很小，虽然是异步备份，但主节点写入并回复客户端的时间和传播给slave节点时间大致相同</p></blockquote></li><li><p>故障转移时候，一个没有更新路由表的客户端会在主–&gt;从之前做写入操作（几率更小）</p><blockquote><p>原因：长时间无法被大多数主节点访问的节点会被故障转移掉，不再接受任何写入操作，其修复好后仍然会有一小段时间拒绝写入。好让其他节点有时间去告知配置信息的变更</p></blockquote></li></ul><h2 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h2><p>根据redis选举机制，高可用需要至少3台服务器(3个master节点)，每个master节点都至少要有一个salve节点可达，最好是从节点数量&gt;主节点数量</p><blockquote><ol><li>master遇到故障转移到slave后，集群会再次恢复可用</li><li>master故障修复后会重新加入集群成为新master的从节点，防止下次故障</li><li>当从节点有两个就可以多一次故障转移</li></ol></blockquote><p><img src="http://qiniu.itliusir.com/redis-cluster.png" alt="redis-cluster"></p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>在Redis的集群中，节点并不是把命令转发到负责键的节点上，而是把客户端重定向到服务一定范围内的键的节点上。 最终客户端获得一份最新的集群路由表，里面有写着哪些节点服务哪些键，所以在正常操作中客户端是直接联系到对应的节点来发送指令。</p><p>由于使用了异步复制，节点不会等待其他节点对写入操作的回复</p><p>所以普通操作是可以被处理得跟在Redis单机版一样的，在一个拥有 N 个master节点的 Redis 集群中，由于线性扩展的设计，你可以认为同样的操作在集群上的性能是Redis单机版的n倍</p><h2 id="键分布模型"><a href="#键分布模型" class="headerlink" title="键分布模型"></a>键分布模型</h2><p>Redis 集群的键空间被分割为 <code>16384</code> 个槽（slot）， 集群的最大节点数量也是 <code>16384</code> 个。</p><blockquote><p>推荐的最大节点数量为 1000 个左右。</p></blockquote><p>每个主节点都负责处理 <code>16384</code> 个哈希槽的其中一部分。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://redis.io/topics/cluster-spec">Redis Cluster Spec</a></p><p><a href="http://redisdoc.com/topic/cluster-spec.html">Redis 集群规范</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis Cluster spec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 集群部署</title>
      <link href="/2018/database-redis-cluster/"/>
      <url>/2018/database-redis-cluster/</url>
      
        <content type="html"><![CDATA[<p>摘要:最近工作搭建redis集群时候的笔记</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文:"></a>正文:</h2><h1 id="Redis集群搭建"><a href="#Redis集群搭建" class="headerlink" title="Redis集群搭建"></a>Redis集群搭建</h1><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><blockquote><p>系统: CentOS 7.4</p><p>Redis: redis-4.0.2</p><p>ruby: 2.4.2</p></blockquote><h2 id="安装gcc"><a href="#安装gcc" class="headerlink" title="安装gcc"></a>安装gcc</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh gcc-c++-4.8.5-16.el7.x86_64.rpm --nodeps</span><br><span class="line">Preparing...                          ################################# [100%]</span><br><span class="line">Updating / installing...</span><br><span class="line">   1:gcc-c++-4.8.5-16.el7             ################################# [100%]</span><br></pre></td></tr></table></figure><h2 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /opt </span><br><span class="line">tar xzf redis-4.0.2.tar.gz</span><br><span class="line">cd redis-4.0.2</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p><strong>如果因为编译失败可以使用</strong><code>make distclean</code></p><h2 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h2><ul><li><strong>创建redis-cluster目录</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /opt/redis-4.0.2/redis-cluster</span><br><span class="line">cd /opt/redis-4.0.2/redis-cluster</span><br><span class="line">mkdir 7100 7101 7102</span><br></pre></td></tr></table></figure><ul><li><strong>分别修改这三个配置文件，把如下<code>redis.conf 配置</code>内容粘贴进去</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi 7100/redis.conf</span><br><span class="line">vi 7101/redis.conf </span><br><span class="line">vi 7102/redis.conf </span><br></pre></td></tr></table></figure><ul><li><code>redis.conf</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">port 7100</span><br><span class="line">bind 192.168.103.14</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis_7100.pid</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes_7100.conf</span><br><span class="line">cluster-node-timeout 20100</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><ul><li><strong>配置说明</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">端口7100,7101,7102</span></span><br><span class="line">port 7100</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">默认ip为127.0.0.1，需要改为其他节点机器可访问的ip，否则创建集群时无法访问对应的端口，无法创建集群</span></span><br><span class="line">bind 192.168.103.14</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">redis后台运行</span></span><br><span class="line">daemonize yes</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">pidfile文件对应7100，7101，7102</span></span><br><span class="line">pidfile /var/run/redis_7100.pid</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">开启集群，把注释<span class="comment">#去掉</span></span></span><br><span class="line">cluster-enabled yes</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">集群的配置，配置文件首次启动自动生成 7100，7101，7102</span>          </span><br><span class="line">cluster-config-file nodes_7100.conf</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">请求超时，默认15秒，可自行设置</span> </span><br><span class="line">cluster-node-timeout 20100    </span><br><span class="line">        </span><br><span class="line"><span class="meta">#</span><span class="bash">aof日志开启，有需要就开启，它会每次写操作都记录一条日志</span></span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><ul><li><strong>在另外一台机器上重复以上操作，目录和端口改为7103、7104、7105</strong></li></ul><h2 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 第一台机器上执行 3个节点</span></span><br><span class="line">for((i=0;i&lt;=2;i++)); do /opt/redis-4.0.2/src/redis-server /opt/redis-4.0.2/redis-cluster/710$i/redis.conf; done</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">第二台机器上执行 3个节点</span></span><br><span class="line">for((i=3;i&lt;=5;i++)); do /opt/redis-4.0.2/src/redis-server /opt/redis-4.0.2/redis-cluster/710$i/redis.conf; done</span><br></pre></td></tr></table></figure><h2 id="检查服务"><a href="#检查服务" class="headerlink" title="检查服务"></a>检查服务</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep redis   //redis是否启动成功</span><br><span class="line">netstat -tnlp | grep redis  //监听redis端口</span><br></pre></td></tr></table></figure><h2 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h2><p>现在我们已经有了六个正在运行中的 Redis 实例，通过使用 Redis 集群命令行工具 redis-trib ， 编写节点配置文件的工作可以非常容易地完成： redis-trib 位于 Redis 源码的 src 文件夹中， 它是一个 Ruby 程序， 这个程序通过向实例发送特殊命令来完成创建新集群， 检查集群， 或者对集群进行重新分片（reshared）等工作。所以我们先来安装ruby。</p><h3 id="安装ruby"><a href="#安装ruby" class="headerlink" title="安装ruby"></a>安装ruby</h3><p>通过yum安装的ruby往往版本较低，这里使用安装包安装</p><p><a href="http://cache.ruby-lang.org/pub/ruby/">下载地址</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar -xvzf ruby-2.4.2.tar.gz</span><br><span class="line">cd ruby-2.4.2</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>安装完成后，可以查看是否安装成功，若遇到没有输出版本可以重新打开命令窗口试试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -v</span><br></pre></td></tr></table></figure><p>接下来我们安装redis依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install redis</span><br></pre></td></tr></table></figure><h3 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h3><p>接下来我们使用 Redis 集群命令行工具 redis-trib，在其中一台机器上运行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/redis-4.0.2/src/redis-trib.rb create --replicas 1 192.168.103.14:7100 192.168.103.14:7101 192.168.103.14:7102 192.168.103.28:7103 192.168.103.28:7104 192.168.103.28:7105</span><br></pre></td></tr></table></figure><p>会出现如下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Creating cluster</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Performing <span class="built_in">hash</span> slots allocation on 6 nodes...</span></span><br><span class="line">Using 3 masters:</span><br><span class="line">192.168.103.14:7100</span><br><span class="line">192.168.103.28:7103</span><br><span class="line">192.168.103.14:7101</span><br><span class="line">Adding replica 192.168.103.28:7104 to 192.168.103.14:7100</span><br><span class="line">Adding replica 192.168.103.14:7102 to 192.168.103.28:7103</span><br><span class="line">Adding replica 192.168.103.28:7105 to 192.168.103.14:7101</span><br><span class="line">M: c190d12629fd227c909caa96f5e978ff996364ed 192.168.103.14:7100</span><br><span class="line">   slots:0-5460 (5461 slots) master</span><br><span class="line">M: 77ea96b2eb31b0dd44acc986fe8484358cd9863f 192.168.103.14:7101</span><br><span class="line">   slots:10923-16383 (5461 slots) master</span><br><span class="line">S: b08c0a2e59ef7564eeda7f8d7ca08ec7f3766c1d 192.168.103.14:7102</span><br><span class="line">   replicates 76d59f4caaf766bea9122b1e6327e13721c8ca3b</span><br><span class="line">M: 76d59f4caaf766bea9122b1e6327e13721c8ca3b 192.168.103.28:7103</span><br><span class="line">   slots:5461-10922 (5462 slots) master</span><br><span class="line">S: 77abb939328acb2198fe3e4a495c217d25b91cda 192.168.103.28:7104</span><br><span class="line">   replicates c190d12629fd227c909caa96f5e978ff996364ed</span><br><span class="line">S: 82f48a3c8d0d684fe31254fd4115d8c3b5622f4e 192.168.103.28:7105</span><br><span class="line">   replicates 77ea96b2eb31b0dd44acc986fe8484358cd9863f</span><br><span class="line">Can I set the above configuration? (type &#x27;yes&#x27; to accept): yes</span><br></pre></td></tr></table></figure><p><strong>输入yes继续</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Nodes configuration updated</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Assign a different config epoch to each node</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span></span><br><span class="line">Waiting for the cluster to join....</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Performing Cluster Check (using node 192.168.103.14:7100)</span></span><br><span class="line">M: c190d12629fd227c909caa96f5e978ff996364ed 192.168.103.14:7100</span><br><span class="line">   slots:0-5460 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 77ea96b2eb31b0dd44acc986fe8484358cd9863f 192.168.103.14:7101</span><br><span class="line">   slots:10923-16383 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 82f48a3c8d0d684fe31254fd4115d8c3b5622f4e 192.168.103.28:7105</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 77ea96b2eb31b0dd44acc986fe8484358cd9863f</span><br><span class="line">S: b08c0a2e59ef7564eeda7f8d7ca08ec7f3766c1d 192.168.103.14:7102</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 76d59f4caaf766bea9122b1e6327e13721c8ca3b</span><br><span class="line">M: 76d59f4caaf766bea9122b1e6327e13721c8ca3b 192.168.103.28:7103</span><br><span class="line">   slots:5461-10922 (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 77abb939328acb2198fe3e4a495c217d25b91cda 192.168.103.28:7104</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates c190d12629fd227c909caa96f5e978ff996364ed</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Check slots coverage...</span></span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure><p>可以看到master节点分别是<code>14:7100(0-5460)</code>、<code>14:7101(10923-16383)</code>、<code>28:7103(5461-10922)</code>，salve节点分别是<code>28:7150</code> 、<code>14:7102</code> 、<code>28:7104</code></p><p>对应关系可以根据上面可以看到分别是3主3从</p><p><strong>若输入yes后出现</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Can I set the above configuration? (type &#x27;yes&#x27; to accept): yes</span><br><span class="line">/usr/local/lib/ruby/gems/2.4.0/gems/redis-4.0.1/lib/redis/client.rb:119:in `call&#x27;: ERR Slot 5798 is already busy (Redis::CommandError)</span><br><span class="line">from /usr/local/lib/ruby/gems/2.4.0/gems/redis-4.0.1/lib/redis.rb:2764:in `block in method_missing&#x27;</span><br><span class="line">from /usr/local/lib/ruby/gems/2.4.0/gems/redis-4.0.1/lib/redis.rb:45:in `block in synchronize&#x27;</span><br><span class="line">from /usr/local/lib/ruby/2.4.0/monitor.rb:214:in `mon_synchronize&#x27;</span><br><span class="line">from /usr/local/lib/ruby/gems/2.4.0/gems/redis-4.0.1/lib/redis.rb:45:in `synchronize&#x27;</span><br><span class="line">from /usr/local/lib/ruby/gems/2.4.0/gems/redis-4.0.1/lib/redis.rb:2763:in `method_missing&#x27;</span><br><span class="line">from /opt/redis-4.0.2/src/redis-trib.rb:212:in `flush_node_config&#x27;</span><br><span class="line">from /opt/redis-4.0.2/src/redis-trib.rb:776:in `block in flush_nodes_config&#x27;</span><br><span class="line">from /opt/redis-4.0.2/src/redis-trib.rb:775:in `each&#x27;</span><br><span class="line">from /opt/redis-4.0.2/src/redis-trib.rb:775:in `flush_nodes_config&#x27;</span><br><span class="line">from /opt/redis-4.0.2/src/redis-trib.rb:1296:in `create_cluster_cmd&#x27;</span><br><span class="line">from /opt/redis-4.0.2/src/redis-trib.rb:1700:in `&lt;main&gt;&#x27;</span><br></pre></td></tr></table></figure><p><strong>解决办法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 每个节点执行以下命令,然后重新执行创建集群命令</span></span><br><span class="line">/opt/redis-4.0.2/src/redis-cli -h 192.168.103.14 -p 7100</span><br><span class="line">192.168.103.14:7100&gt; flushall</span><br><span class="line">OK</span><br><span class="line">192.168.103.14:7100&gt; cluster reset soft</span><br><span class="line">OK</span><br><span class="line">192.168.103.14:7100&gt; exit</span><br><span class="line">...</span><br><span class="line">/opt/redis-4.0.2/src/redis-cli -h 192.168.103.28 -p 7103</span><br><span class="line">192.168.103.28:7103&gt; flushall</span><br><span class="line">OK</span><br><span class="line">192.168.103.28:7103&gt; cluster reset soft</span><br><span class="line">OK</span><br><span class="line">192.168.103.28:7103&gt; exit</span><br></pre></td></tr></table></figure><h3 id="集群验证"><a href="#集群验证" class="headerlink" title="集群验证"></a>集群验证</h3><h4 id="连接集群测试"><a href="#连接集群测试" class="headerlink" title="连接集群测试"></a>连接集群测试</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 选择一个节点<span class="built_in">set</span>值</span></span><br><span class="line">/opt/redis-4.0.2/src/redis-cli -c -h 192.168.103.28 -p 7104</span><br><span class="line">192.168.103.28:7104&gt; set name admin</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> Redirected to slot [5798] located at 192.168.103.28:7103</span></span><br><span class="line">OK</span><br><span class="line">192.168.103.28:7103&gt; get name</span><br><span class="line">&quot;admin&quot;</span><br><span class="line">192.168.103.28:7103&gt; exit</span><br><span class="line"><span class="meta">#</span><span class="bash"> 换个节点测试</span></span><br><span class="line">[root@server28 /]# /opt/redis-4.0.2/src/redis-cli -c -h 192.168.103.14 -p 7101</span><br><span class="line">192.168.103.14:7101&gt; get name</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> Redirected to slot [5798] located at 192.168.103.28:7103</span></span><br><span class="line">&quot;admin&quot;</span><br><span class="line">192.168.103.28:7103&gt; exit</span><br></pre></td></tr></table></figure><p>可以发现<code>name &quot;admin&quot;</code>被放置在<code>28:7103</code>主节点上，槽位是(5461-10922)</p><blockquote><p>注: Redis 集群没有使用一致性hash, 而是引入了 <strong>哈希槽</strong>的概念.</p><p>Redis 集群有16384个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽,举个例子,比如当前集群有3个节点,那么:</p><ul><li><p>节点 A 包含 0 到 5500号哈希槽.</p></li><li><p>节点 B 包含5501 到 11000 号哈希槽.</p></li><li><p>节点 C 包含11001 到 16384号哈希槽.</p><p>这种结构很容易添加或者删除节点. 比如如果我想新添加个节点D, 我需要从节点 A, B, C中得部分槽到D上. 如果我想移除节点A,需要将A中的槽移到B和C节点上,然后将没有任何槽的A节点从集群中移除即可. 由于从一个节点将哈希槽移动到另一个节点并不会停止服务,所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态.</p></li></ul></blockquote><h4 id="检查集群状态"><a href="#检查集群状态" class="headerlink" title="检查集群状态"></a>检查集群状态</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/opt/redis-4.0.2/src/redis-trib.rb check 192.168.103.14:7100</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Performing Cluster Check (using node 192.168.103.14:7100)</span></span><br><span class="line">M: c190d12629fd227c909caa96f5e978ff996364ed 192.168.103.14:7100</span><br><span class="line">   slots:0-5460 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 77ea96b2eb31b0dd44acc986fe8484358cd9863f 192.168.103.14:7101</span><br><span class="line">   slots:10923-16383 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 82f48a3c8d0d684fe31254fd4115d8c3b5622f4e 192.168.103.28:7105</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 77ea96b2eb31b0dd44acc986fe8484358cd9863f</span><br><span class="line">S: b08c0a2e59ef7564eeda7f8d7ca08ec7f3766c1d 192.168.103.14:7102</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 76d59f4caaf766bea9122b1e6327e13721c8ca3b</span><br><span class="line">M: 76d59f4caaf766bea9122b1e6327e13721c8ca3b 192.168.103.28:7103</span><br><span class="line">   slots:5461-10922 (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 77abb939328acb2198fe3e4a495c217d25b91cda 192.168.103.28:7104</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates c190d12629fd227c909caa96f5e978ff996364ed</span><br></pre></td></tr></table></figure><h4 id="列出集群节点"><a href="#列出集群节点" class="headerlink" title="列出集群节点"></a>列出集群节点</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/opt/redis-4.0.2/src/redis-cli -c -h 192.168.103.14 -p 7101</span><br><span class="line">192.168.103.14:7101&gt; cluster nodes</span><br><span class="line">77abb939328acb2198fe3e4a495c217d25b91cda 192.168.103.28:7104@17104 slave c190d12629fd227c909caa96f5e978ff996364ed 0 1523435804915 5 connected</span><br><span class="line">76d59f4caaf766bea9122b1e6327e13721c8ca3b 192.168.103.28:7103@17103 master - 0 1523435804000 4 connected 5461-10922</span><br><span class="line">82f48a3c8d0d684fe31254fd4115d8c3b5622f4e 192.168.103.28:7105@17105 slave 77ea96b2eb31b0dd44acc986fe8484358cd9863f 0 1523435805918 6 connected</span><br><span class="line">b08c0a2e59ef7564eeda7f8d7ca08ec7f3766c1d 192.168.103.14:7102@17102 slave 76d59f4caaf766bea9122b1e6327e13721c8ca3b 0 1523435803000 4 connected</span><br><span class="line">77ea96b2eb31b0dd44acc986fe8484358cd9863f 192.168.103.14:7101@17101 myself,master - 0 1523435803000 2 connected 10923-16383</span><br><span class="line">c190d12629fd227c909caa96f5e978ff996364ed 192.168.103.14:7100@17100 master - 0 1523435806920 1 connected 0-5460</span><br></pre></td></tr></table></figure><h4 id="打印集群信息"><a href="#打印集群信息" class="headerlink" title="打印集群信息"></a>打印集群信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">192.168.103.14:7101&gt; cluster info</span><br><span class="line">cluster_state:ok</span><br><span class="line">cluster_slots_assigned:16384</span><br><span class="line">cluster_slots_ok:16384</span><br><span class="line">cluster_slots_pfail:0</span><br><span class="line">cluster_slots_fail:0</span><br><span class="line">cluster_known_nodes:6</span><br><span class="line">cluster_size:3</span><br><span class="line">cluster_current_epoch:6</span><br><span class="line">cluster_my_epoch:2</span><br><span class="line">cluster_stats_messages_ping_sent:1605</span><br><span class="line">cluster_stats_messages_pong_sent:1682</span><br><span class="line">cluster_stats_messages_meet_sent:5</span><br><span class="line">cluster_stats_messages_sent:3292</span><br><span class="line">cluster_stats_messages_ping_received:1681</span><br><span class="line">cluster_stats_messages_pong_received:1610</span><br><span class="line">cluster_stats_messages_meet_received:1</span><br><span class="line">cluster_stats_messages_received:3292</span><br></pre></td></tr></table></figure><h4 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h4><p><code>cluster meet  &lt;ip&gt; &lt;port&gt;</code><strong>将 ip 和 port 所指定的节点添加到集群当中</strong></p><p><code>cluster forget &lt;node_id&gt;</code>  <strong>从集群中移除 node_id 指定的节点</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">192.168.103.14:7100&gt; cluster meet 192.168.103.28 7106</span><br><span class="line">OK</span><br><span class="line">192.168.103.14:7100&gt; cluster nodes</span><br><span class="line">047f60047efa74c6f597e935b8b5896c15057cf6 192.168.103.28:7106@17106 master - 0 1523448401000 0 connected</span><br><span class="line">77ea96b2eb31b0dd44acc986fe8484358cd9863f 192.168.103.14:7101@17101 master - 0 1523448401961 2 connected 10923-16383</span><br><span class="line">82f48a3c8d0d684fe31254fd4115d8c3b5622f4e 192.168.103.28:7105@17105 slave 77ea96b2eb31b0dd44acc986fe8484358cd9863f 0 1523448402964 6 connected</span><br><span class="line">b08c0a2e59ef7564eeda7f8d7ca08ec7f3766c1d 192.168.103.14:7102@17102 slave 76d59f4caaf766bea9122b1e6327e13721c8ca3b 0 1523448403965 4 connected</span><br><span class="line">76d59f4caaf766bea9122b1e6327e13721c8ca3b 192.168.103.28:7103@17103 master - 0 1523448402000 4 connected 5461-10922</span><br><span class="line">77abb939328acb2198fe3e4a495c217d25b91cda 192.168.103.28:7104@17104 slave c190d12629fd227c909caa96f5e978ff996364ed 0 1523448404969 5 connected</span><br><span class="line">c190d12629fd227c909caa96f5e978ff996364ed 192.168.103.14:7100@17100 myself,master - 0 1523448401000 1 connected 0-5460</span><br><span class="line">192.168.103.14:7100&gt; cluster forget 047f60047efa74c6f597e935b8b5896c15057cf6</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p><code>cluster nodes</code>命令的结果含义如下：</p><ul><li>节点ID</li><li>IP:端口</li><li>标志: master, slave, myself, fail, …</li><li>如果是个从节点, 这里是它的主节点的NODE ID</li><li>集群最近一次向节点发送 PING 命令之后， 过去了多长时间还没接到回复。.</li><li>节点最近一次返回 PONG 回复的时间。</li><li>节点的配置纪元（configuration epoch）：详细信息请参考 Redis 集群规范 。</li><li>本节点的网络连接情况：例如 connected 。</li><li>节点目前包含的槽：例如 192.168.103.28:7103 目前包含号码为 5960 至 10921 的哈希槽。</li></ul><p><strong>使用redis-trib.rb 新增节点</strong></p><ol><li>添加master节点</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/redis-4.0.2/src/redis-trib.rb add-node 192.168.103.28:7106 192.168.103.14:7100</span><br></pre></td></tr></table></figure><ol start="2"><li>添加salve节点(随机选一个主节点),前提是节点要为空</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/redis-4.0.2/src/redis-trib.rb add-node --slave 192.168.103.28:7106 192.168.103.14:7100</span><br></pre></td></tr></table></figure><ol start="3"><li>添加salve节点(指定主节点为192.168.103.14:7101)</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/redis-4.0.2/src/redis-trib.rb add-node --slave --master-id 77ea96b2eb31b0dd44acc986fe8484358cd9863f 192.168.103.28:7106 192.168.103.14:7100</span><br></pre></td></tr></table></figure><p>​    也可以使用cluster replicate</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.103.28:7106&gt; cluster replicate 77ea96b2eb31b0dd44acc986fe8484358cd9863f</span><br></pre></td></tr></table></figure><p><strong>使用redis-trib.rb 移除节点</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/redis-4.0.2/src/redis-trib.rb del-node 192.168.103.14:7100 `&lt;node-id&gt;`</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://segmentfault.com/a/1190000010682551">CentOs7.3 搭建 Redis-4.0.1 Cluster 集群服务</a></p><p><a href="http://www.redis.cn/topics/cluster-tutorial.html">Redis 集群教程</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis Cluster </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud Netflix OSS 学习总结</title>
      <link href="/2018/SpringCloud-Netflix/"/>
      <url>/2018/SpringCloud-Netflix/</url>
      
        <content type="html"><![CDATA[<p>摘要: 本篇博客是使用SpringCloud框架开发微服务时候的一篇技术分享</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文:"></a>正文:</h2><h1 id="Spring-Cloud-Netflix-OSS"><a href="#Spring-Cloud-Netflix-OSS" class="headerlink" title="Spring Cloud Netflix OSS"></a><code>Spring Cloud Netflix OSS</code></h1><p>提供了对<code>Netflix</code>开源项目的集成，使我们可以以Spring Boot编程风格使用<code>Netflix</code>旗下相关框架，只需要在程序里添加注解，就可以使用成熟的<code>Netflix</code>组件(<code>Eureka</code>、<code>Hystrix</code>、<code>Zuul</code>、<code>Ribbon</code>、<code>Sidecar</code>)</p><h2 id="Spring-Cloud-Eureka"><a href="#Spring-Cloud-Eureka" class="headerlink" title="Spring Cloud Eureka"></a>Spring Cloud Eureka</h2><h3 id="Eureka客户端"><a href="#Eureka客户端" class="headerlink" title="Eureka客户端"></a>Eureka客户端</h3><ul><li><p>向<code>Eureka</code>注册服务</p></li><li><p>高可用(HA)</p><ul><li><p>多注册中心主机</p><p>如果配置了多个Eureka注册服务器，那么默认情况只有一台可用的服务器，存在注册信息。如果Down掉了，则会选择下一台可用的Eureka服务器。</p></li></ul></li><li><p>配置</p><ul><li><p>应用间隔</p><p><code>registry-fetch-interval-seconds: </code>30 去服务端获取注册信息的间隔时间</p></li><li><p>同步间隔</p><p><code>instance-info-replication-interval-seconds: </code>30 更新实例信息的变化到服务端的间隔时间</p></li></ul><p><a href="http://cloud.spring.io/spring-cloud-static/Dalston.SR4/single/spring-cloud.html#_appendix_compendium_of_configuration_properties">参考链接</a></p></li><li><p>注意</p><ul><li>端口不要使用0</li><li>Eureka缓存<ol><li>Eureka Server对注册列表进行缓存，默认时间为30s。</li><li>Eureka Client对获取到的注册信息进行缓存，默认时间为30s。</li><li>Ribbon会从上面提到的Eureka Client获取服务列表，将负载均衡后的结果缓存30s。</li></ol></li></ul></li></ul><h3 id="Eureka服务端"><a href="#Eureka服务端" class="headerlink" title="Eureka服务端"></a>Eureka服务端</h3><p><img src="http://qiniu.itliusir.com/Eureka.png" alt="img"></p><ul><li>注册中心对比</li></ul><table><thead><tr><th align="center"><code>Feature</code></th><th align="center"><a href="https://github.com/hashicorp/consul">Consul</a></th><th align="center"><a href="https://github.com/apache/zookeeper">zookeeper</a></th><th align="center"><a href="https://github.com/coreos/etcd">etcd</a></th><th align="center"><a href="https://github.com/Netflix/eureka">euerka</a></th></tr></thead><tbody><tr><td align="center">服务健康检查</td><td align="center">服务状态，内存，硬盘等</td><td align="center">(弱)长连接，<code>keepalive</code></td><td align="center">连接心跳</td><td align="center">可配支持</td></tr><tr><td align="center">多数据中心</td><td align="center">支持</td><td align="center">—</td><td align="center">—</td><td align="center">—</td></tr><tr><td align="center">kv存储服务</td><td align="center">支持</td><td align="center">支持</td><td align="center">支持</td><td align="center">—</td></tr><tr><td align="center">一致性</td><td align="center"><code>raft</code></td><td align="center"><code>paxos</code></td><td align="center"><code>raft</code></td><td align="center">—</td></tr><tr><td align="center"><code>cap</code></td><td align="center"><code>ca</code></td><td align="center"><code>cp</code></td><td align="center"><code>cp</code></td><td align="center"><code>ap</code></td></tr><tr><td align="center">使用接口(多语言能力)</td><td align="center">支持<code>http</code>和<code>dns</code></td><td align="center">客户端</td><td align="center"><code>http/grpc</code></td><td align="center"><code>http</code>（sidecar）</td></tr><tr><td align="center">watch支持</td><td align="center">全量/支持long polling</td><td align="center">支持</td><td align="center">支持 long polling</td><td align="center">支持 long polling/大部分增量</td></tr><tr><td align="center">自身监控</td><td align="center"><code>metrics</code></td><td align="center">—</td><td align="center"><code>metrics</code></td><td align="center"><code>metrics</code></td></tr><tr><td align="center">安全</td><td align="center"><code>acl /https</code></td><td align="center"><code>acl</code></td><td align="center"><code>https</code>支持（弱）</td><td align="center">—</td></tr><tr><td align="center">spring cloud集成</td><td align="center">已支持</td><td align="center">已支持</td><td align="center">已支持</td><td align="center">已支持</td></tr></tbody></table><ul><li><p>CAP</p><ul><li><p><em>C</em> <strong>数据一致性</strong>     一致性是指数据的原子性，在经典的数据库中通过事务来保障，事务完成时，无论成功或回滚，数据都会处于一致的状态，在分布式环境下，一致性是指多个节点数据是否一致</p><p><a href="http://thesecretlivesofdata.com/raft/">raft</a> </p></li><li><p><em>A</em> <strong>服务可用性</strong> 服务一直保持可用的状态，当用户发出一个请求，服务能在一定的时间内返回结果</p></li><li><p><em>P</em> <strong>网络分区故障的容错性</strong> 在分布式应用中，可能因为一些分布式的原因导致系统无法运转，好的分区容忍性，使应用虽然是一个分布式系统，但是好像一个可以正常运转的整体</p></li></ul></li><li><p>Consul</p><ul><li>服务发现</li><li>健康检查</li><li>键值存储</li><li>多数据中心</li></ul><p><a href="https://www.consul.io/intro/index.html">官网</a></p><p><a href="http://cloud.spring.io/spring-cloud-consul/">Spring Cloud Consul 参考文档</a></p></li><li><p>Eureka Server高可用配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">peer1</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">peer1</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://peer2/eureka/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">peer2</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">peer2</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://peer1/eureka/</span></span><br></pre></td></tr></table></figure><p><a href="http://cloud.spring.io/spring-cloud-static/Dalston.SR4/single/spring-cloud.html#_peer_awareness">参考文档</a></p></li></ul><h2 id="Spring-Cloud-Ribbon"><a href="#Spring-Cloud-Ribbon" class="headerlink" title="Spring Cloud Ribbon"></a>Spring Cloud Ribbon</h2><p>主要功能是为REST客户端实现负载均衡</p><h3 id="Netflix-Ribbon"><a href="#Netflix-Ribbon" class="headerlink" title="Netflix Ribbon"></a>Netflix Ribbon</h3><ul><li><p>依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Ribbon 客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@RibbonClients(&#123;</span></span><br><span class="line"><span class="meta">        @RibbonClient(name = &quot;service-provider&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置</p><p><code>application.properties</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">service-provider.ribbon.listOfServers</span> = <span class="string">\</span></span><br><span class="line"><span class="string">  http://$&#123;host&#125;:$&#123;port&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Netflix-Ribbon-整合-Eureka"><a href="#Netflix-Ribbon-整合-Eureka" class="headerlink" title="Netflix Ribbon 整合 Eureka"></a>Netflix Ribbon 整合 Eureka</h3><ul><li><p>Ribbon 客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@RibbonClients(&#123;</span></span><br><span class="line"><span class="meta">        @RibbonClient(name = &quot;service-provider&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置</p></li></ul><h2 id="Spring-Cloud-OpenFeign"><a href="#Spring-Cloud-OpenFeign" class="headerlink" title="Spring Cloud OpenFeign"></a>Spring Cloud OpenFeign</h2><ul><li><p>发展</p><p>9.0.0版本之后groupId <code>io.netflix.feign</code>更改为<code>io.github.openfeign</code></p><p>对应依赖<code>spring-cloud-starter-feign</code>–&gt;<code>spring-cloud-starter-openfeign</code></p></li><li><p>依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-feign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>feign 客户端</p><p><code>Application.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>feignClient.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;ms-business-task-engine-server&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITaskEngineService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/TaskQueue/addTaskToQueue&quot;,method = RequestMethod.POST)</span></span><br><span class="line">    <span class="function">BaseResponse <span class="title">addTaskToQueue</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;SubTaskDTO&gt; subTaskDTOList)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>配置参考ribbon</p></li></ul><h2 id="Spring-Cloud-Hystrix"><a href="#Spring-Cloud-Hystrix" class="headerlink" title="Spring Cloud Hystrix"></a>Spring Cloud Hystrix</h2><p>hystrix可帮助隔离每个服务，使单个服务的响应失败，避免微服务架构中因个别服务出现异常而引起级联故障蔓延。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>断路器机制(断路–&gt;半开–&gt;恢复)</li><li>资源隔离</li><li>熔断降级</li></ul><h3 id="Hystrix-Dashboard-监控"><a href="#Hystrix-Dashboard-监控" class="headerlink" title="Hystrix Dashboard 监控"></a>Hystrix Dashboard 监控</h3><h2 id="Spring-Cloud-Zuul"><a href="#Spring-Cloud-Zuul" class="headerlink" title="Spring Cloud Zuul"></a>Spring Cloud Zuul</h2><p>在没有网关的时候，随着系统不断庞大，运维维护越来越复杂，接口校验逻辑的冗余越来越多，校验逻辑升级更为复杂。</p><h3 id="ZuulFilter"><a href="#ZuulFilter" class="headerlink" title="ZuulFilter"></a>ZuulFilter</h3><h4 id="过滤器类型"><a href="#过滤器类型" class="headerlink" title="过滤器类型"></a>过滤器类型</h4><ul><li>pre 路由之前执行</li><li>route 路由请求时被调用</li><li>post 在route和error过滤器之后被过滤</li><li>error 处理请求发生错误时候被调用</li></ul><h4 id="过滤器执行顺序"><a href="#过滤器执行顺序" class="headerlink" title="过滤器执行顺序"></a>过滤器执行顺序</h4><ul><li>order越小，优先级越高</li></ul><h4 id="过滤器是否被执行"><a href="#过滤器是否被执行" class="headerlink" title="过滤器是否被执行"></a>过滤器是否被执行</h4><ul><li>shouldFilter = true(结合yaml控制开启)</li></ul><h4 id="过滤器具体逻辑"><a href="#过滤器具体逻辑" class="headerlink" title="过滤器具体逻辑"></a>过滤器具体逻辑</h4><ul><li>run()</li></ul><h3 id="Routes"><a href="#Routes" class="headerlink" title="Routes"></a>Routes</h3><p>路由规则与列表</p><h2 id="Spring-Cloud-Sidecar"><a href="#Spring-Cloud-Sidecar" class="headerlink" title="Spring Cloud Sidecar"></a>Spring Cloud Sidecar</h2><h3 id="非JVM语言接入SpringCloud的两种方案"><a href="#非JVM语言接入SpringCloud的两种方案" class="headerlink" title="非JVM语言接入SpringCloud的两种方案"></a>非JVM语言接入SpringCloud的两种方案</h3><ul><li>Sidecar<ul><li>必须去实现一个健康检查接口</li><li>只有状态，服务治理只能从网关层控制流量</li></ul></li><li>自己实现注册中心API Http接口(推荐)</li></ul><p><strong><a href="https://github.com/itliusir/Spring-Cloud-Netflix-Demo">示例代码-github</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netflix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap 源码分析</title>
      <link href="/2018/14-ConcurrentHashMap/"/>
      <url>/2018/14-ConcurrentHashMap/</url>
      
        <content type="html"><![CDATA[<h2 id="TOP-带着问题看源码"><a href="#TOP-带着问题看源码" class="headerlink" title="TOP 带着问题看源码"></a>TOP 带着问题看源码</h2><ol><li>ConcurrentHashMap 是怎么保证线程安全的</li></ol><span id="more"></span><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p>顾名思义，ConcurrentHashMap 是线程安全的 HashMap，HashMap 我们之前的文章已经分析过了，这次主要分析 ConcurrentHashMap 是怎么保证线程安全的。</p><p><a href="http://qiniu.itliusir.com/cmap01.png"><img src="http://qiniu.itliusir.com/cmap01.png" alt="img"></a></p><ul><li><p><em>AbstractMap 实现类</em></p><p>提供一些围绕着iterator的基础方法</p></li><li><p><em>ConcurrentMap 接口</em></p><p>声明是线程安全的 Map</p></li><li><p><em>Serializable 接口</em></p><p>标记该类是可序列化的</p></li></ul><h2 id="2-成员变量分析"><a href="#2-成员变量分析" class="headerlink" title="2. 成员变量分析"></a>2. 成员变量分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储数据数组</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">// 扩容时新生成的数据，table 的2倍</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"><span class="comment">// 基础计数值，没有竞争时候使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line"><span class="comment">// 控制符，-1 表示有线程正在初始化；-N 表示有N - 1个线程正在进行扩容；默认0 表示还没初始化；&gt;0 表示下一次扩容或者初始化的大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br></pre></td></tr></table></figure><h2 id="3-核心方法分析"><a href="#3-核心方法分析" class="headerlink" title="3. 核心方法分析"></a>3. 核心方法分析</h2><h3 id="3-1-新增数据操作"><a href="#3-1-新增数据操作" class="headerlink" title="3.1 新增数据操作"></a>3.1 新增数据操作</h3><h4 id="3-1-1-put-K-key-V-value"><a href="#3-1-1-put-K-key-V-value" class="headerlink" title="3.1.1 put(K key, V value)"></a>3.1.1 put(K key, V value)</h4><p>put 方法调用的是 putVal，putIfAbsent 参数传的是 false，代表不去重</p><p>核心逻辑如下：</p><ol><li><p>计算hash，这里算的是一定大于0的，当hash 小于 0代表是两种情况: ① MOVED(-1) 正在扩容 ② TREEBIN(-2) 此元素后是红黑树</p></li><li><p>检查是否初始化，没有初始化先初始化一次</p></li><li><p>根据hash值，查找对应位置的元素</p><p>3.1 如果没有元素，就 CAS 放进去</p><p>3.2 如果有元素，加锁针对链表或者红黑树(通过hash是否大于0来判断)进行替换或添加</p></li><li><p>检查链表长度，大于8就转为红黑树</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// key 或者 value 为 null 直接抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  <span class="comment">// 计算hash值</span></span><br><span class="line">  <span class="comment">// 这里与hashmap不同的是计算过程中引入了HASH_BITS(0x7fffffff，高于30位都是0)将高位置0</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">  <span class="comment">// 标记默认为0(数组)</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">      <span class="comment">// 懒初始化策略，使用时候发现为空才去调用初始化方法</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">      <span class="comment">// 和HashMap的区别是采用 volatile读</span></span><br><span class="line">      <span class="comment">// 如果当前hash对应的位置为空使用 CAS 进行添加(放置)元素</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// MOVED(-1) 是预留的hash值给，代表别的线程正在进行扩容操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">          <span class="comment">// 帮助扩容</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">      <span class="comment">// 走到这里是说明计算的hash对应地方已经有元素了</span></span><br><span class="line">      <span class="comment">// 执行替换或添加(链表、树)</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">          <span class="comment">// 对这个节点加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">              <span class="comment">// 在 synchronized 语义中再次判断一次</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                  <span class="comment">// hash值不为预留的hash，这里主要是判断是不是 TREEBIN(-2) 来看此节点是否为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 标记为1，链表在遍历查找的时候会累加这个值(链表)</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                          <span class="comment">// 如果key也一样，就直接替换</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                          <span class="comment">// 否则，找到下一个为空的地方尾部插入</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="comment">// 如果是红黑树</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                      <span class="comment">// 标记为2，小于8就行(红黑树)</span></span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                      <span class="comment">// 调用红黑树的添加方法</span></span><br><span class="line">                      <span class="comment">// 二分查找到就直接返回，查不到就构建一个节点加到红黑树再返回</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 上面链表里标记的，这个值是代表了链表的长度</span></span><br><span class="line">          <span class="comment">// 大于8就转为红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 数组的元素个数+1</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-查找数据操作"><a href="#3-2-查找数据操作" class="headerlink" title="3.2 查找数据操作"></a>3.2 查找数据操作</h3><h4 id="3-2-1-get-Object-key"><a href="#3-2-1-get-Object-key" class="headerlink" title="3.2.1 get(Object key)"></a>3.2.1 get(Object key)</h4><p>查找元素相对于新增来说，不需要考虑并发，所以逻辑较为简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">  <span class="comment">// 计算 hash 值</span></span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果key相同，直接返回这个元素</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 如果是红黑树(TREEBIN(-2)),调用红黑树的查找方法</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// 否则就是链表了，遍历链表进行查找</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 找不到返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-初始化-amp-amp-扩容操作"><a href="#3-3-初始化-amp-amp-扩容操作" class="headerlink" title="3.3 初始化 &amp;&amp; 扩容操作"></a>3.3 初始化 &amp;&amp; 扩容操作</h3><h4 id="3-3-1-initTable"><a href="#3-3-1-initTable" class="headerlink" title="3.3.1 initTable()"></a>3.3.1 initTable()</h4><p>核心逻辑就是：</p><ol><li>检查 sizeCtl</li><li>设置 sizeCtl</li><li>设置容量，初始化 table(0.75的负载因子)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">  <span class="comment">// 循环</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 检查 sizeCtl，如果小于0说明正在进行初始化或者扩容，先让出 CPU 等待一会</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">      <span class="comment">// 当前线程在初始化，设置为-1，失败就重试</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="comment">// 如果sc为空就设置容量为默认容量</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                  <span class="comment">// 初始化table</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                  <span class="comment">// 设置sc为n的0.75倍，可以看到这里是写死的，所以没有全局可变的负载因子</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-transfer-Node-lt-K-V-gt-tab-Node-lt-K-V-gt-nextTab"><a href="#3-3-2-transfer-Node-lt-K-V-gt-tab-Node-lt-K-V-gt-nextTab" class="headerlink" title="3.3.2 transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)"></a>3.3.2 transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</h4><p>核心逻辑如下：</p><ol><li>新数组初始化为2倍</li><li>拆分为l两个链表(树)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">  <span class="comment">// 如果每个核要处理的小于16就设置为16</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">  <span class="comment">// 初始化，double size</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 新数组的大小</span></span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">  <span class="comment">// ForwardingNode 是用来临时存放扩容时的节点</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh</span><br><span class="line">      <span class="comment">// 循环，计算i值(--i)</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">          <span class="comment">// 如果迁移已经完成</span></span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">              table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// CAS 更新扩容阈值，sizeCtl - 1说明新加入了一个当前线程参与扩容</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">      <span class="comment">// MOVED(-1) 表示遍历到了ForwardingNode节点，意味着该节点已经处理过了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">              <span class="comment">// 节点复制</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                  <span class="comment">// 拆分为2个链表，这里是和hashMap类似的</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                      <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                          <span class="comment">// 根据是否为0来判断是低位链表还是高位链表</span></span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                      <span class="comment">// 遍历链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                          <span class="comment">// 放到低位链表</span></span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                          <span class="comment">// 放到高位链表</span></span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                      <span class="comment">// 低位不变</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                      <span class="comment">// 高位+n</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="comment">// 红黑树</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                      <span class="comment">// 分为两个树，如果小于6就退化为链表</span></span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-元素个数操作"><a href="#3-4-元素个数操作" class="headerlink" title="3.4 元素个数操作"></a>3.4 元素个数操作</h3><h4 id="3-4-1-addCount-long-x-int-check"><a href="#3-4-1-addCount-long-x-int-check" class="headerlink" title="3.4.1 addCount(long x, int check)"></a>3.4.1 addCount(long x, int check)</h4><p>主要做了两件事，一件事是更新元素个数，一个是检查是否扩容(这里省略这部分…)</p><p>当你看到 baseCount 和 CounterCell[] 是不是很熟悉，没错！和前面分析的 LongAdder 是一样的，就是散列开来分开计数，最后在统计，增加并行性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-2-size"><a href="#3-4-2-size" class="headerlink" title="3.4.2 size()"></a>3.4.2 size()</h4><p>统计 baseCount + counterCells</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">            (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (<span class="keyword">int</span>)n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其实就是把基础统计和散列各线程的计数加起来，这里计数是不精准的</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过对核心方法的分析，回到问题 <strong>TOP 1</strong> 可以知道，其主要采用 synchronized + CAS 来保证线程安全的</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>可以发现ConcurrentHashMap 采用 synchronized + CAS 来保证线程安全，尽量提高并行性。</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ConcurrentHashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap 源码分析</title>
      <link href="/2018/03-HashMap/"/>
      <url>/2018/03-HashMap/</url>
      
        <content type="html"><![CDATA[<h2 id="TOP-带着问题看源码"><a href="#TOP-带着问题看源码" class="headerlink" title="TOP 带着问题看源码"></a>TOP 带着问题看源码</h2><ol><li>HashMap 的数据结构是什么</li><li>Hash冲突解决办法是什么，什么时候会转为红黑树</li><li>容量为什么为2的N次幂</li><li>HashMap 是怎么扩容的</li><li>HashMap 为什么使用红黑树</li></ol><span id="more"></span><h2 id="1-继承和实现关系"><a href="#1-继承和实现关系" class="headerlink" title="1. 继承和实现关系"></a>1. 继承和实现关系</h2><p><a href="http://qiniu.itliusir.com/hashmap01.png"><img src="http://qiniu.itliusir.com/hashmap01.png" alt="img"></a></p><ul><li><p><em>AbstractMap 实现类</em></p><p>提供一些围绕着iterator的基础方法</p></li><li><p><em>Cloneable 接口</em></p><p>标记该类对象能够被Object.clone()</p></li><li><p><em>Serializable 接口</em></p><p>标记该类是可序列化的。</p></li></ul><h2 id="2-成员变量分析"><a href="#2-成员变量分析" class="headerlink" title="2. 成员变量分析"></a>2. 成员变量分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认初始容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="comment">// 最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 负载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 大于8转为树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 小于6转为链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// 当内部数组size小于64并且单位置冲突超过8，优先扩容，而不是树化</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure><h2 id="3-构造方法分析"><a href="#3-构造方法分析" class="headerlink" title="3. 构造方法分析"></a>3. 构造方法分析</h2><h3 id="3-1-无参构造方法"><a href="#3-1-无参构造方法" class="headerlink" title="3.1 无参构造方法"></a>3.1 无参构造方法</h3><p>使用默认负载因子做全局负载因子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-带初始化容量的构造方法"><a href="#3-2-带初始化容量的构造方法" class="headerlink" title="3.2 带初始化容量的构造方法"></a>3.2 带初始化容量的构造方法</h3><p>指定容量和默认负载因子，走下面带负载因子的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-带初始化容量和负载因子的构造方法"><a href="#3-3-带初始化容量和负载因子的构造方法" class="headerlink" title="3.3 带初始化容量和负载因子的构造方法"></a>3.3 带初始化容量和负载因子的构造方法</h3><p>check参数，容量转为参数的最小2次幂。</p><p>为什么要转为2的N次幂呢，主要是为了后面做取模运算可以使用性能更好地位运算来代替%</p><p>回到 <strong>TOP 3</strong> 问题，可以明白了为什么这样设计。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-核心方法分析"><a href="#4-核心方法分析" class="headerlink" title="4. 核心方法分析"></a>4. 核心方法分析</h2><h3 id="4-1-获取元素"><a href="#4-1-获取元素" class="headerlink" title="4.1 获取元素"></a>4.1 获取元素</h3><p>先计算key的hash值，然后调用getNode方法获取到节点的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先来看hash方法，可以看到是通过高半区与低半区进行异或，为什么要这样做呢？</p><p>主要是把高位的特征也给加入到扰动计算中，降低低位的冲突。那降低低位冲突目的是啥呢？</p><p>其实可以从取下标位置(n-1) &amp; hash来分析，n为2的N次幂，在n - 1在二进制中低位肯定全是1，那和hash做与运算相当于结果是hash低位的截取操作。也就是hash的冲突情况完全取决于hash自身低位的冲突情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的主要逻辑就是先计算下标，然后对比hash值和value值来获取元素(①)。注意的是如果节点是tree，会使用递归来遍历查找，时间复杂度则会转为O(nlogn)(②)。如果是链表则会遍历来获取，这段长度比较短并不会太影响性能(③)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ①</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// ②</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// ③</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-新增-amp-更新元素"><a href="#4-2-新增-amp-更新元素" class="headerlink" title="4.2 新增&amp;更新元素"></a>4.2 新增&amp;更新元素</h3><h4 id="4-2-1-put-K-key-V-value"><a href="#4-2-1-put-K-key-V-value" class="headerlink" title="4.2.1 put(K key, V value)"></a>4.2.1 put(K key, V value)</h4><p>计算 key 的 hash，onlyIfAbsent 设置为 false (默认覆盖旧的 key )，evict 设置为 true (代表会逐出元素，在LinkedHashMap 实现 LRU 时候的重写方法 removeEldestEntry 里会用到。在序列化也会涉及到，序列化时候会设置为 false)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-2-putIfAbsent-K-key-V-value"><a href="#4-2-2-putIfAbsent-K-key-V-value" class="headerlink" title="4.2.2 putIfAbsent(K key, V value)"></a>4.2.2 putIfAbsent(K key, V value)</h4><p>对比默认的 put 方法，只是把 onlyIfAbsent 设置为true，表示有则不覆盖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####4.2.3 resize()</p><p>在分析 putVal 方法之前，我们先分析扩容方法 resize</p><p>核心逻辑主要分为以下五个部分</p><p>① 没超过最大值，且数组元素超过了64的阈值则扩容为原来的2倍</p><p>② 无冲突情况数组桶重新hash</p><p>③ 节点是红黑树，走红黑树拆分逻辑，和下面链表差不多，会增加阈值判断，若扩容后节点数小于6则会转为链表</p><p>④ 节点是链表，④-① 和 ④-② 是判断hash值新增bit位是0还是1的情况，来分散链表</p><p>⑤ 对④做最后的铺垫，根据不同情况放置不同位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// ①</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// ②</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// ③</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">// ④</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// ④-①</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// ④-②</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// ⑤</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到 <strong>TOP 4</strong> 问题，可以明白了hashMap扩容的机制和场景</p><p>####4.2.3 putVal(int hash, K key, V value, boolean onlyIfAbsent,<br>boolean evict)</p><p>核心逻辑主要分为如下6个步骤</p><p>① 先检查存储数组是否为空(例如使用默认构造方法没有设置初始值)，为空了则调用上面的扩容方法resize</p><p>② 然后计算hash值对应的位置是否为空，如果为空则构建一个next节点是null的空节点放到该位置</p><p>③ 如果位置不为空，hash值相同，且key相同则更新元素</p><p>④ 如果节点是 treeNode，则调用 Tree 版本的putTreeVal，逻辑都差不多，就是遍历左右子树，查到了就返回查不到就构建一个</p><p>⑤ 如果节点是链表，首先遍历到链表最后一位加入构建的节点，然后 check 阈值是否要转为红黑树，最后若存在相同的key就覆盖</p><p>⑥ 超过最大容量则扩容处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// ①</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// ②</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// ③</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// ④</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ⑤</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// ⑥</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到 <strong>TOP 2</strong> 问题，可以明白了解决冲突的方式是采用了拉链法，当链表长度大于8则会转为红黑树</p><h3 id="4-3-删除元素"><a href="#4-3-删除元素" class="headerlink" title="4.3 删除元素"></a>4.3 删除元素</h3><p>计算hash值，然后调用 removeNode 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心逻辑主要分为三个步骤</p><p>① 定位元素的位置</p><p>② 找到键相同的元素</p><p>③ 删除相关节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="comment">// ①</span></span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// ②</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ③</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><h3 id="5-1-数据结构的设计"><a href="#5-1-数据结构的设计" class="headerlink" title="5.1 数据结构的设计"></a>5.1 数据结构的设计</h3><p>总体是一个散列表的设计，底层使用数组，这里为了方便位运算，会将size重置为最接近你所设置的2^n，这样取模就可以用位运算代替了。</p><h3 id="5-2-冲突的处理"><a href="#5-2-冲突的处理" class="headerlink" title="5.2 冲突的处理"></a>5.2 冲突的处理</h3><p>hash 冲突采用的是拉链法，王争老师的《数据结构与算法之美》专栏里有讲解，对于数据较少的话使用开放寻址法处理冲突较为合适，例如ThreadLocal，显然不适合HashMap。</p><p>回到 <strong>TOP 1</strong> 问题，可以明白了 HashMap 底层使用的数组+链表(红黑树) 来实现的。</p><h3 id="5-3-为什么使用红黑树"><a href="#5-3-为什么使用红黑树" class="headerlink" title="5.3 为什么使用红黑树"></a>5.3 为什么使用红黑树</h3><p>当链足够长，HashMap设置的阈值是8 超过8就会转成红黑树，原因是链表的时间复杂度在数据多的情况下会表现很差。至于为什么使用的是红黑树而不是相同时间复杂度实现更为简单的跳表呢？ 实际上使用跳表也不是不可以，但是HashMap主要的场景还是散列表，每个冲突都用跳表结构属实有些浪费空间。</p><p>解释了 <strong>TOP 5问题</strong></p><h3 id="5-4-扩容"><a href="#5-4-扩容" class="headerlink" title="5.4 扩容"></a>5.4 扩容</h3><p>在扩容期间，为了避免单链过长，扩容时候会对链进行分开处理，所以就又有了冲突的长度小于6会把树节点重新转化为链表。</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAS 源码分析</title>
      <link href="/2017/javase-CAS/"/>
      <url>/2017/javase-CAS/</url>
      
        <content type="html"><![CDATA[<p>摘要:CAS全称为compare and swap，是原子操作的一种，可用于在多线程编程中实现不被打断的数据交换操作，从而避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题。 该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值。<br>                                                        –<strong>from Wikipedia</strong></p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文:"></a>正文:</h2><p>在使用上，通常会记录下某块内存中的旧值，通过对旧值进行一系列的操作后得到新值，然后通过CAS操作将新值与旧值进行交换。如果这块内存的值在这期间内没被修改过，则旧值会与内存中的数据相同，这时CAS操作将会成功执行 使内存中的数据变为新值。如果内存中的值在这期间内被修改过，则一般来说旧值会与内存中的数据不同，这时CAS操作将会失败，新值将不会被写入内存。</p><h1 id="CAS的实现"><a href="#CAS的实现" class="headerlink" title="CAS的实现"></a>CAS的实现</h1><p>接下来我们去看CAS在java中的实现，<a href="http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/sun/misc/Unsafe.java">sun.misc.Unsafe</a>提供了compareAndSwap系列函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Atomically update Java variable to &lt;tt&gt;x&lt;/tt&gt; if it is currently</span></span><br><span class="line"><span class="comment">    * holding &lt;tt&gt;expected&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if successful</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    Object expected,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    Object x)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Atomically update Java variable to &lt;tt&gt;x&lt;/tt&gt; if it is currently</span></span><br><span class="line"><span class="comment">    * holding &lt;tt&gt;expected&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if successful</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                 <span class="keyword">int</span> expected,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                 <span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Atomically update Java variable to &lt;tt&gt;x&lt;/tt&gt; if it is currently</span></span><br><span class="line"><span class="comment">    * holding &lt;tt&gt;expected&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if successful</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  <span class="keyword">long</span> expected,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  <span class="keyword">long</span> x)</span></span>;</span><br></pre></td></tr></table></figure><p>可以看到native发现这是一个本地方法调用，可以去查看对应的OpenJDK中调用代码<a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/os_cpu/linux_x86/vm/atomic_linux_x86.inline.hpp">atomic_linux_x86.inline.hpp</a>  /  <a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/os_cpu/windows_x86/vm/atomic_windows_x86.inline.hpp">atomic_windows_x86.inline.hpp</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux(int 类型)</span></span><br><span class="line">inline jint Atomic::cmpxchg(jint exchange_value, <span class="keyword">volatile</span> jint* dest, jint compare_value) &#123;</span><br><span class="line">  <span class="keyword">int</span> mp = os::is_MP();</span><br><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(LOCK_IF_MP(%<span class="number">4</span>)</span> &quot;cmpxchgl %1,<span class="params">(%<span class="number">3</span>)</span>&quot;</span></span><br><span class="line"><span class="function">                    : &quot;</span>=a<span class="string">&quot; (exchange_value)</span></span><br><span class="line"><span class="string">                    : &quot;</span>r<span class="string">&quot; (exchange_value), &quot;</span>a<span class="string">&quot; (compare_value), &quot;</span>r<span class="string">&quot; (dest), &quot;</span>r<span class="string">&quot; (mp)</span></span><br><span class="line"><span class="string">                    : &quot;</span>cc<span class="string">&quot;, &quot;</span>memory<span class="string">&quot;);</span></span><br><span class="line"><span class="string">  return exchange_value;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//windows(int 类型)</span></span><br><span class="line"><span class="string">inline jint Atomic::cmpxchg(jint exchange_value, volatile jint* dest, jint compare_value) &#123;</span></span><br><span class="line"><span class="string"> return (*os::atomic_cmpxchg_func)(exchange_value, dest, compare_value);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到其实现方式是基于硬件平台的汇编指令cmpxchg指令完成的，JVM只是封装了汇编调用。以linux x86处理器为例子，int mp = os::is_MP()中的MP是multiprocessor，即多处理器，当遇到是多处理器的情况下加上LOCK。cmpxchgl指的应该是compare and exchange指令。</p><h1 id="CAS在Java中的使用"><a href="#CAS在Java中的使用" class="headerlink" title="CAS在Java中的使用"></a>CAS在Java中的使用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Unsafe unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 通过反射获取rt.jar下的Unsafe类</span></span><br><span class="line">Field field = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">unsafe = (Unsafe) field.get(<span class="keyword">null</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Get Unsafe instance occur error&quot;</span> + e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Class clazz = Target.class;</span><br><span class="line">Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">Target target = <span class="keyword">new</span> Target();</span><br><span class="line">Field intFiled = clazz.getDeclaredField(<span class="string">&quot;intParam&quot;</span>);</span><br><span class="line">Field longFiled = clazz.getDeclaredField(<span class="string">&quot;longParam&quot;</span>);</span><br><span class="line">Field strFiled = clazz.getDeclaredField(<span class="string">&quot;strParam&quot;</span>);</span><br><span class="line">Field strFiled2 = clazz.getDeclaredField(<span class="string">&quot;strParam2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// intParam</span></span><br><span class="line">System.out.print(unsafe.compareAndSwapInt(target, <span class="number">12</span>, <span class="number">3</span>, <span class="number">10</span>) + <span class="string">&quot;:&quot;</span>);</span><br><span class="line">System.out.println((Integer) intFiled.get(target));</span><br><span class="line"><span class="comment">// longParam</span></span><br><span class="line">System.out.print(unsafe.compareAndSwapLong(target, <span class="number">16</span>, <span class="number">1l</span>, <span class="number">2l</span>) + <span class="string">&quot;:&quot;</span>);</span><br><span class="line">System.out.println((Long) longFiled.get(target));</span><br><span class="line"><span class="comment">// strParam</span></span><br><span class="line">System.out.print(unsafe.compareAndSwapObject(target, <span class="number">24</span>, <span class="keyword">null</span>, <span class="string">&quot;5&quot;</span>)</span><br><span class="line">+ <span class="string">&quot;:&quot;</span>);</span><br><span class="line">System.out.println((String) strFiled.get(target));</span><br><span class="line"><span class="comment">// strParam2</span></span><br><span class="line">System.out.print(unsafe.compareAndSwapObject(target, <span class="number">28</span>, <span class="keyword">null</span>, <span class="string">&quot;6&quot;</span>)</span><br><span class="line">+ <span class="string">&quot;:&quot;</span>);</span><br><span class="line">System.out.println((String) strFiled2.get(target));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> intParam = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">long</span> longParam = <span class="number">1l</span>;</span><br><span class="line">String strParam;</span><br><span class="line">String strParam2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如代码所示，compareAndSwapXx方法会根据第二个参数”偏移量”去拿偏移量这么多的属性的值和第三个参数对比，如果相同则将该属性值替换为第四个参数。该偏移量是指某个字段相对Java对象的起始位置的偏移量，可以通过unsafe.objectFieldOffset(param)去获取对应属性的偏移量。</p><p>顺便介绍个查看对象的属性位置分布的一个小工具：<a href="http://openjdk.java.net/projects/code-tools/jol/">jol</a></p><h2 id="使用Demo"><a href="#使用Demo" class="headerlink" title="使用Demo:"></a>使用Demo:</h2><p>首先引用jol-core包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.openjdk.jol/jol-core --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jol-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.9&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在项目里简单使用下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOffset</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">out.println(VM.current().details());</span><br><span class="line">out.println(ClassLayout.parseClass(Throwable.class).toPrintable());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下，根据偏移量界面化的显示属性分布的位置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Running 64-bit HotSpot VM.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Using compressed oop with 3-bit <span class="built_in">shift</span>.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Using compressed klass with 3-bit <span class="built_in">shift</span>.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Objects are 8 bytes aligned.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Field sizes by <span class="built_in">type</span>: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Array element sizes: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]</span></span><br><span class="line"></span><br><span class="line">java.lang.Throwable object internals:</span><br><span class="line"> OFFSET  SIZE                            TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0    12                                 (object header)                           N/A</span><br><span class="line">     12     4                                 (alignment/padding gap)                  </span><br><span class="line">     16     4                java.lang.String Throwable.detailMessage                   N/A</span><br><span class="line">     20     4             java.lang.Throwable Throwable.cause                           N/A</span><br><span class="line">     24     4   java.lang.StackTraceElement[] Throwable.stackTrace                      N/A</span><br><span class="line">     28     4                  java.util.List Throwable.suppressedExceptions            N/A</span><br><span class="line">Instance size: 32 bytes</span><br><span class="line">Space losses: 4 bytes internal + 0 bytes external = 4 bytes total</span><br></pre></td></tr></table></figure><h1 id="CAS存在的ABA问题"><a href="#CAS存在的ABA问题" class="headerlink" title="CAS存在的ABA问题"></a>CAS存在的ABA问题</h1><p>CAS普遍存在的一个问题就是ABA问题，即是当线程一将变量A修改为B，之后又修改为A，线程二去对比A发现没变化就会判断出错。目前很多都是使用加上版本号来解决，加个version字段，每次修改就++，每次判断时候多判断下版本号是否变化来确定某变量是否被修改。</p><p>下班啦，暂且到这里，祝大家十一玩的开心~~~</p><p><img src="http://qiniu.itliusir.com/xixi.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>invoke 源码分析</title>
      <link href="/2017/javase-Method-invoke/"/>
      <url>/2017/javase-Method-invoke/</url>
      
        <content type="html"><![CDATA[<p>摘要:最近有使用到Method的invoke方法，于是就学习了下Method的invoke方法源码(暂未深入到native)</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文:"></a>正文:</h2><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>首先看一下invoke方法的代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccessibleObject</span> <span class="keyword">implements</span> <span class="title">AnnotatedElement</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> override;</span><br><span class="line"><span class="comment">//访问权限</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccessible</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> override;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Method.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span></span><br><span class="line"><span class="function">          InvocationTargetException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">               Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">               checkAccess(caller, clazz, obj, modifiers);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       MethodAccessor ma = methodAccessor;             <span class="comment">// read volatile</span></span><br><span class="line">       <span class="keyword">if</span> (ma == <span class="keyword">null</span>) &#123;</span><br><span class="line">           ma = acquireMethodAccessor();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ma.invoke(obj, args);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以看到在该方法第一步会先去判断AccessibleObject的override属性是否为true</p><ul><li>若为true则忽略访问权限的控制</li><li>若为false则会去调用Reflection.quickCheckMemberAccess()判断是不是public，若不是则会使用Reflection.getCallerClass()获取调用此方法的class，然后校验其是否有权限</li><li>最后会调用MethodAccessor的invoke()方法</li></ul><p>MethodAccessor的invoke方法源码如下所示，就是一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodAccessor</span> </span>&#123;</span><br><span class="line">   <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Method&#125; */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object[] args)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它只是一个单方法接口，其invoke()方法与Method.invoke()的对应。 创建MethodAccessor实例的是ReflectionFactory。</p><p><a href="http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/sun/reflect/ReflectionFactory.java">sun.reflect.ReflectionFactory</a>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionFactory</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> initted = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// &quot;Inflation&quot; mechanism. Loading bytecodes to implement</span></span><br><span class="line">    <span class="comment">// Method.invoke() and Constructor.newInstance() currently costs</span></span><br><span class="line">    <span class="comment">// 3-4x more than an invocation via native code for the first</span></span><br><span class="line">    <span class="comment">// invocation (though subsequent invocations have been benchmarked</span></span><br><span class="line">    <span class="comment">// to be over 20x faster). Unfortunately this cost increases</span></span><br><span class="line">    <span class="comment">// startup time for certain applications that use reflection</span></span><br><span class="line">    <span class="comment">// intensively (but only once per class) to bootstrap themselves.</span></span><br><span class="line">    <span class="comment">// To avoid this penalty we reuse the existing JVM entry points</span></span><br><span class="line">    <span class="comment">// for the first few invocations of Methods and Constructors and</span></span><br><span class="line">    <span class="comment">// then switch to the bytecode-based implementations.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Package-private to be accessible to NativeMethodAccessorImpl</span></span><br><span class="line">    <span class="comment">// and NativeConstructorAccessorImpl</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> noInflation        = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>     inflationThreshold = <span class="number">15</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** We have to defer full initialization of this class until after</span></span><br><span class="line"><span class="comment">        the static initializer is run since java.lang.reflect.Method&#x27;s</span></span><br><span class="line"><span class="comment">        static initializer (more properly, that for</span></span><br><span class="line"><span class="comment">        java.lang.reflect.AccessibleObject) causes this class&#x27;s to be</span></span><br><span class="line"><span class="comment">        run, before the system properties are set up. */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkInitted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initted) <span class="keyword">return</span>;</span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// Tests to ensure the system properties table is fully</span></span><br><span class="line">                    <span class="comment">// initialized. This is needed because reflection code is</span></span><br><span class="line">                    <span class="comment">// called very early in the initialization process (before</span></span><br><span class="line">                    <span class="comment">// command-line arguments have been parsed and therefore</span></span><br><span class="line">                    <span class="comment">// these user-settable properties installed.) We assume that</span></span><br><span class="line">                    <span class="comment">// if System.out is non-null then the System class has been</span></span><br><span class="line">                    <span class="comment">// fully initialized and that the bulk of the startup code</span></span><br><span class="line">                    <span class="comment">// has been run.</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (System.out == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// java.lang.System not yet fully initialized</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    String val = System.getProperty(<span class="string">&quot;sun.reflect.noInflation&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (val != <span class="keyword">null</span> &amp;&amp; val.equals(<span class="string">&quot;true&quot;</span>)) &#123;</span><br><span class="line">                        noInflation = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    val = System.getProperty(<span class="string">&quot;sun.reflect.inflationThreshold&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (val != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            inflationThreshold = Integer.parseInt(val);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> (RuntimeException) </span><br><span class="line">                                <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Unable to parse property sun.reflect.inflationThreshold&quot;</span>).</span><br><span class="line">                                    initCause(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    initted = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> MethodAccessor <span class="title">newMethodAccessor</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        checkInitted();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (noInflation) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MethodAccessorGenerator().</span><br><span class="line">                generateMethod(method.getDeclaringClass(),</span><br><span class="line">                               method.getName(),</span><br><span class="line">                               method.getParameterTypes(),</span><br><span class="line">                               method.getReturnType(),</span><br><span class="line">                               method.getExceptionTypes(),</span><br><span class="line">                               method.getModifiers());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            NativeMethodAccessorImpl acc =</span><br><span class="line">                <span class="keyword">new</span> NativeMethodAccessorImpl(method);</span><br><span class="line">            DelegatingMethodAccessorImpl res =</span><br><span class="line">                <span class="keyword">new</span> DelegatingMethodAccessorImpl(acc);</span><br><span class="line">            acc.setParent(res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，实际的MethodAccessor实现有两个版本，一个是Java实现的，另一个是native code实现的。Java实现的版本在初始化时需要较多时间，但长久来说性能较好；native版本正好相反，启动时相对较快，但运行时间长了之后速度就比不过Java版了。</p><p>这个需要注意的是inflationThreshold的值是15，也就是说前15次是使用的native版本，之后使用的是java版本，具体实现可以往下看。</p><p>为了权衡两个版本的性能，Sun的JDK使用了“inflation”的技巧：让Java方法在被反射调用时，开头若干次使用native版，等反射调用次数超过阈值时则生成一个专用的MethodAccessor实现类，生成其中的invoke()方法的字节码，以后对该Java方法的反射调用就会使用Java版。 (Sun的JDK是从1.4系开始采用这种优化的)</p><p>可以在启动命令里加上-Dsun.reflect.noInflation=true，就会RefactionFactorynoInflation属性就变成true了，这样不用等到15调用后，程序一开始就会用java版的MethodAccessor了</p><p>可以在上段代码newMethodAccessor()方法看到DelegatingMethodAccessorImpl res = new DelegatingMethodAccessorImpl(acc);</p><p><a href="http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/sun/reflect/DelegatingMethodAccessorImpl.java">sun.reflect.DelegatingMethodAccessorImpl</a>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelegatingMethodAccessorImpl</span> <span class="keyword">extends</span> <span class="title">MethodAccessorImpl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MethodAccessorImpl delegate;</span><br><span class="line"></span><br><span class="line">    DelegatingMethodAccessorImpl(MethodAccessorImpl delegate) &#123;</span><br><span class="line">        setDelegate(delegate);</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> delegate.invoke(obj, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDelegate</span><span class="params">(MethodAccessorImpl delegate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类是方便在native与Java版的MethodAccessor之间实现切换。</p><p><a href="http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/sun/reflect/NativeMethodAccessorImpl.java">sun.reflect.NativeMethodAccessorImpl</a>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NativeMethodAccessorImpl</span> <span class="keyword">extends</span> <span class="title">MethodAccessorImpl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Method method;</span><br><span class="line">    <span class="keyword">private</span> DelegatingMethodAccessorImpl parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numInvocations;</span><br><span class="line"></span><br><span class="line">    NativeMethodAccessorImpl(Method method) &#123;</span><br><span class="line">        <span class="keyword">this</span>.method = method;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (++numInvocations &gt; ReflectionFactory.inflationThreshold()) &#123;</span><br><span class="line">            MethodAccessorImpl acc = (MethodAccessorImpl)</span><br><span class="line">                <span class="keyword">new</span> MethodAccessorGenerator().</span><br><span class="line">                    generateMethod(method.getDeclaringClass(),</span><br><span class="line">                                   method.getName(),</span><br><span class="line">                                   method.getParameterTypes(),</span><br><span class="line">                                   method.getReturnType(),</span><br><span class="line">                                   method.getExceptionTypes(),</span><br><span class="line">                                   method.getModifiers());</span><br><span class="line">            parent.setDelegate(acc);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> invoke0(method, obj, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setParent</span><span class="params">(DelegatingMethodAccessorImpl parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title">invoke0</span><span class="params">(Method m, Object obj, Object[] args)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在每次调用invoke方法时候会++numInvocations，inflationThreshold的值是15，该块就是上文所说的native版本和java版本的切换实现部分。当numInvocations超过inflationThreshold的值调用MethodAccessorGenerator.generateMethod()来生成Java版的MethodAccessor的实现类，并且改变DelegatingMethodAccessorImpl所引用的MethodAccessor为Java版。后续经由DelegatingMethodAccessorImpl.invoke()调用到的就是Java版的实现了。</p><h1 id="反射的性能"><a href="#反射的性能" class="headerlink" title="反射的性能"></a>反射的性能</h1><p>反射的性能开销主要原因如下：</p><ul><li>可变参数导致的 Object 数组</li><li>基本类型的自动装箱拆箱</li><li>MethodAccesor.invoke的瓶颈</li></ul><p>前两点很好理解，最后一点说之前我们先说下方法内联：</p><blockquote><p>方法内联指的是编译器在编译一个方法时，将某个方法调用的目标方法也纳入编译范围内，并用其返回值替代原方法调用这么个过程</p></blockquote><p>在反射中，Method.invoke一直会被内联，但是它里面的MethodAccesor.invoke则不一定(java 虚拟机无法同时记录那么多调用者的具体类型)，这样就会造成反射调用没有被内联的情况</p><h1 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h1><p>可以使用<a href="https://github.com/itliusir/Test/blob/master/Test/src/testinvoke/TestClassLoad.java#L1">demo</a>测试invoke方法执行的流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Hello,&quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClassLoad</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Class&lt;?&gt; clz = Class.forName(<span class="string">&quot;testinvoke.A&quot;</span>);</span><br><span class="line">Object o = clz.newInstance();</span><br><span class="line">Method m = clz.getMethod(<span class="string">&quot;foo&quot;</span>, String.class);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">m.invoke(o, Integer.toString(i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在运行的时候使用-XX:+TraceClassLoading参数监控类加载情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[Loaded testinvoke.A from file:/C:/Users/itliusir/git/test/Test/bin/]</span><br><span class="line">[Loaded sun.reflect.NativeMethodAccessorImpl from D:\jdk8\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.DelegatingMethodAccessorImpl from D:\jdk8\jre\lib\rt.jar]</span><br><span class="line">Hello,<span class="number">0</span></span><br><span class="line">Hello,<span class="number">1</span></span><br><span class="line">Hello,<span class="number">2</span></span><br><span class="line">Hello,<span class="number">3</span></span><br><span class="line">Hello,<span class="number">4</span></span><br><span class="line">Hello,<span class="number">5</span></span><br><span class="line">Hello,<span class="number">6</span></span><br><span class="line">Hello,<span class="number">7</span></span><br><span class="line">Hello,<span class="number">8</span></span><br><span class="line">Hello,<span class="number">9</span></span><br><span class="line">Hello,<span class="number">10</span></span><br><span class="line">Hello,<span class="number">11</span></span><br><span class="line">Hello,<span class="number">12</span></span><br><span class="line">Hello,<span class="number">13</span></span><br><span class="line">Hello,<span class="number">14</span></span><br><span class="line">[Loaded sun.reflect.ClassFileConstants from D:\jdk8\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.AccessorGenerator from D:\jdk8\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.MethodAccessorGenerator from D:\jdk8\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.ByteVectorFactory from D:\jdk8\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.ByteVector from D:\jdk8\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.ByteVectorImpl from D:\jdk8\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.ClassFileAssembler from D:\jdk8\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.UTF8 from D:\jdk8\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.Label from D:\jdk8\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.Label$PatchInfo from D:\jdk8\jre\lib\rt.jar]</span><br><span class="line">[Loaded java.util.ArrayList$Itr from D:\jdk8\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.MethodAccessorGenerator$<span class="number">1</span> from D:\jdk8\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.ClassDefiner from D:\jdk8\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.ClassDefiner$<span class="number">1</span> from D:\jdk8\jre\lib\rt.jar]</span><br><span class="line">[Loaded java.util.concurrent.ConcurrentHashMap$ForwardingNode from D:\jdk8\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.GeneratedMethodAccessor1 from __JVM_DefineClass__]</span><br><span class="line">Hello,<span class="number">15</span></span><br><span class="line">[Loaded java.lang.Shutdown from D:\jdk8\jre\lib\rt.jar]</span><br><span class="line">[Loaded java.lang.Shutdown$Lock from D:\jdk8\jre\lib\rt.jar]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Method </tag>
            
            <tag> invoke </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MAT内存分析工具使用</title>
      <link href="/2017/JVM-MAT/"/>
      <url>/2017/JVM-MAT/</url>
      
        <content type="html"><![CDATA[<p>摘要:Eclipse Memory Analysis Tools (MAT) 是一个分析 Java堆数据的专业工具,用它可以定位内存泄漏的原因。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文:"></a>正文:</h2><p><strong>Memory Analyzer的安装</strong></p><ul><li>Eclipse-&gt;Help-&gt;Eclipse Marketplace</li></ul><p><img src="http://qiniu.itliusir.com/eclipse-install-plugins.png" alt="install plugins"></p><ul><li>安装完成后可以调用jdk工具jps查看当前的java进程，然后调用jmap将该进程的内存heap输出到文件。</li></ul><p><img src="http://qiniu.itliusir.com/dump.png" alt="dump"></p><ul><li>通过MAT以图像形式直观的展示内存泄漏报表等</li></ul><p>首先Eclipse-&gt;File-&gt;Open File 打开上一步生成的文件</p><p><img src="http://qiniu.itliusir.com/openfile.png" alt="openfile"></p><p>第一个选项是内存泄漏报表（自动检查可能存在内存泄露的对象，通过报表展示存活的对象以及为什么他们没有被垃圾收集）；</p><p>第二个是对象报表（对可疑对象进行分析，如字符串是否定义重了，空的collection、finalizer以及弱引用等）；</p><p>这里我们打开第一个：</p><p><img src="http://qiniu.itliusir.com/mat2.png" alt="MAT View"></p><p><strong>Memory Analyzer主界面介绍</strong></p><ul><li>下面的Histogram（列出内存中的对象，对象的个数以及大小）这里我们可以使用正则去进行匹配</li></ul><p><img src="http://qiniu.itliusir.com/mat5.png" alt="Histogram"></p><p>可以在具体的Class右键List objects-&gt;with incoming…./outgoing…查看该Class的实例</p><pre><code>1. outgoing references ：表示该对象的出节点（被该对象引用的对象）。2. incoming references ：表示该对象的入节点（引用到该对象的对象）。</code></pre><ul><li>下面的Dominator Tree是列出最大的对象以及其依赖存活的Object （大小是以Retained Heap为标准排序的）</li></ul><p><img src="http://qiniu.itliusir.com/dominator.png" alt="dominator"></p><ul><li>而Top Consumers则是通过图形列出最大的Object</li></ul><p><img src="http://qiniu.itliusir.com/top_consumers1.png" alt="top_consumers"></p><ul><li>Duplicate Class是通过MAT自动分析泄漏的原因</li></ul><p>一般Histogram和 Dominator Tree是最常用的。</p><p><strong>Memory Analyzer中概念介绍</strong></p><ul><li>Shallow heap</li></ul><p>Shallow size就是对象本身占用内存的大小，不包含其引用的对象。</p><pre><code>1. 常规对象（非数组）的Shallow size由其成员变量的数量和类型决定。2. 数组的shallow size由数组元素的类型（对象类型、基本类型）和数组长度决定</code></pre><ul><li>Retained Heap</li></ul><p>它表示如果一个对象被释放，那么因为该对象的释放而减少引用从而导致释放所有的对象所占用的heap大小</p><p><img src="http://qiniu.itliusir.com/histogram.png" alt="retained"></p><p>为了计算Retained Memory，MAT引入了Dominator Tree。加入对象A引用B和C，B和C又都引用到D（一个菱形）。此时要计算Retained Memory，A的包括A本身和B，C，D。B和C因为共同引用D，所以他俩的Retained Memory都只是他们本身。D当然也只是自己。我觉得是为了加快计算的速度，MAT改变了对象引用图，而转换成一个对象引用树。在这里例子中，树根是A，而B，C，D是他的三个儿子。B，C，D不再有相互关系。把引用图变成引用树，计算Retained Heap就会非常方便，显示也非常方便。对应到MAT UI上，在dominator tree这个view中，显示了每个对象的shallow heap和retained heap。然后可以以该节点位树根，一步步的细化看看retained heap到底是用在什么地方了。要说一下的是，这种从图到树的转换确实方便了内存分析，但有时候会让人有些疑惑。本来对象B是对象A的一个成员，但因为B还被C引用，所以B在树中并不在A下面，而很可能是平级，如下图所示。</p><p><img src="http://qiniu.itliusir.com/histogram1.png" alt="retained"></p><p>为了纠正这点，MAT中点击右键，可以List objects中选择with outgoing references和with incoming references。这是个真正的引用图的概念</p><ul><li>GC Root</li></ul><p>GC发现通过任何reference chain(引用链)无法访问某个对象的时候，该对象即被回收。名词GC Roots正是分析这一过程的起点，例如JVM自己确保了对象的可到达性(那么JVM就是GC Roots)，所以GC Roots就是这样在内存中保持对象可到达性的，一旦不可到达，即被回收。通常GC Roots是一个在current thread(当前线程)的call stack(调用栈)上的对象（例如方法参数和局部变量），或者是线程自身或者是system class loader(系统类加载器)加载的类以及native code(本地代码)保留的活动对象。所以GC Roots是分析对象为何还存活于内存中的利器。</p><p>在Histogram或者Domiantor Tree的某一个条目上，右键可以查看其GC Root Path</p><p>参考：</p><p><a href="http://blog.csdn.net/yxz329130952/article/details/50288145" title="利用MAT进行内存泄露分析">http://blog.csdn.net/yxz329130952/article/details/50288145</a></p><p><a href="http://www.jianshu.com/p/d8e247b1e7b2" title="MAT使用入门">http://www.jianshu.com/p/d8e247b1e7b2</a></p><h1 id="晚安"><a href="#晚安" class="headerlink" title="晚安~"></a>晚安~</h1>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinkedList 源码分析</title>
      <link href="/2017/02-LinkedList/"/>
      <url>/2017/02-LinkedList/</url>
      
        <content type="html"><![CDATA[<h2 id="TOP-带着问题看源码"><a href="#TOP-带着问题看源码" class="headerlink" title="TOP 带着问题看源码"></a>TOP 带着问题看源码</h2><ol><li>LinkedList 采用的数据结构是什么</li></ol><span id="more"></span><h2 id="1-继承和实现关系"><a href="#1-继承和实现关系" class="headerlink" title="1. 继承和实现关系"></a>1. 继承和实现关系</h2><p><a href="http://qiniu.itliusir.com/linkedlist01.png"><img src="http://qiniu.itliusir.com/linkedlist01.png" alt="img"></a></p><ul><li><p><em>AbstractSequentialList 实现类</em></p><p>提供一些围绕着iterator的基础方法</p></li><li><p><em>List 接口</em></p><p>提供 list 功能</p></li><li><p><em>Deque 接口</em></p><p>提供双端操作功能，以此可以猜出 LinkedList 数据结构是一个双向链表</p></li><li><p><em>Cloneable 接口</em></p><p>标记该类对象能够被Object.clone()</p></li><li><p><em>Serializable 接口</em></p><p>标记该类是可序列化的</p></li></ul><h2 id="2-成员变量分析"><a href="#2-成员变量分析" class="headerlink" title="2. 成员变量分析"></a>2. 成员变量分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 容量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 首节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="comment">// 尾节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><p>接下来看节点 Node的成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节点的值</span></span><br><span class="line">E item;</span><br><span class="line"><span class="comment">// next 指针</span></span><br><span class="line">Node&lt;E&gt; next;</span><br><span class="line"><span class="comment">// prev 指针</span></span><br><span class="line">Node&lt;E&gt; prev;</span><br></pre></td></tr></table></figure><p>回到 <strong>TOP 1</strong> 问题，根据实现可以明白其数据结构是一个双向链表</p><h2 id="3-构造方法分析"><a href="#3-构造方法分析" class="headerlink" title="3. 构造方法分析"></a>3. 构造方法分析</h2><p>一个是默认无参，一个是带集合内容的。</p><p>把传来的集合新增入当前list</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看节点 Node的构造方法，根据入参默认维护两个指针。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">    <span class="keyword">this</span>.item = element;</span><br><span class="line">    <span class="keyword">this</span>.next = next;</span><br><span class="line">    <span class="keyword">this</span>.prev = prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-核心方法分析"><a href="#4-核心方法分析" class="headerlink" title="4. 核心方法分析"></a>4. 核心方法分析</h2><h3 id="4-1-获取元素"><a href="#4-1-获取元素" class="headerlink" title="4.1 获取元素"></a>4.1 获取元素</h3><p>先check，然后通过 node(index)方法取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>node 方法通过判断索引 index 的范围(若是大于一半集合容量，则从尾结点向前遍历，若小于则从头结点向后遍历)来尽量高效的取到对应的节点</p><h3 id="4-2-新增元素"><a href="#4-2-新增元素" class="headerlink" title="4.2 新增元素"></a>4.2 新增元素</h3><h4 id="4-2-1-add-E-e"><a href="#4-2-1-add-E-e" class="headerlink" title="4.2.1 add(E e)"></a>4.2.1 add(E e)</h4><p>尾插</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建一个next指针是null，prev指针是尾结点的新节点newNode，如果尾结点不为空则将尾结点的next结点指向newNode，否则将头结点指向newNode</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-2-add-int-index-E-element"><a href="#4-2-2-add-int-index-E-element" class="headerlink" title="4.2.2 add(int index, E element)"></a>4.2.2 add(int index, E element)</h4><p>先check，如果插入的还是尾部，则调用 linkLast 方法，否则先获取到索引 index 对应的节点然后调用 linkBefore 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建一个 prev 指针是索引 index - 1 对应节点，next节点是索引 index 对应节点的新节点newNode **(图中绿色部分)**。然后把index节点的prev指向newNode <strong>(图中蓝色部分)<strong>，如果要插入的是第一个位置，则把 first 指针指向newNode，否则维护剩余的指针关系(index - 1 节点的next指向newNode)</strong>(图中红色部分)</strong></p><p><a href="http://qiniu.itliusir.com/linkedlist02.png"><img src="http://qiniu.itliusir.com/linkedlist02.png" alt="img"></a></p><h3 id="4-3-更新元素"><a href="#4-3-更新元素" class="headerlink" title="4.3 更新元素"></a>4.3 更新元素</h3><p>根据下标位置获取节点，然后把节点的值进行覆盖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-删除元素"><a href="#4-4-删除元素" class="headerlink" title="4.4 删除元素"></a>4.4 删除元素</h3><h4 id="4-4-1-remove-int-index"><a href="#4-4-1-remove-int-index" class="headerlink" title="4.4.1 remove(int index)"></a>4.4.1 remove(int index)</h4><p>先check，然后先获取index对应节点最后调用unlink方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同按照下标新增那块逻辑差不多，去除一个节点(prev next item置null)，重新维护指针关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-2-remove-Object-o"><a href="#4-4-2-remove-Object-o" class="headerlink" title="4.4.2 remove(Object o)"></a>4.4.2 remove(Object o)</h4><p>遍历要找的元素的index，然后调用unlink方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-3-clear"><a href="#4-4-3-clear" class="headerlink" title="4.4.3 clear()"></a>4.4.3 clear()</h4><p>遍历赋值null，size重置为0</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedList </tag>
            
            <tag> Deque </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList 源码分析</title>
      <link href="/2017/01-ArrayList/"/>
      <url>/2017/01-ArrayList/</url>
      
        <content type="html"><![CDATA[<h2 id="TOP-带着问题看源码"><a href="#TOP-带着问题看源码" class="headerlink" title="TOP 带着问题看源码"></a>TOP 带着问题看源码</h2><ol><li>List list = new ArrayList(20) 扩容了几次</li><li>ArrayList 怎么实现数组动态扩容，扩容时机，扩容倍数</li><li>ArrayList 怎么实现remove的</li><li>为什么remove具体元素性能差</li><li>ArrayList 是怎么序列化的</li></ol><span id="more"></span><h2 id="1-继承和实现关系"><a href="#1-继承和实现关系" class="headerlink" title="1. 继承和实现关系"></a>1. 继承和实现关系</h2><p><a href="http://qiniu.itliusir.com/arraylist01.png"><img src="http://qiniu.itliusir.com/arraylist01.png" alt="img"></a></p><ul><li><p><em>RandomAccess 接口</em></p><p>标记该类具有快速随机访问能力。当一个集合拥有该能力时候，采用for循环遍历会很快；若没有则采用Iterator迭代器最快。参考ArrayList的indexOf(Object o)方法和AbstractList的indexOf(Object o)方法区别。</p></li><li><p><em>Serializable 接口</em></p><p>标记该类是可序列化的。</p></li><li><p><em>Cloneable 接口</em></p><p>标记该类对象能够被Object.clone()</p><p>根据重写的clone方法实现主要分为如下两种克隆方式</p><ol><li><p>浅克隆</p><p>只copy对象本身和对象中的基本变量，不copy包含引用的对象</p></li><li><p>深克隆</p><p>不仅copy对象本身，还copy对象包含的引用对象</p></li></ol></li><li><p><em>AbstractList 抽象类</em></p><p> 提供一些基础方法: IndexOf、clear、addAll、iterator等</p></li></ul><h2 id="2-成员变量分析"><a href="#2-成员变量分析" class="headerlink" title="2. 成员变量分析"></a>2. 成员变量分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 空数组实例(为0时候)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">// 默认大小时候的空数组实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">// 存储数组</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="comment">// 数组大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">// 数组最大容量，减8是因为可能一些VM会在数组保留一些header，防止OOM</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure><h2 id="3-构造方法分析"><a href="#3-构造方法分析" class="headerlink" title="3. 构造方法分析"></a>3. 构造方法分析</h2><h3 id="3-1-无参构造方法"><a href="#3-1-无参构造方法" class="headerlink" title="3.1 无参构造方法"></a>3.1 无参构造方法</h3><p>默认赋值一个空数组实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-带初始化容量的构造方法"><a href="#3-2-带初始化容量的构造方法" class="headerlink" title="3.2 带初始化容量的构造方法"></a>3.2 带初始化容量的构造方法</h3><p>可以看到是由参数的大小来创建对应大小的 elementData 数组，回到 <strong>TOP 1</strong> 问题，可以看出来不会发生扩容，也就是0次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-带集合内容的构造方法"><a href="#3-3-带集合内容的构造方法" class="headerlink" title="3.3 带集合内容的构造方法"></a>3.3 带集合内容的构造方法</h3><p>把传过来的集合转化为数组赋值给 elementData 数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-核心方法分析"><a href="#4-核心方法分析" class="headerlink" title="4. 核心方法分析"></a>4. 核心方法分析</h2><h3 id="4-1-获取元素"><a href="#4-1-获取元素" class="headerlink" title="4.1 获取元素"></a>4.1 获取元素</h3><p>先 check ，再按照 index 取。check也是为了保证工程中不会出现奇奇怪怪的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 final 修饰的数组来接收存储数组，对其遍历。 modCount 变量和 final 修饰的 expectedModCount 进行对比来判断是否存在并发读写情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">final</span> E[] elementData = (E[]) <span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">        action.accept(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-新增元素"><a href="#4-2-新增元素" class="headerlink" title="4.2 新增元素"></a>4.2 新增元素</h3><h4 id="4-2-1-add-E-e"><a href="#4-2-1-add-E-e" class="headerlink" title="4.2.1 add(E e)"></a>4.2.1 add(E e)</h4><p>把一个元素新增到elementData，主要涉及如下几点</p><ol><li>modCount++ 声明我新增元素了，在并发情况下起到容量是否发生变化作用</li><li>如果容量不足，则扩容数组大小(参考下面grow方法)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####4.2.2 add(int index, E element)</p><p>按照index位置来插入元素，和上面方法同理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####4.2.3 grow(int minCapacity)</p><p>第4行可以看到，使用位运算扩容了 1.5 倍大小空间，至于为啥是1.5倍，我猜是经验值。</p><p>回到 <strong>TOP 2</strong> 问题，可以明白了扩容机制是通过数组 copy方式，时机就是容量不够的时候，倍数是1.5倍</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-更新元素"><a href="#4-3-更新元素" class="headerlink" title="4.3 更新元素"></a>4.3 更新元素</h3><p>直接数组下标覆盖，返回旧值，至于为什么返回的是旧值，可能一方面是根据下标查询不是很影响性能索性给查询出来，另一方面下标和新值请求者都清楚也没必要返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-删除元素"><a href="#4-4-删除元素" class="headerlink" title="4.4 删除元素"></a>4.4 删除元素</h3><h4 id="4-4-1-remove-int-index"><a href="#4-4-1-remove-int-index" class="headerlink" title="4.4.1 remove(int index)"></a>4.4.1 remove(int index)</h4><p>计算要删除的下标后一位到数组末尾的长度，然后通过copy这段长度覆盖到原数组的位置，最后把最后一位置null,实现删除。</p><p>回到 <strong>TOP 3</strong> 问题，可以明白删除机制也是通过数组copy覆盖的思想来实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">        <span class="comment">// 计算长度</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// param1: 源数组</span></span><br><span class="line">        <span class="comment">// param2: 源数组要复制的起始位置</span></span><br><span class="line">        <span class="comment">// param3: 目标数组</span></span><br><span class="line">        <span class="comment">// param4: 目标数组放置的起始位置</span></span><br><span class="line">        <span class="comment">// param5: 复制的长度</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####4.4.2 remove(Object o)</p><p>首先分为两个场景，第一个是要删除的元素是null，第二个是要删除的是非null的。</p><p>主要是遍历要找的元素，找到该元素对应的index，然后使用 fastRemove(index) 去快速删除</p><p>回到 <strong>TOP 4</strong> 问题，可以明白计算某个元素下标的时间复杂度是 O(n) 的，所以性能没有直接根据下标删除好</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-3-fastRemove-int-index"><a href="#4-4-3-fastRemove-int-index" class="headerlink" title="4.4.3 fastRemove(int index)"></a>4.4.3 fastRemove(int index)</h4><p>因为调用该方法都是内部计算index后调用的，所以不需要再校验index是否越界，也不需要返回oldValue。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-4-clear"><a href="#4-4-4-clear" class="headerlink" title="4.4.4 clear()"></a>4.4.4 clear()</h4><p>遍历赋值null，size重置为0</p><h2 id="5-序列化"><a href="#5-序列化" class="headerlink" title="5. 序列化"></a>5. 序列化</h2><p>首先我们在最开始就有介绍 ArrayList 类实现的有 Serializable 接口，但是我们在成员变量那一节看到的存储数组 elementData 是有 <code>transient</code> 修饰的，也就是elementData不会参与默认序列化，那实现这个 Serializable 接口还有意义么？</p><p>其实仔细观察类里的方法你会发现有两个与序列化的流有关系的方法：<code>writeObject</code> 、<code>readObject</code></p><p>在序列化过程中如果有这两个方法，会默认调用这两个方法进行用户自定义的序列化和反序列化，如果没有才走默认序列化。</p><p>那么我们知道作者的序列化是自定义了，那为什么这样做呢，为什么不直接使用默认序列化呢？</p><p>我们可以想下，每次扩容1.5倍，那这个数组实际会有一些空间扩容后还未被填充，如果使用默认序列化则会将null也给序列化进去。</p><p>接下来我们来看一下自定义序列化方法具体的实现：</p><h3 id="5-1-writeObject"><a href="#5-1-writeObject" class="headerlink" title="5.1 writeObject"></a>5.1 writeObject</h3><p>写入数组大小，遍历写入数组元素，检查并发冲突</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-readObject"><a href="#5-2-readObject" class="headerlink" title="5.2 readObject"></a>5.2 readObject</h3><p>初始化存储数组elementData，读取写入的数组大小，构造数组并写入元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in capacity</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        <span class="keyword">int</span> capacity = calculateCapacity(elementData, size);</span><br><span class="line">        SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);</span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到 <strong>TOP 5</strong> 问题，可以明白 ArrayList 序列化采用的是自定义序列化方式</p><h3 id="5-3-自定义序列化的原理"><a href="#5-3-自定义序列化的原理" class="headerlink" title="5.3 自定义序列化的原理"></a>5.3 自定义序列化的原理</h3><p>通过跟踪ObjectOutputStream的writeObject()方法，调用链路如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writeObject -&gt; writeObject0 -&gt; writeOrdinaryObject -&gt; writeSerialData</span><br></pre></td></tr></table></figure><p>代码如下所示，可以看到会先判断是否有 writeObject 方法，如果有的话，会通过反射的方式调用序列化对象的writeObject方法，如果没有则使用默认序列化方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeSerialData</span><span class="params">(Object obj, ObjectStreamClass desc)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; slots.length; i++) &#123;</span><br><span class="line">        ObjectStreamClass slotDesc = slots[i].desc;</span><br><span class="line">        <span class="keyword">if</span> (slotDesc.hasWriteObjectMethod()) &#123;</span><br><span class="line">            PutFieldImpl oldPut = curPut;</span><br><span class="line">            curPut = <span class="keyword">null</span>;</span><br><span class="line">            SerialCallbackContext oldContext = curContext;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                debugInfoStack.push(</span><br><span class="line">                    <span class="string">&quot;custom writeObject data (class \&quot;&quot;</span> +</span><br><span class="line">                    slotDesc.getName() + <span class="string">&quot;\&quot;)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                curContext = <span class="keyword">new</span> SerialCallbackContext(obj, slotDesc);</span><br><span class="line">                bout.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">                slotDesc.invokeWriteObject(obj, <span class="keyword">this</span>);</span><br><span class="line">                bout.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">                bout.writeByte(TC_ENDBLOCKDATA);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                curContext.setUsed();</span><br><span class="line">                curContext = oldContext;</span><br><span class="line">                <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                    debugInfoStack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            curPut = oldPut;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            defaultWriteFields(obj, slotDesc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ArrayList </tag>
            
            <tag> remove </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
